<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="ImaginingMe">
    <meta name="keyword"  content="frontend">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
        nodejs-why-and-how-and-what - 前端技术分享 | AnitaK&#39;s Blog
        
    </title>

    <!-- Custom CSS -->
    
<link rel="stylesheet" href="/css/aircloud.css">

    
<link rel="stylesheet" href="/css/gitment.css">

    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
<meta name="generator" content="Hexo 5.0.0"></head>

<body>

<div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i> DICHTEN == CONDENSARE </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar ">
            <img src="http://www.imaginingme.cn/img/avatar.jpeg" />
        </div>
        <div class="name">
            <i>ImaginingMe</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li >
                <a href="/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>主页</span>
                </a>
            </li>
            <li >
                <a href="/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li>
            <li >
                <a href="/archive">
                    <i class="iconfont icon-guidang2"></i>
                    <span>存档</span>
                </a>
            </li>
            <li >
                <a href="/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>关于</span>
                </a>
            </li>
            
            <li>
                <a id="search">
                    <i class="iconfont icon-sousuo1"></i>
                    <span>搜索</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#arch"><span class="toc-text">arch</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#nodejs%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97"><span class="toc-text">nodejs内置模块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#EventEmitter"><span class="toc-text">EventEmitter</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5"><span class="toc-text">异步</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E9%98%BB%E5%A1%9EI-O"><span class="toc-text">非阻塞I&#x2F;O</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#callback"><span class="toc-text">callback</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#throw-Error"><span class="toc-text">throw Error</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF"><span class="toc-text">事件循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Promise"><span class="toc-text">Promise</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#What"><span class="toc-text">What</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#async-await"><span class="toc-text">async&#x2F;await</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#http"><span class="toc-text">http</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Express"><span class="toc-text">Express</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Koa"><span class="toc-text">Koa</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RPC"><span class="toc-text">RPC</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%92%8CAjax%E7%9A%84%E6%AF%94%E8%BE%83-%E7%9B%B8%E5%90%8C"><span class="toc-text">和Ajax的比较-相同</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%92%8CAjax%E7%9A%84%E6%AF%94%E8%BE%83-%E5%B7%AE%E5%BC%82"><span class="toc-text">和Ajax的比较-差异</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RPC%E8%B0%83%E7%94%A8"><span class="toc-text">RPC调用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Buffer%E7%BC%96%E8%A7%A3%E7%A0%81%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E6%8D%AE%E5%8C%85"><span class="toc-text">Buffer编解码二进制数据包</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%A7%E5%B0%8F%E7%AB%AF%E9%97%AE%E9%A2%98"><span class="toc-text">大小端问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%E4%B8%8EString%E6%8E%A5%E8%BF%91"><span class="toc-text">处理方法与String接近</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Protocol-Buffer"><span class="toc-text">Protocol Buffer</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#net-%E6%90%AD%E5%BB%BA%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E7%9A%84RPC%E9%80%9A%E9%81%93"><span class="toc-text">net 搭建多路复用的RPC通道</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#source-code"><span class="toc-text">source code</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97"><span class="toc-text">内置模块</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#basic"><span class="toc-text">basic</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#globals"><span class="toc-text">globals</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#process"><span class="toc-text">process</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80"><span class="toc-text">其他语言</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#golang"><span class="toc-text">golang</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#erlang"><span class="toc-text">erlang</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#performance"><span class="toc-text">performance</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#http%E6%9C%8D%E5%8A%A1%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95"><span class="toc-text">http服务性能测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#nodejs%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7"><span class="toc-text">nodejs性能分析工具</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#js%E4%BB%A3%E7%A0%81%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-text">js代码性能优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%E7%AE%A1%E7%90%86"><span class="toc-text">内存优化管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E6%8F%92%E4%BB%B6"><span class="toc-text">C++插件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#nodejs%E5%AD%90%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B"><span class="toc-text">nodejs子进程与线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cluster"><span class="toc-text">cluster</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%AE%88%E6%8A%A4"><span class="toc-text">进程守护</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E9%9D%99%E5%88%86%E7%A6%BB"><span class="toc-text">动静分离</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Tools"><span class="toc-text">Tools</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#volta-The-Hassle-Free-JavaScript-Tool-Manager"><span class="toc-text">volta - The Hassle-Free JavaScript Tool Manager</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%B7%A5%E7%A8%8B%E5%8C%96"><span class="toc-text">框架设计和工程化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-text">设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-text">观察者模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F"><span class="toc-text">外观模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E5%8E%9F%E5%88%99"><span class="toc-text">6原则</span></a></li></ol></li></ol></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input"/>
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>

        <div class="index-about-mobile">
            <i> DICHTEN == CONDENSARE </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        


<div class="post-container">
    <div class="post-title">
        nodejs-why-and-how-and-what
    </div>

    <div class="post-meta">
        <span class="attr">发布于：<span>2022-01-29 21:52:08</span></span>
        
        </span>
        <span class="attr">访问：<span id="busuanzi_value_page_pv"></span>
</span>
</span>
    </div>
    <div class="post-content ">
        <ul>
<li>性能，并发性，可用性，可靠性，可扩展性</li>
<li>从开始设计，用于构建实时和并发系统</li>
<li>发展，改进中</li>
</ul>
<h2 id="arch"><a href="#arch" class="headerlink" title="arch"></a>arch</h2><ul>
<li>the node.js system</li>
<li>application - v8 - javascript engine</li>
<li>node.js bindings - node api - os operation</li>
<li>libuv - asysnchronous I/O - event queue - event loop - worker threads - file system|network|process - blocking operation|execute callback</li>
<li>nodejs线程 | c++线程<h2 id="nodejs内置模块"><a href="#nodejs内置模块" class="headerlink" title="nodejs内置模块"></a>nodejs内置模块</h2></li>
</ul>
<h3 id="EventEmitter"><a href="#EventEmitter" class="headerlink" title="EventEmitter"></a>EventEmitter</h3><ul>
<li>观察者模式<ul>
<li>addEventListener | removeEventListener</li>
<li>调用|抛事件</li>
<li>谁在听 | 听没听<h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><h3 id="非阻塞I-O"><a href="#非阻塞I-O" class="headerlink" title="非阻塞I/O"></a>非阻塞I/O</h3></li>
</ul>
</li>
<li>Input/Output 系统的输入和输出</li>
<li>阻塞？ 系统接收输入到再输出期间，能否接收其它输入<br>（与阻塞 I/O系统相比，非阻塞 I/O系统提高了 CPU的利用率，可以执行更多的任务，使用更少的时间）</li>
</ul>
<h3 id="callback"><a href="#callback" class="headerlink" title="callback"></a>callback</h3><ul>
<li>func格式规范 - error-first！！！ | node-style callback</li>
<li>异步流程控制 - 回调地狱 | 异步并发（A&amp;&amp;B =&gt; Do C）- 就要加计数器等一堆逻辑来达成</li>
<li>history - package-async.js | thunk-编程范式</li>
</ul>
<h3 id="throw-Error"><a href="#throw-Error" class="headerlink" title="throw Error"></a>throw Error</h3><ul>
<li>全局的会导致程序崩溃</li>
<li>call stack 调用栈 | try catch 如果不在包裹内，则无法捕捉</li>
<li>事件循环 - setTimeout | 注意捕捉范围<h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3></li>
<li>event loop</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop">https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop</a></li>
<li><a target="_blank" rel="noopener" href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/#what-is-the-event-loop">https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/#what-is-the-event-loop</a></li>
<li>理解调用栈<br>(理解好浏览器和node环境的差异，为什么需要eventloop，为什么node端的是更精细化的设计)</li>
<li>browser (<a target="_blank" rel="noopener" href="https://github.com/luokuning/blogs/issues/1">https://github.com/luokuning/blogs/issues/1</a> - Object.observe为什么要被移除)<h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><h4 id="What"><a href="#What" class="headerlink" title="What"></a>What</h4></li>
<li>当前事件循环得不到的结果，未来的事件循环会给到结果</li>
<li>状态机 - pending =&gt; fulfilled/resolved | rejected</li>
<li>.then | .catch</li>
<li>rejected状态后无.catch的Promise，会造成browser｜node环境的全局错误</li>
<li>执行then，catch之后会返回一个新的Promise，该Promise的最终状态根据回调函数的执行结果决定</li>
<li>回调函数：throw -&gt; Promise状态是： rejected | return -&gt; resolved</li>
<li>如果回调函数return了一个Promise，这个Promise会和回调函数return的Promise状态保持一致</li>
<li>Promise.all  并发异步，catch拿第一个error的<h3 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h3></li>
<li>async function 是 Promise的语法糖封装(console出来可以验证)</li>
<li>以同步的方式写异步-异步编程终极方案</li>
<li>以同步的写法获取Promise的执行结果            </li>
<li>try-catch可以获取await得到的错误</li>
<li>Event Loop -&gt; 逻辑思维上的转变</li>
<li>并行异步任务 -&gt; +Promise.all</li>
</ul>
<h3 id="http"><a href="#http" class="headerlink" title="http"></a>http</h3><ul>
<li>http服务 -&gt; 解析请求报文 &amp;&amp; 返回对应的返回报文</li>
<li>IncomingMessage - Class - doc<h4 id="Express"><a href="#Express" class="headerlink" title="Express"></a>Express</h4>Express - http服务框架</li>
<li>核心功能 &amp;&amp; 解决的问题 -&gt; what - 路由&amp;&amp;(req&amp;&amp;res简化)&amp;&amp;middleware | why</li>
<li>middleware - 组织流程代码 ｜ 异步会打破express的洋葱模型</li>
<li><a target="_blank" rel="noopener" href="https://www.npmjs.com/package/express">https://www.npmjs.com/package/express</a><h4 id="Koa"><a href="#Koa" class="headerlink" title="Koa"></a>Koa</h4></li>
<li>(req&amp;&amp;res简化) - 更简单明了</li>
<li>async - 在异步情况下，也符合洋葱模型</li>
<li>精简内核，额外功能都移到了middleware实现</li>
</ul>
<h3 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h3><ul>
<li>Remote Procedure Call<h4 id="和Ajax的比较-相同"><a href="#和Ajax的比较-相同" class="headerlink" title="和Ajax的比较-相同"></a>和Ajax的比较-相同</h4></li>
<li>两端的网络通信</li>
<li>需要约定数据格式</li>
</ul>
<h4 id="和Ajax的比较-差异"><a href="#和Ajax的比较-差异" class="headerlink" title="和Ajax的比较-差异"></a>和Ajax的比较-差异</h4><ul>
<li>不一定使用DNS作为寻址服务</li>
<li>应用层协议一般不使用HTTP</li>
<li>基于TCP或者UDP协议</li>
</ul>
<h4 id="RPC调用"><a href="#RPC调用" class="headerlink" title="RPC调用"></a>RPC调用</h4><ul>
<li><p>寻址｜负载均衡</p>
<ul>
<li>Ajax使用DNS进行寻址</li>
<li>RPC使用特有服务进行寻址</li>
</ul>
</li>
<li><p>TCP通信方式</p>
<ul>
<li>单工通信</li>
<li>半双工通信</li>
<li>全双工通信</li>
</ul>
</li>
<li><p>二进制协议</p>
<ul>
<li>更小的数据包体积</li>
<li>更快的编解码速率</li>
</ul>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/tars-node">https://github.com/tars-node</a> </p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/tars-node/rpc">https://github.com/tars-node/rpc</a></p>
</li>
</ul>
<h3 id="Buffer编解码二进制数据包"><a href="#Buffer编解码二进制数据包" class="headerlink" title="Buffer编解码二进制数据包"></a>Buffer编解码二进制数据包</h3><h4 id="大小端问题"><a href="#大小端问题" class="headerlink" title="大小端问题"></a>大小端问题</h4><ul>
<li>几个Byte里，高位与低位的编排顺序不同<h4 id="处理方法与String接近"><a href="#处理方法与String接近" class="headerlink" title="处理方法与String接近"></a>处理方法与String接近</h4></li>
<li>使用concat 而不是 + ，避免utf-8字符拼接问题<h4 id="Protocol-Buffer"><a href="#Protocol-Buffer" class="headerlink" title="Protocol Buffer"></a>Protocol Buffer</h4></li>
<li>Google研发的二进制协议编解码库</li>
<li>通过协议文件控制Buffer的格式 - 直观｜好维护｜方便协作</li>
</ul>
<h3 id="net-搭建多路复用的RPC通道"><a href="#net-搭建多路复用的RPC通道" class="headerlink" title="net 搭建多路复用的RPC通道"></a>net 搭建多路复用的RPC通道</h3><ul>
<li>单工｜半双工的通信通道搭建</li>
<li>全双工的通信通道搭建<ul>
<li>应用层协议需要有标记包号的字段</li>
<li>需要有标记包长的字段（粘包，不完整包）</li>
<li>错误处理</li>
</ul>
</li>
<li>netty - java的rpc通信<h2 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h2><h4 id="内置模块"><a href="#内置模块" class="headerlink" title="内置模块"></a>内置模块</h4></li>
<li>os.js - internalBinding - node_os.cc - libuv</li>
<li>v8</li>
<li></li>
</ul>
<h2 id="basic"><a href="#basic" class="headerlink" title="basic"></a>basic</h2><h3 id="globals"><a href="#globals" class="headerlink" title="globals"></a>globals</h3><h4 id="process"><a href="#process" class="headerlink" title="process"></a>process</h4><ul>
<li>A swiss army knife global. An Object that contains all the context you need about the current program being executed. Things from env vars, to what machine you’re on.<figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">当 Node.js 进程收到信号时，则将触发信号事件。 </span><br><span class="line">Linux supports the standard signals listed below.  The second</span><br><span class="line">       column <span class="keyword">of</span> the table indicates which standard (<span class="keyword">if</span> any) specified</span><br><span class="line">       the <span class="keyword">signal</span><span class="string"></span>: <span class="string">&quot;P1990&quot;</span> indicates that the <span class="keyword">signal</span><span class="string"> is described in the</span></span><br><span class="line">       original POSIX<span class="number">.1</span><span class="number">-1990</span> standard; <span class="string">&quot;P2001&quot;</span> indicates that the <span class="keyword">signal</span><span class="string"></span></span><br><span class="line">       was added <span class="keyword">in</span> SUSv2 and POSIX<span class="number">.1</span><span class="number">-2001.</span></span><br><span class="line">       </span><br><span class="line">process.on(<span class="string">&#x27;SIGINT&#x27;</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Received SIGINT. Press Control-D to exit.&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man7/signal.7.html">https://man7.org/linux/man-pages/man7/signal.7.html</a> -   SIGINT-P1990-Term-Interrupt from keyboard</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">Windows</span> 不支持信号，因此没有等价的使用信号来终止，但 <span class="selector-tag">Node</span><span class="selector-class">.js</span> 提供了一些对 <span class="selector-tag">process</span><span class="selector-class">.kill</span>() 和 <span class="selector-tag">subprocess</span><span class="selector-class">.kill</span>() 的模拟：</span><br><span class="line"></span><br><span class="line">发送 <span class="selector-tag">SIGINT</span>、<span class="selector-tag">SIGTERM</span>、和 <span class="selector-tag">SIGKILL</span> 会导致目标进程无条件的终止，之后子进程会报告进程被信号终止。</span><br><span class="line">发送信号 0 可以作为独立于平台的方式来测试进程是否存在。</span><br></pre></td></tr></table></figure>










<h2 id="其他语言"><a href="#其他语言" class="headerlink" title="其他语言"></a>其他语言</h2><h3 id="golang"><a href="#golang" class="headerlink" title="golang"></a>golang</h3><ul>
<li>coroutines<h3 id="erlang"><a href="#erlang" class="headerlink" title="erlang"></a>erlang</h3></li>
<li>抢占式调度</li>
</ul>
<h2 id="performance"><a href="#performance" class="headerlink" title="performance"></a>performance</h2><h4 id="http服务性能测试"><a href="#http服务性能测试" class="headerlink" title="http服务性能测试"></a>http服务性能测试</h4><ul>
<li>优化性能的前提 - 性能检查</li>
<li>压测工具 - ab|webbench</li>
<li>服务器性能指标 - QPS｜吞吐量</li>
<li>找到性能瓶颈 - top|iostat</li>
</ul>
<h4 id="nodejs性能分析工具"><a href="#nodejs性能分析工具" class="headerlink" title="nodejs性能分析工具"></a>nodejs性能分析工具</h4><ul>
<li>nodejs - profile</li>
<li>chrome devtool</li>
<li>npm - clinic</li>
</ul>
<h4 id="js代码性能优化"><a href="#js代码性能优化" class="headerlink" title="js代码性能优化"></a>js代码性能优化</h4><ul>
<li>根据性能分析结果优化</li>
<li>准则<ul>
<li>减少不必要的计算 - 提前计算（启动阶段？服务阶段）</li>
<li>空间换时间？</li>
</ul>
</li>
</ul>
<h4 id="内存优化管理"><a href="#内存优化管理" class="headerlink" title="内存优化管理"></a>内存优化管理</h4><ul>
<li>垃圾回收<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">新生代 - 容量小，垃圾回收更快</span><br><span class="line">老生代 - 容量大，垃圾回收更慢</span><br><span class="line">减少内存使用，是提高服务性能的手段</span><br><span class="line">内存泄漏会导致服务性能问题</span><br></pre></td></tr></table></figure></li>
<li>nodejs buffer 的内存分配策略</li>
<li>节省内存的最好方式是 - 使用池</li>
</ul>
<h4 id="C-插件"><a href="#C-插件" class="headerlink" title="C++插件"></a>C++插件</h4><ul>
<li>编译环境<ul>
<li>node-gyp(node-gyp本身，对应的node版本编译环境)</li>
<li>python</li>
</ul>
</li>
<li>将计算量转移到C++进行<ul>
<li>收益：C++运算比JS更快的部分｜成本：C++变量和V8变量的转换</li>
</ul>
</li>
</ul>
<h4 id="nodejs子进程与线程"><a href="#nodejs子进程与线程" class="headerlink" title="nodejs子进程与线程"></a>nodejs子进程与线程</h4><ul>
<li>进程（操作系统挂载运行程序的单元｜拥有一些独立的资源，如内存等）</li>
<li>线程（进行运算调度的单元｜进程内的线程共享进程内的资源）</li>
<li>nodejs的事件循环<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">- </span>主进程运行v8与Javascript</span><br><span class="line"><span class="bullet">- </span>多个子线程通过时间循环被调度</span><br></pre></td></tr></table></figure></li>
<li>使用子进程或者线程利用更多的CPU资源</li>
</ul>
<h4 id="cluster"><a href="#cluster" class="headerlink" title="cluster"></a>cluster</h4><ul>
<li>主进程启动多个子进程，由主进程轮流分发请求，子进程代为处理</li>
</ul>
<h4 id="进程守护"><a href="#进程守护" class="headerlink" title="进程守护"></a>进程守护</h4><ul>
<li>nodejs的稳定性</li>
<li>防止僵尸进程（心跳）</li>
<li>死亡重启</li>
<li>数据监控</li>
</ul>
<h3 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h3><ul>
<li>静态内容-基本不会变动，也不会因为请求参数不同而变化 -&gt; CDN分发，http缓存</li>
<li>动态内容-各种因为请求参数不同而变动，且变种的数量几乎不可枚举 -&gt; 加机器，结合反响代理进行负载均衡<h2 id="Tools"><a href="#Tools" class="headerlink" title="Tools"></a>Tools</h2><h4 id="volta-The-Hassle-Free-JavaScript-Tool-Manager"><a href="#volta-The-Hassle-Free-JavaScript-Tool-Manager" class="headerlink" title="volta - The Hassle-Free JavaScript Tool Manager"></a>volta - The Hassle-Free JavaScript Tool Manager</h4></li>
<li><a target="_blank" rel="noopener" href="https://volta.sh/">https://volta.sh/</a></li>
</ul>
<h2 id="框架设计和工程化"><a href="#框架设计和工程化" class="headerlink" title="框架设计和工程化"></a>框架设计和工程化</h2><blockquote>
<p>软件质量体系，<a target="_blank" rel="noopener" href="https://juejin.cn/post/6990365231348187150">https://juejin.cn/post/6990365231348187150</a> - 设计模式经典书籍</p>
</blockquote>
<ul>
<li><p>架构设计 （底层更稳固-&gt;程序不容易崩溃，容易往上搭-扩展新功能更方便）</p>
</li>
<li><p>工程工具（更加易于施工-学习上手成本低，保证施工安全-不会因为操作失误搞挂程序）</p>
</li>
<li><p>给工程师使用的产品</p>
<ul>
<li>开发体验（可维护性，可靠性，易用性）</li>
<li>KISS（Vue渐进式）</li>
</ul>
</li>
</ul>
<h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><ul>
<li>模式只是达到目的的手段</li>
<li>PD这本书-1995-基于Java语言本身的一些特性-elements of reusable object-oriented software<h4 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h4></li>
<li>EventEmitter（node-process）</li>
<li>DOM addEventListener<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">在 Node.<span class="keyword">js </span>中，EventEmitter 是一个用于处理事件的模块。它提供了一种基于观察者模式的异步编程方式，可以在需要时触发事件和处理事件。以下是一些使用 EventEmitter 的常见场景：</span><br><span class="line"></span><br><span class="line">数据库连接：当使用 Node.<span class="keyword">js </span>连接到数据库时，可以使用 EventEmitter 来处理成功或失败的情况，并确保连接正确关闭。</span><br><span class="line"></span><br><span class="line">网络编程：在编写网络应用程序时，使用 EventEmitter 可以轻松地管理套接字和客户端连接，并处理相关的事件，例如数据传输、断开连接等。</span><br><span class="line"></span><br><span class="line">文件系统：Node.<span class="keyword">js </span>的文件系统模块也使用 EventEmitter 来通知进程有关文件操作的事件（如读取、写入、删除等）。</span><br><span class="line"></span><br><span class="line">自定义事件：通过继承 EventEmitter 类并添加自己的方法和属性，可以创建自己的类，并发出自定义事件来实现各种功能。</span><br><span class="line"></span><br><span class="line">总之，EventEmitter 在 Node.<span class="keyword">js </span>中非常常用，几乎在任何需要处理异步事件的场景中都可能会用到。无论是处理数据库连接、网络编程还是文件系统操作，使用 EventEmitter 都可以帮助我们轻松地管理异步事件，保持代码的模块化和可读性。</span><br><span class="line"></span><br><span class="line">观察者模式是一种设计模式，用于处理对象间的一对多依赖关系，并在对象状态发生变化时自动通知所有依赖项。在观察者模式中，被观察的对象称作主题（<span class="keyword">Subject），而观察它的对象称为观察者（Observer）。</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">观察者模式的主要思想是，当主题对象状态发生变化时，它会通知所有已注册的观察者对象，并调用它们的更新方法来执行相应的操作。这使得主题和观察者可以解耦，避免了紧密耦合的代码结构，也提高了系统的可扩展性和可维护性。</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">观察者模式通常包括以下角色：</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">主题（Subject）：被观察的对象，它包含了观察者需要监视的状态以及注册和删除观察者的方法。</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">观察者（Observer）：观察主题对象的状态，并在状态发生变化时执行相应的操作。</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">具体主题（Concrete </span><span class="keyword">Subject）：具体的被观察对象，它维护了一个观察者列表，并且负责通知所有已注册的观察者。</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">具体观察者（Concrete </span>Observer）：具体的观察者对象，实现了更新方法，并定义了在主题状态发生变化时所执行的操作。</span><br><span class="line"></span><br><span class="line">观察者模式可以应用于许多场景，例如GUI事件处理、文档自动保存、股票市场监控等。它可以帮助我们实现松耦合的代码结构，并提高系统的可扩展性和可维护性。</span><br><span class="line"></span><br><span class="line">RxJS (Reactive <span class="keyword">Extensions </span>for <span class="keyword">JavaScript) </span>is a library for reactive programming using Observables to handle asynchronous <span class="keyword">and </span>event-<span class="keyword">based </span>workflows in <span class="keyword">JavaScript. </span>It provides operators for transforming, filtering, combining, <span class="keyword">and </span>querying data streams, as well as utilities for managing <span class="keyword">subscriptions </span><span class="keyword">and </span>handling errors. RxJS is commonly used in front-end web development with frameworks such as Angular <span class="keyword">or </span>React.</span><br><span class="line">RxJS 的使用场景主要是处理复杂的异步和事件驱动场景，例如：</span><br><span class="line"></span><br><span class="line">处理 HTTP 请求：RxJS 的 Observable 类型可以方便地处理 HTTP 请求和响应，并使用操作符进行数据转换、筛选和组合。</span><br><span class="line"></span><br><span class="line">处理用户界面输入：RxJS 可以处理用户界面上的各种事件（如点击、滚动、输入等），并将它们转换成 Observable 流，使得开发者可以方便地编写响应式代码。</span><br><span class="line"></span><br><span class="line">处理 WebSocket 数据流：RxJS 可以轻松处理 WebSocket 数据流，并基于数据流执行各种操作，例如过滤、聚合、映射等。</span><br><span class="line"></span><br><span class="line">处理复杂的状态管理：RxJS 可以用于处理复杂的状态管理场景，例如 Redux 和 NgRx 中的数据流管理和副作用管理。</span><br><span class="line"></span><br><span class="line">处理数据可视化：RxJS 可以用于实现数据可视化和动画效果，例如基于数据流控制图表的更新和动画过渡效果。</span><br><span class="line"></span><br><span class="line">总之，RxJS 主要适用于需要处理异步和事件驱动场景的项目，尤其是在需要对数据进行转换、组合和筛选时。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h4><ul>
<li>jQuery（解决兼容性问题）<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">elem.on(<span class="string">&#x27;&#x27;</span>, <span class="function"><span class="keyword">func</span>)</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">else</span> - 各种浏览器</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="6原则"><a href="#6原则" class="headerlink" title="6原则"></a>6原则</h4><ul>
<li>单一职责 (微服务) - 每一个模块都有明确的功能</li>
<li>开闭原则 - 对扩展开放，对修改关闭 - css-loader ts-loader| webpack - 新增功能只需要增加模块，不需要修改原有部分<br>。。。like lego</li>
</ul>

        
            <div class="donate-container">
    <div class="donate-button">
        <button id="donate-button">赞赏</button>
    </div>
    <div class="donate-img-container hide" id="donate-img-container">
        <img id="donate-img" src="" data-src="img/donate.jpg">
        <p> 感谢鼓励 </p>
    </div>
</div>
        
        <br />
        <div id="comment-container">
        </div>
        <div id="disqus_thread"></div>

        <div id="lv-container">
        </div>

    </div>
</div>

    </div>
</div>


<footer class="footer">
    <ul class="list-inline text-center">
        
        

        

        

        
        <li>
            <a target="_blank"  href="https://github.com/anitakym">
                            <span class="fa-stack fa-lg">
                                <i class="iconfont icon-github"></i>
                            </span>
            </a>
        </li>
        

        

    </ul>
    
    <a target="_blank" rel="noopener" href="https://beian.miit.gov.cn/"><p>京ICP备19049908号-1</p></a>
    <p>
        <span id="busuanzi_container_site_pv">
            <span id="busuanzi_value_site_pv"></span>PV
        </span>
        <span id="busuanzi_container_site_uv">
            <span id="busuanzi_value_site_uv"></span>UV
        </span>
        Created By <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>  Theme <a target="_blank" rel="noopener" href="https://github.com/aircloud/hexo-theme-aircloud">AirCloud</a></p>
</footer>




</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = "search.json"
    window.hexo_root = "/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>

<script src="/js/index.js"></script>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




</html>
