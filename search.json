[{"title":"KMS-summary","url":"/2024/03/22/KMS-summary/","content":"KMS（Key Management Service）是云计算服务商提供的密钥管理服务。它主要针对数据加密、签名、身份认证等场景，提供自主控制和管理密钥的能力。\n\nKMS提供了一种在不暴露密钥明文的情况下，使用密钥完成客户数据的加密和解密操作。用户可以放心将密钥托管在KMS，不必担心密钥的安全。\n\n使用KMS进行数据加密的流程一般如下：\n\n1. 用户使用KMS创建一个密钥或者使用现有的密钥。\n\n2. 用户将需要加密的数据提交给KMS，并指定使用的密钥。\n\n3. KMS使用指定的密钥进行加密操作，并返回加密后的数据。\n\n4. 加密后的数据可以安全地存储在任意位置。只有拥有密钥权限的用户才能通过KMS进行解密。\n\n5. 用户需要解密数据时，将加密后的数据提交给KMS，并指定解密的密钥。\n\n6. KMS使用密钥进行解密操作，并返回原始数据。\n\nKMS的好处是，用户无需担心密钥的生成、存储、使用和管理等复杂的问题。只需专注于业务开发，将安全问题交给KMS处理。同时，KMS还有严格的权限控制和审计日志功能，可以追踪和记录所有密钥操作，协助满足合规需求。\n\n- https://cloud.tencent.com/document/product/457/45594"},{"title":"survey-sys-summary","url":"/2024/03/21/survey-sys-summary/","content":"### All open source, transparent and self-hostable\n\n## formbricks\n### github\nhttps://github.com/formbricks/formbricks\n```\nFeatures\n- Create conversion-optimized surveys with our no-code editor with several question types.\n- Choose from a variety of best-practice templates.\n- Launch and target your surveys to specific user groups without changing your application code.\n- Create shareable link surveys.\n- Invite your team members to collaborate on your surveys.\n- Integrate Formbricks with Slack, Notion, Zapier, n8n and more.\n- All open source, transparent and self-hostable.\n- Built on Open Source\n- Typescript|Next.js|React|TailwindCSS|Prisma|Auth.js|Zod|Vitest\n```\n\n### survey-library\n- https://github.com/surveyjs/survey-library\n\n\n### LimeSurvey\n- https://github.com/LimeSurvey/LimeSurvey\n\n### OhMyForm\nOhMyForm is a free, opensource form builder similar to Google Forms or TypeForm.\n✏️ Free open source alternative to TypeForm, TellForm, or Google Forms ⛺\n- https://ohmyform.com/about/\n- https://github.com/ohmyform/ohmyform\n\n### TellForm\n- https://github.com/tellform/tellform(archived in 2019)\n- https://tellform.com/\n\n\n- devtools-detector.js 检测开发者工具"},{"title":"x5-接入-summary","url":"/2024/03/20/x5-接入-summary/","content":"https://x5.tencent.com/\n\n#### 商业版本：\n解决免费版本因为成本控制，下载带宽流控（满足业务轻量的SDK接入）的问题\n\n#### 免费版：\n下载慢｜流控｜接入不稳定\n\n### 推荐方案\n- 静态接入（商业版本的内核和SDK，内核版本也会比免费版高）- 集成接入\n- 动态下载的托管，可以自己做版本灰度管理，用自己的CDN - 托管接入\n\n#### chromium\n- 当前次新版本的授权使用\n#### 集成接入模式\n- 50MB+\n- SDK和内核可以直接集成到APP\n- 接口能力（切换系统内核｜初始化接口（失败异常及原因）｜内核安装接口）\n\n#### 托管接入模式\n- SDK<1MB 内核>50MB\n- SDK和内核分别交付\n- 接口能力（下载器及下载监控回调｜切换系统内核｜初始化接口（失败异常及原因）｜内核安装接口）\n- CDN资源-实现动态下载（我们提供）- 什么时候下载｜什么时候更新｜如何控制更新多少\n- Google服务（国外）\n\n#### 升级版产品优势（官网）\n- 稳定内核覆盖率\n多种接入方式，多种集成方式，满足内核稳定初始化诉求\n- 浏览扩展功能\n17项扩展浏览功能，提供更顺畅、优质的网页体验和浏览体验\n- 网页首屏加速能力\n提供全套网页预处理能力，包含DNS、链接、资源请求、预解析、预渲染，提升网页加载速度\n- 网页数据监控能力\n提供内核运营数据报表，网页性能、异常等数据监控接口能力，掌握组件运营全面信息\n- 自研同层渲染框架\n自研将Native View 嵌入到网页中展示，支持同层渲染，实现Native组件渲染到内核层级，网页H5体验犹如Native\n- 小程序框架支持JSCore引擎\n基于 V8 引擎，自研实现一套 Java 与 JS 交互的解决方案。提供更多的扩展功能、各方面代码运行和数据传输性能更优\n\n～～～ 能力都是需要收费的，基础版本主要为了解决限流问题\n\n## 问题\n内核版本问题\nQbSdk.enableX5WithoutRestart()\n安装授权完成之后，QbSdk.preInit(context,callbak)->QbSdk.preInit(context,true,callbak) 强制预初始化内核\n\n不限流之后 - 下载成功95%以上\n\n### api\nhttps://x5.tencent.com/docs/tbsapi.html\n\n\n### 常见问题\n- https://docs.qq.com/doc/DYW9QdXJNWFZnbVdz"},{"title":"mobile-summary","url":"/2024/03/19/mobile-summary/","content":"- https://github.com/AlloyTeam/Mars/tree/master\n- 内容较古早\n```\n面向亿万用户级的移动端Web解决方案：\n\n代码结构规范\n字体设置最佳实践\n模拟原生效果实践\n工具类方法汇总\niOS 与 Android 平台上问题列表\n高性能 Mobile Web 开发\n下一代 Web 框架 - Omi\n特效制作解决方案 - css3transform\n触摸运动解决方案 - AlloyTouch\nMobile 手势解决方案 - AlloyFinger\nMobile 裁剪解决方案 - AlloyCrop\nMobile 级联选择器\n1kb代码搞定移动 Web 开发调试发布错误监控上报用户问题定位 - AlloyLever\n小程序、小游戏以及 Web 通用 Canvas 渲染引擎 - Cax\n```"},{"title":"tcplayer-summary","url":"/2024/03/19/tcplayer-summary/","content":"\nMPEG transport stream (MP2T)是一种用于发送音频、视频和数据的通信协议它具有以下特点：\n\n1. 它被设计为能够在信号弱或有严重干扰的情冃下依旧保持有效性。\n2. 它可以处理媒体数据和元数据并保证两者在传输过程中的同步性。\n3. 它适合在有限的带宽中传输大量的数据流，因此常用于广播。\n4. 它能同时处理多个压缩的数据流。\n\n关于视频，MP2T格式可以被用于流式视频播放如：HLS(HTTP Live Streaming)，它被广泛用于需要直播或播放预先记录的视频的应用中，例如在线直播、播客或连续视频串流。比如YouTube，Netflix这样的流媒体服务就采用了这种格式。这大部分是由于它的弹性和对错误的容忍度，都很适合网络环境。\n\n\n看来你在与服务器打交道和查看HTTP响应头。这些信息看起来像是响应头的一部分，但我需要更多的上下文才能为你做出确切的解释。以下是我对截至目前提供的信息的理解：\n\n- `lego_vod` 可能是处理你请求的服务器的名字或者标识。\n- `X-Cache-Lookup: Cache Hit` 这表明资源在缓存中被找到并使用，避免了向源服务器发出额外请求获取资源，这通常会加速请求的处理。\n- `X-Nws-Log-Uuid: 10529671066262157929` 这可能是服务器生成的唯一标识符，用于追踪或日志记录的目的。\n\n但需要注意，这都是关于HTTP响应头的一般解释，并不是特定于\"lego_vod\"的。因此，如果你有更具体的问题或需求，请随时提出！\n\n\n\n### trtc_web\nhttps://github.com/LiteAVSDK/TRTC_Web\n\n- https://web.sdk.qcloud.com/trtc/webrtc/demo/detect/index.html\n- 设备测试页面\n"},{"title":"app-软键盘","url":"/2024/03/18/app-软键盘/","content":"在应用开发中，调用软键盘通常与输入框相关。当用户需要输入某些信息时，应用程序需要调用软键盘供用户输入。下面是如何在Android和iOS应用中调用软键盘：\n\n1. Android：\n\n在Android中，通常我们不需要显式调用软键盘，只需要设置EditText获取焦点即可。如果确实需要显式调用，可以使用InputMethodManager类来做到。\n\n如下面的示例代码：\n\n```java\n//获取InputMethodManager的实例\nInputMethodManager imm = (InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE); \n//请求显示软键盘\nimm.showSoftInput(editText, InputMethodManager.SHOW_IMPLICIT);\n```\n同样的，如果需要显式关闭软键盘，可以使用hideSoftInputFromWindow函数：\n   \n```java\n//获取当前焦点的View\nView currentFocusView = getCurrentFocus();\n//请求隐藏软键盘\nif (currentFocusView != null) {\n      imm.hideSoftInputFromWindow(currentFocusView.getWindowToken(), 0);\n}\n```\n\n2. iOS：\n\n在iOS中，若要调用软键盘，也是以UIKit中的输入控件(UITextField, UITextView)获取焦点为主。可以通过将resignFirstResponder设为false来请求键盘出现，设为true来使键盘消失。\n\n调用软键盘的代码如下：\n   \n```swift\n// 请求键盘\ntextField.becomeFirstResponder()\n```\n   \n隐藏软键盘的代码如下：\n\n```swift\n// 隐藏键盘\ntextField.resignFirstResponder()\n```\n\n需要注意的是，某些情况下，我们还需要根据实际业务需求，实现键盘的相关操作，比如在键盘上添加完成按钮或自定义工具栏等。\n\n在 Android 系统中，可以通过创建一个输入法服务以定制系统软键盘。以下是创建输入法服务的大致步骤：\n\n1. 创建一个 Java 类，该类需要继承自 `InputMethodService`。`InputMethodService` 是 Android 提供的用于创建自定义输入法服务的基类。\n\n    ```java\n    public class MyInputMethodService extends InputMethodService {\n        ...\n    }\n    ```\n\n2. 在这个类中，你需要覆盖并实现以下两个方法：\n     - `onCreateInputView()`：此方法用于创建键盘的视图。\n     - `onCreateInputMethodInterface()`：此方法用于创建你的输入法的接口。\n\n   例如：\n    \n    ```java\n    public class MyInputMethodService extends InputMethodService {\n\n        @Override\n        public View onCreateInputView() {\n            // 创建并加载键盘视图  \n            View keyboardView = getLayoutInflater().inflate(R.layout.keyboard, null);\n            return keyboardView;\n        }\n\n        @Override\n        public AbstractInputMethodService.AbstractInputMethodImpl onCreateInputMethodInterface() {\n            // 创建并加载键盘的接口\n            return super.onCreateInputMethodInterface();\n        }\n    }\n    ```\n\n3. 在你的 AndroidManifest.xml 文件中，你需要注册你的输入法服务。\n\n    ```xml\n    <service\n        android:name=\".MyInputMethodService\"\n        android:label=\"@string/service_name\"\n        android:permission=\"android.permission.BIND_INPUT_METHOD\">\n        <intent-filter>\n            <action android:name=\"android.view.InputMethod\" />\n        </intent-filter>\n        <meta-data\n            android:name=\"android.view.im\"\n            android:resource=\"@xml/method\" />\n    </service>\n    ```\n\n一旦键盘服务创建并启动，用户就可以在设置->语言和输入法->输入法列表中找到你的键盘并进行切换。定制软键盘的布局、功能等都在你创建的键盘服务的类中进行。\n\n在iOS中，你无法直接定制系统的软键盘，这主要是出于安全和隐私的原因。然而，你可以开发一个键盘应用来提供自定义的输入体验，这是被允许的。这被称为“键盘扩展”。\n\n以下是创建自定义键盘的基本步骤：\n\n1. 在 Xcode 中，创建一个新的 \"Keyboard Extension\"。你可以选择 \"File\" > \"New\" > \"Target\"，然后从 \"Application Extension\" 类别找到 \"Custom Keyboard Extension\"。\n\n2. 这样，你就成功创建了一个新的键盘扩展。其中的 \"KeyboardViewController.swift\" 文件是你需要重点关注的，它负责键盘的展示和用户交互。\n\n3. 你可以在 \"KeyboardViewController.swift\" 文件中重写几个主要方法来实现你自己的键盘布局和逻辑，例如：`updateViewConstraints`，`viewDidLoad` 和 `textWillChange` 等。\n\n需要注意的是，自定义键盘扩展涉及到许多隐私问题，因为键盘能够获知用户所输入的所有内容。出于隐私考虑，iOS 对键盘扩展施加了很多限制，例如无法访问到用户的摄像头、相册等资源，也无法调用网络服务。\n\n使用自定义键盘扩展，你可以实现一些优化输入体验的功能，如自定义键盘布局、添加表情键等。\n\n### \n如果你要创建一个自定义键盘并且能在键盘中进行输入，你需要利用iOS在App Extensions（应用扩展）中所提供的Custom Keyboard Extension（自定义键盘扩展）。然后在键盘扩展中处理键盘的输入。\n\n下面是实现这一功能的基本步骤：\n\n1. 创建键盘扩展：打开Xcode，点击 \"File\" > \"New\" > \"Target\"，然后选择 \"Application Extension\" > \"Custom Keyboard Extension\"。\n\n2. 实现键盘输入：在你的自定义键盘扩展中，核心的类是UIInputViewController。UIInputViewController类负责接收和处理用户的输入。你需要创建一个扩展了UIInputViewController的类，并且重写它的输入方法。\n\n中文字母输入可以通过`self.textDocumentProxy`提供的`adjustTextPosition(byCharacterOffset:)`和`insertText(_:)`方法来实现。例如，当用户按下一个键时，你可以调用`insertText(_:)`方法将该键对应的文字插入到文本中。\n\n```swift\nlet proxy = self.textDocumentProxy as UITextDocumentProxy\nproxy.insertText(\"你的文字\")\n```\n\n3. 创建键盘界面：你可以利用Interface Builder来设计键盘的界面，或者在代码中创建。界面可以包含多个UIButton，当按钮被按下时，对应的文字通过上一步的方式输入到文本中。\n\n记得，在info.plist文件中将RequestsOpenAccess设为YES，这样键盘扩展就可以访问全键盘输入。\n\n以上就是基础的实现方式，你还可以通过添加更多的交互和动画，来丰富你的键盘应用。\n\n定义方式可能会因具体需求和应用的独特性而有所不同，我建议查阅Apple开发者文档中关于Custom Keyboard的部分来获取更详细的信息。\n\n\nhttps://developer.apple.com/library/archive/documentation/General/Conceptual/ExtensibilityPG/CustomKeyboard.html\n\n\n### 参考文章\n- https://juejin.cn/post/6961757804491178014?searchId=20240314170238D0A68EC648BFF98B340D\n\nhttps://setcina.github.io/2020/01/20/WebView%E4%B8%8A%E8%BD%AF%E9%94%AE%E7%9B%98%E7%9A%84%E5%85%BC%E5%AE%B9%E6%96%B9%E6%A1%88/\n\nWebView上软键盘的兼容方案\n\nhttps://juejin.cn/post/6844904199474397191?searchId=20240314170238D0A68EC648BFF98B340D（WKWebView支持代码focus唤起键盘）"},{"title":"移动端自动化测试","url":"/2024/03/18/移动端自动化测试/","content":"- weTest提供了移动端基础测试包50次\n- 基础测试做了哪些事儿\n\n### 自动化测试的框架\n\n1. Appium：\n\n   优点：跨平台支持（Android和IOS）、无需修改APP即可进行自动化测试、支持多种语言（Java、Ruby、Python等）、社区活跃、有大量的教程和文档。\n\n   缺点：获取元素的速度较慢、对动态页面处理不佳。\n\n2. Espresso(Android) / XCTest(iOS)：\n\n   优点：为Android（Espresso）和iOS（XCTest）原生支持、性能好、更可靠、支持最新特性。\n\n   缺点：语言只支持Java（Espresso）或者Swift/Objective-C(XCTest)、需要源代码才能进行测试、无法进行跨应用的测试、社区相对较小。\n\n3. Detox：\n\n    优点：对React Native应用有很好的支持、速度快、稳定性高。\n\n    缺点：只支持JavaScript、文档相对较少。\n\n4. Robot Framework:\n\n    优点：语法简单、扩展性强、关键字驱动使得测试过程更加可读。\n\n    缺点：运行速度中等、需要Python环境、缺乏对移动设备的全面支持。\n\n5. UI Automator:\n\n    优点：Google官方提供、可以跨应用进行UI测试、支持最新Android系统。\n\n    缺点：只有Android支持、需要Java环境、文档相对较少。\n\n"},{"title":"todomvc-summary","url":"/2024/03/17/todomvc-summary/","content":"- https://todomvc.com/\n- https://github.com/tastejs/todomvc"},{"title":"锈化","url":"/2024/03/17/锈化/","content":"- Rustification\n\"锈化\"这个词概念，出现在编程语言Rust的生态系统中。\n由于Rust是一种把内存安全性作为核心目标的语言，而这恰恰是C，C++这些传统语言中最常犯错误的地方，因此，许多开发者和公司想要把他们的现有C或者C++代码“锈化”。\n\n\"锈化\"在编程语言中，一般指的是将其他语言（比如说C++、C语言等）的程序或库重写或者部分重写为Rust语言的过程。\n\n锈化分为全面锈化与部分锈化：\n\n1. 全面锈化：指的是将整个程序或库完全重写为Rust语言。\n2. 部分锈化：指的是将程序或库中的一部分，特别是那些关于内存操作的重要且容易出错的部分，重新用Rust语言编写。\n\nRust的优势在于其零成本抽象，内存安全，线程安全等特性，这能够高效地帮助开发者解决一些C，C++繁琐的内存管理和并发编程问题。\"锈化\"过程的目标，就是将这些优势应用到已有的代码中。\n\n\n在Python社区，如果你要将C语言的模块转换为Python，你可能会听到\"Python化\"（\"Pythonize\"）这个词。在.NET生态中，你也会听到\".NET化\"（\".NETify\"或者\"NET-icize\"）的说法。\n\n总的来说，这类词汇并不是形式化的编程术语，它们更像是一种描绘将现有代码库向新技术或语言转换的一种"},{"title":"feature-probe-summary","url":"/2024/03/13/feature-probe-summary/"},{"title":"pageSpy-practice","url":"/2024/03/13/pageSpy-practice/","content":"\n### 私有化部署\n我们这边运维负责k8s，稍作改造，即可部署\n\n### \n"},{"title":"nginx-digging-into-summary","url":"/2024/03/13/nginx-digging-into-summary/","content":"官方文档对于是什么和怎么做都讲得蛮清楚，好文档系列加1\n- http://nginx.org/en/docs/http/ngx_http_upstream_module.html"},{"title":"Android-so-dep-summary","url":"/2024/03/13/Android-so-dep-summary/","content":"引入abtest时，featureProbe SDK\n\n部分机型，SO库缺失"},{"title":"dig-practice","url":"/2024/03/13/dig-practice/","content":"`dig`是一个DNS查询工具，它用于向DNS服务器发送类型查询，并接收和显示响应。以下是`dig`命令返回结果的一些主要部分的解析：\n\n1. `QUESTION SECTION`：这是你发送给DNS服务器的问题，通常包含你想要查询的域名和查询类型。\n2. `ANSWER SECTION`：这是DNS服务器返回的答案，包含域名对应的记录。如果你查询的是A记录，那么这个部分会显示该域名对应的IP地址。\n3. `AUTHORITY SECTION`：这个部分显示了为这个DNS查询提供权威答案的服务器。\n4. `ADDITIONAL SECTION`：这个部分显示了额外的记录，如域名对应的mail exchange（MX）服务器等。\n5. `Query time`：这个数字显示了整个查询过程所花费的毫秒数。\n6. `SERVER`：这是你查询的DNS服务器的IP地址。\n7. `WHEN`：这是查询的时间和日期。\n8. `MSG SIZE`：这是DNS查询消息的大小，单位是字节。\n\n使用`dig`命令时，可以使用各种查询类型，如A（寻找IPv4地址）、AAAA（寻找IPv6地址）、MX（寻找mail exchange服务器）、NS（寻找命名服务器）等。只需在`dig`命令后面加上查询类型和域名即可，例如：`dig A www.example.com`。\n\n\n### A记录\n当你使用CDN（内容分发网络）服务时，你的站点内容被复制到全球各地的许多数据中心。当用户请求你的站点时，DNS会将他们指向离他们最近的那个数据中心，从而加速内容的加载。\n\n为了实现这个功能，CDN提供商通常会为你的域名配置多个A记录，每个记录都指向不同的数据中心的IP地址。当用户进行DNS查询时，DNS服务器会根据一些算法（如地理位置、网络拥塞、服务器负载等）从这些A记录中选择一个返回，以确保用户被指向最优的数据中心。\n\n因此，使用了CDN服务的域名通常会有很多A记录，这也是为什么你会看到有很多A记录的原因。这就是CDN加速的基本工作原理之一。\n\n###\n前端域名被cname到一个负载均衡的域名上了\n\n\n这是一种常见的设置。在云计算或大型网络环境中，经常会看到这样的设置。这种情况下，CNAME记录被用来把一个域名（常常是一个易于记忆的域名，或者是符合某种命名约定的域名）映射到一个可能会经常变化的IP地址上。\n\n少数情况下，如果你的网站托管在多个服务器上以增加稳定性和可用性，负载均衡器会被用于在这些服务器之间均衡流量。在这种情况下，你可能会有一个负载均衡的域名，该域名会解析到负载均衡器的IP地址。然后，你可以使用CNAME记录将你的主要域名映射到这个负载均衡器域名，而不是直接映射到一个特定的IP地址。这样，如果负载均衡器的IP地址需要更改，你只需要更新负载均衡器域名的A记录，而不需要改动与你的主要域名相关的DNS记录。"},{"title":"hybrid-离线包-summary","url":"/2024/03/12/hybrid-离线包-summary/","content":"- 阿里云移动平台\nhttps://help.aliyun.com/document_detail/161719.html?spm=a2c4g.146492.0.0.1878e8f5Qsv36g\n- https://help.aliyun.com/document_detail/178947.html?spm=a2c4g.161719.0.0.4e671e87LZ5SAm\n```\nH5 离线包的使用可以分为以下四个部分：\n发布离线包\n预置离线包\n启动离线包\n更新离线包\n```\n- 腾讯云移动平台\n\n### "},{"title":"QUIC-summary","url":"/2024/03/12/QUIC-summary/","content":"QUIC（Quick UDP Internet Connections）是由Google开发的一种基于UDP的传输层协议，目的是菜单网络连接更为快速、安全。QUIC 在设计时借鉴了TCP、TLS (Transport Layer Security) 和 HTTP/2 的一些特性，但并不是这三者的简单组合。\n\n关于QUIC，有一些特点是需要了解的：\n\n1. **快速连接建立**：传统的基于TCP的协议在建立连接时需要进行三次握手，如果加上TLS加密，那就需要2-3个RTT（Round-Trip Time，往返时延）。而QUIC协议只需要一个 RTT即可完成握手过程，如果是之前已经“见过”（即在缓存中有记录）的服务器，甚至可以做到零RTT。\n\n2. **内建 TLS**：QUIC协议的连接建立过程中，也完成了TLS握手过程，因此在传输数据时，已经实现了加密。\n\n3. **流控制”，拥塞控制和丢包恢复**：QUIC内置了一系列优化，并且加入了基于流的窗口以及并发多流的拥塞控制。\n\n4. **连接迁移**：由于传输层的连接上下文保存在客户端，所以当网络环境发生变化时，可以实现无缝的连接迁移。\n\n5. **多路复用**：允许在一个QUIC连接中同时存在多个stream，实现数据的并行传输。\n\nQUIC协议正在逐渐被采用，特别是在现代Web传输协议 HTTP/3中，QUIC被选为默认的底层传输协议。\n\n- https://github.com/Tencent/tquic/tree/develop\n- https://tquic.net/zh/docs/tutorial/core_concepts/\n\n### 比较\n- https://tquic.net/zh/docs/further_readings/comparison"},{"title":"幂等-summary","url":"/2024/03/07/幂等-summary/","content":"\"幂等\"这个概念最早出自数学领域，但在计算机科学中，幂等（Idempotent）操作主要指用不会改变系统状态的操作。具体来说，对一个系统反复执行同一操作的结果与执行一次的结果是一样的。在Web开发中，幂等性主要用来保证在网络不稳定或者重复请求的情况下，系统的一致性和数据的一致性。\n\n以下是在生产中实践幂等性的一些常用策略：\n\n**1. HTTP方法：** 根据HTTP标准，某些HTTP方法被定义为幂等的。例如GET，HEAD，PUT，DELETE，OPTIONS和TRACE。在设定API行为的时候，使用这些HTTP方法可以保证我们的API具有幂等性。\n\n**2. 唯一请求编号：** 客户端在发送请求时生成一个唯一ID，并在请求头或参数中发送至服务器。服务器在处理请求之前，先检查该请求编号是否已经处理过，如果已经处理过，则直接返回之前的结果，否则正常处理并记录请求编号。\n\n**3. 数据库操作：** 在数据库中使用主键或者唯一索引来进行更新和删除操作，无论执行多少次，都只会影响一个目标记录。在插入操作时，可以使用存在则更新，不存在则插入的语句，如MySQL的INSERT...ON DUPLICATE KEY UPDATE语句。\n\n**4. 版本控制：** 在处理更新操作前获取记录的版本号，然后在更新时检查版本号是否一致，这样一来，多次相同的请求只有第一次可以成功执行，因为更新操作之后，版本号已经改变。\n\n**5. 分布式锁：** 分布式锁是另一种常用策略，通过对关键部分的操作上锁，确保在同一时间只有一个请求可以操作同一数据。例如，处理账户转账操作时，可以使用分布式锁来确保账户余额的正确性。\n\n**6. 业务逻辑：** 对于业务流程中可能出现重复请求的场景，设计出符合业务特性的幂等处理策略。例如，如果业务操作中包含生成订单的操作，可以预先生成一个订单号，然后将订单号等信息一同发给客户端，客户端再次请求时携带订单号，服务端按照订单号进行幂等处理。\n\n以上策略哪种更适合，需要根据实际业务需求和场景来决定，目标都是为了保持数据一致性，提高系统的稳定性。\n\n\n学术界对于幂等性的研究主要集中在分布式计算、数据库事务处理和服务设计等方面。以下是一些相关的学术论文，你可能会感兴趣：\n\n1. \"Transactional Information Systems: Theory, Algorithms, and the Practice of Concurrency Control and Recovery” by Gerhard Weikum, Gottfried Vossen.  这本书详细地探讨了数据库事务处理，包括幂等性等重要概念。\n\n2. \"Idempotence Is Not a Medical Condition\" by Pat Helland. 这篇论文解释了为什么在服务设计中需要思考幂等性问题，并给出了一些设计思考和推荐。\n\n3. \"Designing Data-Intensive Applications\" by Martin Kleppmann. 这本书详细地探讨了数据系统的设计，包括处理幂等性问题等。\n\n4. \"Building Microservices: Designing Fine-Grained Systems\" by Sam Newman. 对于微服务系统的设计，如何处理幂等性也是一个重要的问题，这本书中也有所涉及。\n\n5. \"Concurrency Control and Recovery in Database Systems\" by Philip A. Bernstein, Vassos Hadzilacos, and Nathan Goodman.此书讲解了并发控制和恢复在数据库系统中的重要性，包括了如何处理事务的幂等性。\n\n这些书籍和论文都能够提供对幂等性有深度的理解和实际应用中如何处理幂等性问题的见解。\n\n\n在软件设计中，利用注解（Annotation）来标识方法的幂等性是一个很好的设计模式，是比依赖方法名称更加灵活和清晰的方式来实现幂等性。\n\n例如，可以定义一个名为@Idempotent的注解，然后在需要保证幂等性的方法上使用该注解。这样一来，开发者只需要查看方法是否有该注解就可以知道该方法是否保证幂等性，而无需查看方法名称。\n\n# 在Java中，你可以这样定义一个幂等注解\npublic @interface Idempotent{\n    ...\n}\n# 然后在需要保证幂等性的方法上使用该注解\n@Idempotent\npublic void someMethod() {\n    ...\n}\n通过这种方式，可以更清晰地标识出哪些方法需要保证幂等性，提高代码的可读性和可维护性，同时也降低了出错的可能性。\n\n注意，注解本身并不能实现幂等性，注解只是一种标记，具体的幂等逻辑还需要开发者自己去实现，例如通过分布式锁、Token机制、数据库唯一约束等方式来保证方法的幂等性。"},{"title":"ab-platform","url":"/2024/03/07/ab-platform/","content":"- featureProbe\n- 调试阶段，自己拉项目进行部署\n\n- https://github.com/FeatureProbe\n- https://gitee.com/featureprobe/FeatureProbe/blob/main/README_CN.md\n目前是没有特性发布的状态，Android端客户端SDK有BUG，但是只能使用方自行兜底处理；\n（https://github.com/FeatureProbe/client-sdk-mobile/tree/main）\n\n```\nFeatureProbe适用于哪些场景\n根据我们的经验，FeatureProbe可以在以下场景中提升软件研发的效能:\n\n『特性粒度』灰度发布: 每个功能独立灰度发布给用户。可迅速关闭受BUG影响的功能，同时不影响其他正常功能的使用。\n降低测试环境搭建成本: 节约测试环境搭建和线下测试时间成本。利用线上环境小流量测试，环境真实同时影响可控。\n降低故障恢复时间:故障发生时通过降级策略调整服务行为，保障用户主路径不受影响。\n简化研发协同方式: 用功能开关替代传统分支开发的团队协同模式。真正实现主干开发、持续部署。减少分支合并冲突，显著加快迭代速度。\n统一的配置管理中心: 通过用户友好的操作页面，统一操作线上配置，实时修改功能参数，让运营活动生效更简单。\n```"},{"title":"bun-summary","url":"/2024/03/06/bun-summary/","content":"- https://github.com/oven-sh/bun"},{"title":"jemalloc-ptmalloc-summary","url":"/2024/03/06/jemalloc-ptmalloc-summary/","content":"\n- https://internals.rust-lang.org/t/jemalloc-was-just-removed-from-the-standard-library/8759\nrust 从默认的jemalloc,该回了系统malloc\n\n`jemalloc` 是一种开源内存分配库，有时由于其提供的优化性能，开发者会希望使用它替代默认的 `ptmalloc`，下面是在 Linux 上做此类替换的一般步骤：\n\n1. 首先，我们需要安装 `jemalloc`。在 Ubuntu 上，可以使用 `apt-get`：\n```\nsudo apt-get install libjemalloc-dev\n```\n\n2. 创建一个包装脚本以将 `jemalloc` 插入到库加载序列的最前面。这实际上会将 `LD_PRELOAD` 环境变量设置为 `jemalloc` 的路径，以此在应用启动时优先加载 `jemalloc`。\n```bash\n#!/bin/bash\nexport LD_PRELOAD=/usr/lib/x86_64-linux-gnu/libjemalloc.so.1\nexec \"$@\"\n```\n假设该脚本命名为 `use_jemalloc.sh`。要打开文件并使其可执行，我们可以运行：\n```bash\nchmod +x use_jemalloc.sh\n```\n\n3. 现在我们可以使用此脚本启动我们的应用，例如：\n```bash\n./use_jemalloc.sh node app.js\n```\n\n上述步骤将确保你的 Node.js 应用使用 `jemalloc` 而不是默认的 `ptmalloc`。\n\n提示：`jemalloc` 的路径可能因操作系统和版本不同而异。如果 `/usr/lib/x86_64-linux-gnu/libjemalloc.so.1` 不起作用，你可能需要在你的系统中搜索正确的路径。\n\n不过，即便执行了上述步骤，也不能保证一定能提升性能，这很大程度上取决于你的特定应用和工作负载。这是一个值得试验的方面。如果你没有看到预期的性能改进，你可能需要更深入地研究或者考虑其他的优化方法。\n\n\nNode.js 应用 RSS 内存泄漏排查与解决方案\nhttps://zhuanlan.zhihu.com/p/675317993\n```\n故事从一次 Node.js 20 升级开始\n一直走弯路，Node.js 16、18 就存在此问题\n第一次的 RSS 内存分析结论：内存碎片比较多没有及时回收\n问题结果：周期性 OOM\n故事再次循环\n复现代码\nTestCase1\nTestCase2\nnpmmirror 使用 jemalloc 的修复效果\n通过 ezm 摸排有多少类似的应用\n只有 Node.js 出现此类问题吗？\n为什么 2009 年 Facebook 就提供 jemalloc 解决此问题而 Node.js 在 2023 年还在发生？\n相关资料\n故事从一次 Node.js 20 升级开始\n\n```"},{"title":"network-information-API-summary","url":"/2024/03/06/network-information-API-summary/","content":"https://googlechrome.github.io/samples/network-information/\nhttps://github.com/googlechrome/samples/tree/gh-pages/network-information\n```\ntype: undefined\n     downlink: 1.45 Mb/s\n          rtt: 300 ms\n  downlinkMax: undefined Mb/s\neffectiveType: 4g\n     saveData: false\n```\nNetwork Information API 提供了有关系统网络连接的信息，允许 Web 应用程序在网络连接改变时访问并适应这些变化。这个 API 提供的信息有以下几个主要参数：\n\ntype: 这是一个表示用户设备网络连接类型的字符串。它可以是 bluetooth，cellular，ethernet，none，wifi，wimax，other，unknown。\n\neffectiveType: 这是一个表示用户设备的有效网络连接类型的字符串，主要考虑带宽和网络延迟。它可以是 slow-2g，2g，3g，4g。\n\ndownlink: 这是一个表示设备的下行速度（单位：Mbps，向用户设备发送数据的速度）的数值。\n\nuplink: 表示设备的上行速度（单位：Mbps，用户设备发送数据的速率）。\n\nrtt: 这是代表用户设备网络连接的往返时间（以毫秒为单位）的数字。被用来估计网络的延迟。\n\nsaveData: 这是一个表示用户设备是否在尽量减少数据使用的布尔值，它是根据用户的浏览器设置和操作系统设置决定的。"},{"title":"virtual-scroller-summary","url":"/2024/03/05/virtual-scroller-summary/","content":"`vue-virtual-scroller`是一个Vue组件，用于高效地渲染大量的列表或滚动数据。它使用了虚拟滚动的技术，只渲染当前可视区域内的数据，从而明显提升了渲染大量数据的性能。\n\n`vue-virtual-scroller`的主要特性如下：\n- 支持水平或垂直滚动\n- 支持动态布局的元素（行高或列宽不一致）\n- 无缝地集成进现有的Vue项目中，因为它是个Vue插件/组件\n\n"},{"title":"命令行工具-nodejs-summary","url":"/2024/03/04/命令行工具-nodejs-summary/","content":"- http-server\n- https://github.com/http-party/http-server"},{"title":"nodejs新官网体验","url":"/2024/03/04/nodejs新官网体验/","content":"- https://github.com/nodejs/nodejs.org/issues\n- https://beta-node-js-org.vercel.app/en/learn/getting-started/introduction-to-nodejs\n- 目前只有英文昂"},{"title":"deobfuscating-javascript-反混淆","url":"/2024/03/04/deobfuscating-javascript-反混淆/","content":"- https://steakenthusiast.github.io/\n\n- https://steakenthusiast.github.io/2022/05/21/Deobfuscating-Javascript-via-AST-An-Introduction-to-Babel/\n\n- de4js(https://www.npmjs.com/package/de4js)\n#### Related projects\nIlluminateJS: A static JavaScript deobfuscator.\nJStillery: Advanced JavaScript Deobfuscation via Partial Evaluation.\nAkamai Deobfuscator: A tool to help you deobfuscate Akamai scripts.\nNice2Predict: Learning framework for program property prediction.\nJavascript deobfuscation AMA: General questions about deobfuscating JavaScript.\nDeobfuscator IO: A (incomplete) deobfuscator for scripts obfuscated with obfuscator.io (Archived).\nJavaScript Deobfuscator: Deobfuscation tool for obfuscated JavaScript using obfuscator.io.\nPrepack: A JavaScript bundle optimizer.\nJS Deobfuscate: JavaScript deobfuscate for JSjiami, Sojson, ...\nJSDec: Online JavaScript decoder. Supported sojson v4/Premium/v5 and more (No longer update).\n* Obfuscator.IO is always up to date. The automatic deobfuscation tools (including this project) will usually not match its latest version. But that doesn't mean it's a safe tool to secure your source code."},{"title":"WebP-summary","url":"/2024/03/04/WebP-summary/","content":"### caniuse\n- https://caniuse.com/?search=webp\n- WebP image format  - OTHER\nImage format (based on the VP8 video format) that supports lossy and lossless compression, as well as animation and alpha transparency. WebP generally has better compression than JPEG, PNG and GIF and is designed to supersede them. AVIF and JPEG XL are designed to supersede WebP.\n- Safari 14.0 – 15.6 has full support of WebP, but requires macOS 11 Big Sur or later.\n\n### Picture\n- caniuse ok ~\n- https://cloud.tencent.com/document/product/436/60453\n- 可配合资源的文档对象存储和数据万象处理\n\n### 兼容性\n- 尤其是在涉及canvas的时候，要注意Safari上面的兼容性\n\n### 成本考虑\n- 结合使用场景\n- https://cloud.tencent.com/document/product/460/58117\n\n### COS数据处理接口\n- 下载｜上传｜云上数据\n- 图片压缩指在图片质量保持不变的情况，尽可能的减小图片大小，以达到节省图片存储空间、减少图片访问流量、提升图片访问速度的效果。\n对象存储（Cloud Object Storage，COS）基于 数据万象（Cloud Infinite，CI） 产品推出了 WebP 压缩功能，可将图片转换为 webp 压缩图片格式，其在压缩方面相比 jpg 格式更优越。在相同图片质量的情况下，webp 格式图片要比 jpg 格式图片减小25%以上，可以适配多终端使用场景。\n- http://example-1258125638.cos.ap-shanghai.myqcloud.com/sample.png?imageMogr2/format/webp"},{"title":"zod-summary","url":"/2024/03/01/zod-summary/"},{"title":"duolingo-summary","url":"/2024/02/28/duolingo-summary/","content":"- wasm\n- Service Worker\n```\nsw\n gcm.js\n offline.js\ngcm-service-worker.js\n```\nOffscreenCanvas 是一个 HTML5 Canvas API，允许你在Web Worker中创建和操作 Canvas 2D 或 WebGL 上下文。Web Worker 是一种能在浏览器的背景线程中运行脚本的方法，这样就不会阻塞用户界面。\n\nOffscreenCanvas 的主要优势在于，你可以在后台线程中进行复杂的渲染计算工作，然后渲染结果可以直接传输给前台的画布进行显示，这样不会影响到前台主线程的性能。\n\n以下是创建一个 OffscreenCanvas 的例子：\n\n```javascript\nconst offscreenCanvas = new OffscreenCanvas(256, 256);\nconst context = offscreenCanvas.getContext('2d');\n// 在这里，你可以使用 getContext() 方法中的 '2d' 或 'webgl' 参数，根据你的需要来获取相应的 2D 或 WebGL 渲染上下文。\n```\n\n然后可以在这个上下文上利用各种方法进行绘图操作。\n\n\n### 163邮箱中使用的service worker\n- workbox(https://github.com/GoogleChrome/workbox)"},{"title":"和第三方SDK打交道的总结","url":"/2024/02/27/和第三方SDK打交道的总结/","content":"在不修改原型链、BOM和DOM对象的情况下，我们可以通过使用帮助函数（helper function）或者通常被称为“wrapper”的方式，对第三方 SDK 打非侵入式的补丁或者说是进行封装。\n\n具体的方法如下：\n\n1. **建立包装函数（Wrapper Function）：** 创建一个新的函数，该函数内部调用第三方 SDK 的相关方法，并额外添加我们需要的功能。例如：\n\n```javascript\n// 第三方 SDK 方法\nfunction thirdPartyMethod(a, b) { /* ... */ }\n\n// 包装函数\nfunction wrappedMethod(a, b) {\n    // 在调用原有方法前执行新逻辑...\n    \n    thirdPartyMethod(a, b);\n    \n    // 在调用原有方法后执行新逻辑...\n}\n```\n\n这种方式的优势是可以在不触碰原有功能的情况下添加新的功能或行为。\n\n2. **使用代理（Proxy）：** JavaScript的 Proxy 对象可以创建一个对象的代理，从而可以拦截该对象的某些操作。比如你可以拦截对一个对象的函数调用，然后在函数调用前后执行自己的逻辑。\n\n以下是一个使用 Proxy 的示例：\n\n```javascript\nlet thirdPartyObject = {\n    thirdPartyMethod: function(a, b) { /* ... */ }\n};\n\nlet proxy = new Proxy(thirdPartyObject, {\n    get: function(target, prop) {\n        if (typeof target[prop] === 'function') {\n            return function(...args) {\n                // 在调用原有方法前执行新逻辑...\n                \n                let result = target[prop](...args);\n                \n                // 在调用原有方法后执行新逻辑...\n                \n                return result;\n            };\n        } else {\n            return target[prop];\n        }\n    }\n});\n```\n\n此时，通过 `proxy.thirdPartyMethod(a, b)` 调用方法，就会执行我们的新逻辑，同时不会更改原有的对象和方法，算是一种非侵入式的补丁方式。\n\n请注意，对于 Proxy 的方式，由于 Proxy 是 ES6 的一个特性，对于不支持 ES6 的环境，这种方式则无法使用。\n\n总体而言，要非侵入式地对第三方 SDK 打补丁，建立一个包装或者代理层是一个比较有效的方式。这种方式可以让我们添加自己的代码逻辑，又不修改或者侵入第三方 SDK 的原有逻辑。\n\nJavaScript的Proxy对象可以通过polyfill来实现。但是这只适用于ES5和以后的版本，因为早期版本的JavaScript并未提供能够完全模拟Proxy对象的功能。\n\n示例代码如下：\n\n```js\nif(typeof Proxy !== 'function') {\n    Proxy = function(target, handler) {\n        //TODO: add logic here \n        return target;\n    };\n};\n```\n\n这只是一个非常简单的示例，真正实现一个完整的Proxy polyfill会非常复杂且困难。在实际应用中，最好的方法可能是检查浏览器是否支持Proxy，并且在不支持的情况下提供备用策略，因为除了某些边缘情况，很难编写出一个与原生Proxy功能完全一致的polyfill。\n\n需要注意的是，由于Proxy对象涉及许多底层操作，不可能完全地在不支持它的JavaScript环境中模拟出来，所以并不存在一个完整且可靠的Proxy polyfill。实际上，最好尽量在支持Proxy的环境中使用它，并且考虑它的可用性和兼容性问题。"},{"title":"philosophy-of-software-design-summary","url":"/2024/02/23/philosophy-of-software-design-summary/","content":"- https://github.com/Cactus-proj/A-Philosophy-of-Software-Design-zh\n\n```\n前言\n斯坦福教授、Tcl 语言发明者 John Ousterhout 的著作《A Philosophy of Software Design》，自出版以来，好评如潮。按照 IT 图书出版的惯例，如果冠名为“实践”，书中内容关注的是某项技术的细节和技巧；冠名为“艺术”，内容可能是记录一件优秀作品的设计过程和经验；而冠名为“哲学”，则是一些通用的原则和方法论，这些原则方法论串起来，能够形成一个体系。正如”知行合一”、“世界是由原子构成的”、“我思故我在”，这些耳熟能详的句子能够一定程度上代表背后的人物和思想。用一句话概括《A Philosophy of Software Design》，软件设计的核心在于降低复杂性。\n\n目录\n前言\n第 1 章 介绍\n第 2 章 复杂性的本质\n第 3 章 工作代码是不够的\n第 4 章 模块应该是深的\n第 5 章 信息隐藏(和泄漏)\n第 6 章 通用模块更深入\n第 7 章 不同的层，不同的抽象\n第 8 章 降低复杂性\n第 9 章 在一起更好还是分开更好？\n第 10 章 定义不存在的错误\n第 11 章 设计它两次\n第 12 章 为什么写评论呢？四个理由\n第 13 章 注释应该描述代码中不明显的内容\n第 14 章 选择的名字\n第 15 章 先写评论\n第 16 章 修改现有的代码\n第 17 章 一致性\n第 18 章 代码应该是显而易见的\n第 19 章 软件发展趋势\n第 20 章 设计性能\n第 21 章 结论\n总结\n```"},{"title":"css-text-decor-3-summary","url":"/2024/02/23/css-text-decor-3-summary/","content":"https://www.w3.org/TR/css-text-decor-3/#line-decoration"},{"title":"lldb-编译","url":"/2024/02/22/lldb-编译/","content":"在Windows的Linux子系统里面安装lldb\n\n编译一个\n\nLLDB 是一个开源的编译器工程，具有强大的命令行调试器和源级别调试工具，且有着良好的用户和应用程序接口。它作为 LLVM 项目的一部分而被开发，旨在提供良好的本机交叉平台调试。\n\nLLDB 通过使用 LLVM 编译器中其他部分的重新利用代码和现有的库，提供了一个现代化的，高性能的原生调试工具。LLDB 目前支持了 `C`，`Objective-C` 和 `C++` 语言，Mac、Linux、Windows及 FreeBSD都有良好的支持。\n\nLLDB 提供了一种可扩展的框架，可以进行各种类型的自动和可视化调试，并且可以比其他开源调试器更好地处理大型应用程序，以及需要动态下载符号的调试。主要功能如下： \n\n- 支持了调试多线程程序。\n- 动态查看并操作（读或写）变量的值。\n- 具备条件断点，观察点（当变量改变值时停止）和代码的单步执行功能。\n- 支持交互式源码级别和装配指令级别调试。\n- 兼容 `gdb` 和 `Python` 脚本的命令，方便开发者迁移和学习。\n- 支持 `LLVM` 和 `Clang` 的表达式解析器，可以调用 C++ 成员函数和类。\n\n这些特性使 LLDB 成为一种强大而灵活的调试工具。"},{"title":"webkit-bug-report","url":"/2024/02/21/webkit-bug-report/","content":"\n### 涉及获取摄像头获取视频和麦克风获取音频流的业务\nhttps://bugs.webkit.org/buglist.cgi?quicksearch=OverConstrainedError\nhttps://bugs.webkit.org/show_bug.cgi?id=176349\n- sentry收到报错，只有一条，设备信息为macos，Safari浏览器\n\n- https://itecnote.com/tecnote/javascript-how-to-resolve-ios-11-safari-getusermedia-invalid-constraint-issue/\n\n- https://developer.mozilla.org/zh-CN/docs/Web/API/MediaDevices/getDisplayMedia#%E5%BC%82%E5%B8%B8\n- MediaDevices.getDisplayMedia()\n\n\n### createStream\n- https://web.sdk.qcloud.com/trtc/webrtc/doc/zh-cn/TRTC.html#createStream\n```\ncreateStream(streamConfig) → {Stream}\n创建一个本地流 Stream 对象，本地流 Stream 对象通过 publish() 方法发布本地音视频流。\n\n注意：一个音视频流 Stream 中最多只能包含一个音频 track 和一个视频 track。\n\n本地音视频流可以\n\n从摄像头和麦克风采集获得，适用于一般的音视频通话。\n从屏幕分享源采集获得，适用于进行屏幕分享。\n从开发者通过 audioSource/videoSource 指定的 MediaStreamTrack 获得， 使用这种方式业务层可先对音视频进行前处理，比如，对音频进行混音，或者对视频进行美颜处理，亦或者通过这种方式向远端用户推送一个正在播放的音视频文件。\n\n```"},{"title":"web-photoshop-summary","url":"/2024/02/01/web-photoshop-summary/"},{"title":"web-crypto-API-summary","url":"/2024/01/05/web-crypto-API-summary/","content":"- https://www.crypto101.io/"},{"title":"metadata-reflection-summary","url":"/2023/12/28/metadata-reflection-summary/","content":"Metadata Reflection API 是 TypeScript 提供的一种机制，它允许在运行时访问类、接口或者类型的元数据。这对于某些开发工作，如装饰器、DI框架（依赖注入框架）、对象映射等，非常有帮助。\n\n这个 API 采用于 ECMAScript 的装饰器提案，它有以下三个主要的部分：\n\n1. Reflect.metadata：用于添加指定的元数据到类的定义上。\n2. Reflect.defineMetadata：用于在一个对象上定义新的元数据。\n3. Reflect.getMetadata：用于获取已定义的元数据。\n\n要使用这个 API，你需要在 tsconfig.json 文件里，把 \"emitDecoratorMetadata\" 设置为 true。\n\n以下是一个例子，演示了如何使用 Metadata Reflection API：\n\n```ts\n// 定义一个装饰器\nfunction logType(target : any, key : string) {\n  let t = Reflect.getMetadata(\"design:type\", target, key);\n  console.log(`${key} type: ${t.name}`);\n}\n\nclass Demo {\n  @logType // 应用装饰器\n  public attr1 : string;\n}\n\n// 输出：attr1 type: String\n```\n\n在这个例子中，\"logType\" 装饰器使用了 Reflect.getMetadata 函数来取得 \"attr1\" 的类型，然后输出的结果就是 \"attr1 type: String\"。\n\n总的来说，Metadata Reflection API 提供了在运行时访问类型信息的功能，这使得 TypeScript 在很多场景下更具灵活性和强大的动态编程能力。\n\n\n这段话的意思是，现在Decorators和Decorator Metadata已经在TC39中达到了第三阶段，以下提出的API不再被考虑作为标准化。然而，这个包将继续支持那些利用TypeScript的遗留--experimentalDecorators选项的项目，因为一些项目可能无法迁移到使用标准的装饰器。\n\nTC39是JavaScript标准化组织。它通过阶段（共4个阶段）对JavaScript的特性进行标准化讨论。需要注意的是，达到第三阶段，表示该特性已经接近最终确定并将在未来的版本中作为标准特性出现。\n\n这个段落是告诉你，虽然Decorator和Decorator Metadata已经基本确定为标准特性，但是在这个包中还将继续支持TypeScript早期的—experimentalDecorators选项，以保证后向兼容性，并且方便那些还使用旧版TypeScript的项目。\n\n### Decorators\n- https://www.typescriptlang.org/docs/handbook/decorators.html\nNOTE  This document refers to an experimental stage 2 decorators implementation. Stage 3 decorator support is available since Typescript 5.0. See: Decorators in Typescript 5.0\n\n- https://devblogs.microsoft.com/typescript/announcing-typescript-5-0/#decorators"},{"title":"pinyin-summary","url":"/2023/12/26/pinyin-summary/"},{"title":"trippy-summary","url":"/2023/12/18/trippy-summary/","content":"- https://trippy.cli.rs/\n- Trippy combines the functionality of traceroute and ping and is designed to assist with the analysis of networking issues.\n"},{"title":"random-summary","url":"/2023/12/18/random-summary/","content":"\nBuild a Second Brain\n- Distill 里的渐进式总结法和 Express 里中级包的概念。\n- CODE 即 Capture（捕捉）、Origanize（整理）、Distill（提炼） 和 Express（表达） 四步法，指引我们每天如何面对无尽的信息流\n\n\nUmi\n- 非业务层提取到社区开源做\n- 业务层通过插件的方式放在企业内部实现\n- 开源和业务的共赢\n- 和 Egg 是同一个路数\n\n带着问题看社区方案\n- elm 和 choo 我想着用来解 redux 和蚂蚁内部数据流方案不够好用的问题，于是有了 dva；\n- 看到 esbuild 我想着用来解压缩的问题，于是有了 esbuild-webpack-plugin；\n- 看到 module federation 我想着用来解构建慢的问题，于是有了 MFSU。\n\n\n1）解的问题是否有意义，2）方案成熟度，3）避免低水平重复造轮子"},{"title":"docker-desktop-summary","url":"/2023/12/14/docker-desktop-summary/","content":"windows - wsl\n\nhttps://learn.microsoft.com/en-us/windows/wsl/install\n默认是开启的\n注意：\n1. docker build -t aaa:ccc .\nThe command 'docker' could not be found in this WSL 2 distro.\nWe recommend to activate the WSL integration in Docker Desktop settings.\nFor details about using Docker Desktop with WSL 2, visit:\nhttps://docs.docker.com/go/wsl2/\n\n wsl -l -v\n wsl.exe --setdefault Ubuntu-22.04\n\n\n2. docker build -t aaa:ccc .\nERROR: permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Get \"http://%2Fvar%2Frun%2Fdocker.sock/_ping\": dial unix /var/run/docker.sock: connect: permission denied\nsudo groupadd docker\nsudo gpasswd -a $kkk docker\nsudo gpasswd -a $USER docker\nnewgrp docker\n(unix socket需要root权限访问，所以需要在子系统里面，将当前用户加到docker组里，docker守护进程启动的时候，会默认赋予名字为docker的用户组读写Unix socket的权限，因此只要创建docker用户组，并将当前用户加入到docker用户组中，那么当前用户就有权限访问Unix socket了，进而也就可以执行docker相关命令)\n "},{"title":"immersive-translate-notes","url":"/2023/12/14/immersive-translate-notes/","content":"技术类文章，专业名词多，对照是很有必要的；\n- 非常好用，方便对比\n- 插件形式\n- 研究了下注入的方式"},{"title":"IPFS-summary","url":"/2023/12/11/IPFS-summary/","content":"Cloudflare IPFS Gateway 是一个公共的网关，允许你在没有安装IPFS（互联网文件系统）客户端的情况下访问存储在IPFS网络上的内容。IPFS是一种分布式文件系统，旨在创建持久且分布式存储和共享的文件。它是一种内容可寻址的方法，意味着它使用文件本身的哈希（一个唯一的数字指纹）来定位文件，而不是依赖于原始文件位置。\n\n这个gateway的工作原理是：充当你和IPFS网络之间的代理。当你访问Cloudflare IPFS Gateway的网页时，Gateway将会在IPFS网络上寻找那个文件的哈希，并将内容提供给你。这使得任何连接到互联网的人都能查看IPFS上的内容，甚至他们自己没有运行IPFS节点。\n\n这个服务也使得IPFS上的网站可以被搜索引擎索引，因为Cloudflare充当了一个可以被常规互联网访问的桥梁。同时，它也能为IPFS上的内容提供了DDOS保护。\n\n需要注意的是，尽管你可以通过Cloudflare的IPFS Gateway访问IPFS网络，但是你不能将新的文件添加到IPFS网络上，除非你自己运行一个IPFS节点。 "},{"title":"mongo-startup","url":"/2023/12/06/mongo-startup/","content":"### Mongosh\nMongoDB Shell(Mongosh)是MongoDB的标准交互式JavaScript接口。直到MongoDB 4.2，标准的shell是mongo。在MongoDB 4.4中，Mongosh是一种新的命令行接口，用来代替老的mongo shell。这是因为Mongosh比起老的mongo shell有更多的现代化的交互特性。 \n\n然而，MongoDB 4.4是在Mongosh正式发布之前就发布的。因此，MongoDB 4.4及其之前的版本的安装包中并不包含Mongosh，因为在那个时候Mongosh就还未开发完。如果你想在MongoDB 4.4或之前的版本中使用Mongosh，你需要自己去下载和安装。\n\n\n### Artifactory\nArtifactory是JFrog公司开发的一个强大的二进制包管理工具，支持各种主流的包管理系统，包括Java，Python，npm，npm，Maven，Gradle，NuGet，Ruby，YUM，Debian等。Artifactory可以帮助开发者和DevOps工程师存储、组织、管理（如访问控制、版本管理），以及跟踪他们的代码，减少构建和发布流程中的复杂性。\n\nArtifactory主要包含以下特性：\n\n1. 强大的二进制包管理能力：无论你是在本地还是在云端都可以管理和跟踪你的二进制包。\n2. 强大的集成能力：与主流的CI/CD工具，像Jenkins，Bamboo，TeamCity，和Docker等等做了深度的集成。\n3. 安全和访问控制：可以为你的仓库，包和元数据设置权限来保证你的代码的安全。\n4. 版本管理：可以管理和跟踪你的包的版本，确保你总能找到你需要的版本。\n5. 多仓库管理：Artifactory允许你为你的包设置不同的仓库，可以帮助你更好地组织你的包。\n\n### prune\ndocker system prune\ndocker system prune -a\n\n### 端口映射\n如果在Docker容器中运行的应用程序需要通过网络进行交互，那么端口映射是必须的。如果没有进行端口映射，会遇到以下问题：\n1. 外部访问：如果没有进行端口映射，那么外部设备（包括运行 Docker 的宿主机）无法通过网络访问到容器中的应用。这是因为 Docker 容器有自己的网络命名空间，对外界默认是隔离的。\n2. 通信隔离：另外，如果多个容器之间需要进行通信，如果没有正确的端口映射，也可能导致相互之间无法通信。\n3. 服务使用限制：对于某些需要阿尔特端口（如HTTP服务的80端口， HTTPS服务的443端口）的服务，如果你没有进行端口映射，可能就无法正常提供服务。\n\n\n### mongo compass\n- 可视化，及时更新客户端，关注release"},{"title":"jenkins-slave-nodes","url":"/2023/12/04/jenkins-slave-nodes/","content":"- 增加slave节点，用于构建\n- 场景 - nodejs18对于centos8的需求\n- Jenkins在centos7的机器上\n\n- manage jenkins\n- manage nodes and clouds\n- 新建节点\n\n- 用标签或者节点名字都能匹配，标签可以起个简洁的\n- only build jobs with label expressions matching this node\n- 启动方式（launch agents via ssh - 需要安装ssh插件 ssh build agents）"},{"title":"react-Event-summary","url":"/2023/11/15/react-Event-summary/"},{"title":"webview-缓存问题-practice","url":"/2023/11/14/webview-缓存问题-practice/","content":"https://www.geeksforgeeks.org/write-through-and-write-back-in-cache/\n\n- 在一个客户端 App 中，多个 WKWebView 使用中会共享一个 UI 进程(与 App 进程共享)、共享一个 Networking 进程、每个 WKWebView 实例独享一个 WebContent 进程\n- A WKProcessPool object represents a single process that WebKit uses to manage web content. To provide a more secure and stable experience, WebKit renders the content of web views in separate processes, rather than in your app’s process space. By default, WebKit gives each web view its own process space until it reaches an implementation-defined process limit. After that, web views with the same WKProcessPool object share the same web content process.(WebContent 进程启动规则 - <ios13)\n\n### 线程终止问题\n### wbwebviewmemory\n- webViewWebContentProcessDidTerminate\n- https://github.com/fuyoufang/WKWebViewMemory\n\n\n## WKWebView 请求拦截探索与实践\n\nhttps://juejin.cn/post/6922625242796032007/\nhttps://juejin.cn/post/7099004308120666120\n\n## GCDWebServer"},{"title":"doc-扫描-图像处理-summary","url":"/2023/11/14/doc-扫描-图像处理-summary/","content":"- https://www.dynamsoft.com/document-normalizer/docs/core/introduction/?ver=latest\n- https://www.dynamsoft.com/document-normalizer/docs/web/programming/javascript/"},{"title":"Building-a-javascript-bundler-reading","url":"/2023/11/14/Building-a-javascript-bundler-reading/","content":"https://cpojer.net/posts/building-a-javascript-bundler#compile-each-file-in-parallel\n其余系列文章\n```\n*   [Dependency Managers Don’t Manage Your Dependencies](/posts/dependency-managers-dont-manage-your-dependencies)\n*   [Rethinking JavaScript Infrastructure](/posts/rethinking-javascript-infrastructure)\n*   [Building a JavaScript Testing Framework](/posts/building-a-javascript-testing-framework)\n*   [Building a JavaScript Bundler](/posts/building-a-javascript-bundler) **(you are here)**\n```"},{"title":"highlight-practice","url":"/2023/11/14/highlight-practice/","content":"### IntersectionObserver\n```\nmark {\n  animation-name: highlight;\n  animation-timeline: view();\n}\n@​keyframes highlight { to { --light: 1; }}\nmark span {\n  background-position: calc((1 - var(--light)) * 110%) 0;\n  transition: background 1s;\n}\n```\nThe \"trick\" is to animate a custom property with a scroll-driven animation. These will flip in a binary fashion if not using @​property. And that's what you want.\n\nYou can then use that value to set the style on the highlights (<mark>). What you see is the transition of a background-position to get the multi-line highlight. A technique posted on this account before 🤙\n\nAdded bonuses:\n– Could use another element for the author initials of a highlight and animate that in too. Here the pseudoelement is being used. But another accessible span would do the trick.\n– Highlight color is scoped inline via hue.\n– View transition theme switch for a bonus that looks like a triangle. Been messing with Vercel docs so was the easiest thing to go with \n\n\n# Lightweight, robust, elegant syntax highlighting.\nhttps://github.com/PrismJS/prism\n\n### code-blocks-but-better\nhttps://pedro-ofurnl2ot-peduarte.vercel.app/writing/code-blocks-but-better"},{"title":"AIGC-doc-for-客服团队","url":"/2023/11/14/AIGC-doc-for-客服团队/"},{"title":"bundler-design-practice-summary","url":"/2023/11/14/bundler-design-practice-summary/","content":"- https://mp.weixin.qq.com/s/WS28QgKniN4fOya_ikoYkA\n- Bundler 的设计取舍：为什么要开发 Rspack?"},{"title":"podcasts-recommends","url":"/2023/11/13/podcasts-recommends/"},{"title":"artsy-summary","url":"/2023/11/08/artsy-summary/","content":"- https://github.com/artsy/energy\n\n### circleci\n- https://app.circleci.com/pipelines/github/artsy/energy?branch=main\n\n\n### callstack\n- https://github.com/callstack/react-native-testing-library\n- https://github.com/callstack/repack\n- https://github.com/callstack/linaria"},{"title":"hanzi-writer-summary","url":"/2023/11/08/hanzi-writer-summary/","content":"- https://github.com/chanind/hanzi-writer.git\n- 描红项目\n\n对于hanzi-writer-data的处理"},{"title":"游戏-cocos-design-arch-summary","url":"/2023/11/08/游戏-cocos-design-arch-summary/","content":"### 存档功能"},{"title":"自研骨架屏和框架骨架屏-summary","url":"/2023/11/07/自研骨架屏和框架骨架屏-summary/","content":"### 微信小程序骨架屏\n\n### 抖音骨架屏\n- https://developer.open-douyin.com/docs/resource/zh-CN/mini-app/develop/guide/experience-optimization/list/skeleton\n\n### T-Design 骨架屏\n\n### elementUI 骨架屏"},{"title":"patch-package-practice","url":"/2023/11/07/patch-package-practice/","content":"## 处理问题\nhttps://github.com/ds300/patch-package\n\n- 依赖的第三方包代码有问题，需要更新，最便捷的的方式\n\n`patch-package` 是在依赖包中进行小规模更改后，可以用来记录并复制这些更改的工具。以下是使用`patch-package`的最佳实践：\n\n1. 安装patch-package: 可以使用npm或yarn进行安装。\n   \n   使用npm: `npm i patch-package postinstall-postinstall`\n   \n   使用yarn: `yarn add patch-package postinstall-postinstall`\n\n2. 创建补丁: 先进行对依赖包的修改，然后运行`npx patch-package package-name`。\n\n3. 尽可能小的改动: 不要尝试使用patch-package进行大规模的更改。这可能导致版本升级时patch失败，甚至可能违反包的许可证。\n\n4. 使用git版本控制: 在使用patch-package之前，最好首先进行一次git commit，以便在产生一个补丁文件后，可以清楚地看到新增的更改。\n\n5. 在`postinstall`脚本中运行`patch-package`: 在`package.json`的`scripts`属性中添加一项 `\"postinstall\": \"patch-package\"`。这样做可以确保每次安装或更新依赖后都会自动应用补丁。\n\n6. 应用`yarn.lock` 或 `package-lock.json`: 这样做以确保将来的构建将使用相同的依赖项版本，并且补丁将应用。\n\n7. 切勿修改`node_modules`中包的源代码: 使用`patch-package`之前，一定要先在源代码中进行修改，然后再创建补丁文件。\n\n8. 提交patch文件到版本控制系统: 这样做以便其他开发者在`npm install`后能够应用同样的补丁。\n\n9. 在升级依赖项时小心: 当你升级一个已经打过补丁的包时，确保测试，因为补丁可能不再适用于新版本。\n\n记住，在修改一个包时，最好的选择通常是先提交一个pull请求到上游项目。然而，如果你需要快速修复问题，或者你的更改不太可能被上游项目接受，那么`patch-package`是一个非常有用的工具。"},{"title":"galacean-summary","url":"/2023/11/06/galacean-summary/","content":"https://galacean.antgroup.com/#/examples/latest/lottie-benchmark\n\n骨骼动画（Skeletal Animation）以较小的内存占用来生成抽象和复杂的动画。它通过对“骨骼”进行动画设计，然后使用这些骨骼来驱动模型的不同部分，创建出逼真的动画。\n\n在骨骼动画中，减少骨骼数量能够降低硬件计算压力，从而提高性能，特别是在某些硬件配置较低的设备中。\n\n苹果的 iPhone 设备有一个知名的限制是，它的 GPU 对 uniform 的数量有一定的限制。如果一个动画的骨骼数量超过这个限制，将不能正确地在这些设备上运行。因此，开发者在制作动画时需要考虑这些限制，并适应性地进行优化。\n\n JavaScript 不擅长于进行密集计算，但现在有很多工具和框架来处理这方面的问题。例如，WebGL 和 WebAssembly 可以使得在浏览器中执行高性能的数学和图形计算成为可能。\n\n ```\n 苹果的 iPhone 和一些其他设备存在一些 GPU 限制，其中之一就是对 uniform 的数量有一定限制。\n\nUniforms 是一种 WebGL（一种在浏览器中使用 GPU 的方式）中的概念，它们是从 JavaScript 发送到顶点着色器或片段着色器的数据。一般来说，它们用于存储时间、灯光、纹理样本器等值。\n\n苹果设备上的这个限制通常表现为最大工作负载（最多可以多少个 uniforms）。这个数量取决于设备的 GPU。对于某些早期或者入门级别的设备，这个限制可以低至 128 个 uniforms。\n\n这个限制在实际开发中可能会成为问题，特别是在开发复杂的 WebGL 应用，如 3D 游戏或者复杂的数据可视化应用时。达到 uniform 的限制可以导致应用无法正常渲染，甚至出现崩溃。\n\n解决这个问题的一种常见方式是更好地管理和优化你的 uniforms。比如，尽量减少不必要的 uniforms，复用 uniforms，或者使用纹理来存储数据以降低对 uniforms 的需要。\n\n需要注意的是，这个问题并不只存在于 iPhone 上，一些旧的或低端的 Android 设备上也可能存在相同的问题。同样，在 WebGL 2 中，这个限制已经得到了一定的提高，但是考虑到设备兼容性，开发者仍然需要注意这个问题。\n ```\n\n\n ### galacean effect\n https://galacean.antgroup.com/effects/inspiration\n\n\n\n ### 其他\n - https://github.com/svga/SVGAPlayer-Web-Lite"},{"title":"player-audio-summary","url":"/2023/11/06/player-audio-summary/","content":"### 项目分析\n- https://github.com/Moosync/Moosync.git\n\n- https://moosync.app/"},{"title":"declarative-shadow-dom-summary","url":"/2023/11/06/declarative-shadow-dom-summary/","content":"https://github.com/mfreed7/declarative-shadow-dom/blob/master/README.md\nhttps://chromestatus.com/feature/6239658726391808\nhttps://github.com/whatwg/html/pull/5465\nhttps://bugs.chromium.org/p/chromium/issues/list?q=component:Blink%3EDOM%3EShadowDOM\n\n\n\n\nhttps://developer.mozilla.org/en-US/docs/Web/API/Element/shadowRoot"},{"title":"jieba-node-summary","url":"/2023/11/03/jieba-node-summary/","content":"- 分词\n\n用法：\n- 文章分析加tag\n\n- https://github.com/yanyiwu/nodejieba"},{"title":"postcss-summary","url":"/2023/11/02/postcss-summary/","content":"- https://github.com/postcss/postcss\n- "},{"title":"expo-summary","url":"/2023/11/02/expo-summary/","content":"- https://github.com/expo/expo"},{"title":"rust-overview-summary","url":"/2023/11/02/rust-overview-summary/","content":"### 参考书\n- Rust 程序设计（第二版）\n- rust atomics and locks"},{"title":"fastlane-summary","url":"/2023/10/26/fastlane-summary/"},{"title":"meta-x5-chromium-based-webview-for-android","url":"/2023/10/26/meta-x5-chromium-based-webview-for-android/","content":"- https://engineering.fb.com/2022/09/30/android/launching-a-new-chromium-based-webview-for-android/"},{"title":"nodejs-20-practice","url":"/2023/10/24/nodejs-20-practice/","content":"- https://nodejs.org/en/blog/announcements/nodejs16-eol\n- https://nodejs.org/en/blog/announcements/v20-release-announce"},{"title":"vue-demi-best-practice","url":"/2023/10/24/vue-demi-best-practice/"},{"title":"react-testing-jest","url":"/2023/10/17/react-testing-jest/","content":"- 辅助库 - 模拟相关场景（DOM + 事件的模拟）\n- Enzyme\n- React Testing Library\n\n- "},{"title":"Shader-summary","url":"/2023/09/26/Shader-summary/","content":"- https://www.awwwards.com/websites/glsl/\n\n- https://github.com/alphardex/webgl-shader-book-code"},{"title":"UI-CODE-Summary","url":"/2023/09/26/UI-CODE-Summary/","content":"-  Design2Code（简称D2C）\n\n- https://github.com/wuba/Picasso\n- Picasso \n一款sketch插件，可将sketch设计稿页面自动解析成前端代码。\nPicasso是58同城推出的一款sketch设计稿解析插件，可将sketch设计稿自动解析成还原精准，可用度高的前端代码。\n\n- 阿里 - imgcook\n\n- 京东 - Deco\n\n\n- 转转 - 马良\n\n- Semi D2C\n\n- AI Lab - MS\n\n- Locofy\n\n### 设计类software\n- mastergo\n- figma\n- sketch"},{"title":"RISC-CISC-summary","url":"/2023/09/25/RISC-CISC-summary/","content":"\nARM 和 x86 是两种主流的 CPU 架构，各自遵循不同的设计理念。\n\n1. ARM (Advanced RISC Machine): ARM 架构遵循 RISC (Reduced Instruction Set Computing, 精简指令集) 设计原则。RISC 系统的一部分特性包括每个指令的执行时间都相当短（通常是一个时钟周期）以及指令的数量较少。这通常导致更高的处理器效率、更低的电力消耗，非常适合于手机、平板电脑等移动设备。\n\n2. x86: x86 架构遵循 CISC (Complex Instruction Set Computing, 复杂指令集) 设计原则。CISC 指令集的一部分特性包括每条指令可以执行多个低级操作，如加载、存储、运算等。得益于这样的设计，x86 架构通常有着更强大的性能和灵活性，非常适合于服务器、桌面计算机等高性能计算平台。\n\n当然，现代 ARM 和 x86 架构已经大幅融合了彼此的优点，比如x86 在功耗优化、ARM 在性能提升方面都做了许多努力。因此，这两者的界限已经开始模糊。\n\n苹果在2020年开始将其Mac设备从使用Intel的x86架构处理器转换为自家设计的基于ARM架构的Apple Silicon处理器。这些基于ARM的Apple Silicon被称为M1芯片。以下是截至目前使用Apple Silicon M1的Mac设备：\n\n1. MacBook Air (2020年末版及其后的版本)\n2. 13英寸MacBook Pro (2020年末版及其后的版本)\n3. Mac mini (2020年末版及其后的版本)\n4. 24英寸iMac (2021年中及其后的版本)\n5. MacBook Pro (2021年，带有14英寸和16英寸的M1 Pro或M1 Max芯片)\n\n未来，预计苹果会继续扩大其基于ARM的Mac产品线，取代现有的Intel x86架构Mac。\n\n### electron - arm dmg"},{"title":"lulu-ui-summary","url":"/2023/09/19/lulu-ui-summary/"},{"title":"aircode-summary","url":"/2023/09/19/aircode-summary/"},{"title":"eventtracing-summary","url":"/2023/09/19/eventtracing-summary/","content":"- https://eventtracing.github.io/docs/intro\n### 网易云音乐 - 曙光埋点\n- 多端支持\n\n\n### 美团内部系统"},{"title":"qrcode-summary","url":"/2023/09/15/qrcode-summary/","content":"- \"QR\" 在 \"QR Code\" 中代表 \"Quick Response\"，意为 \"快速响应\"。这是因为这种代码可以让扫描设备快速地读取其中的信息。初次发明于日本，被用于跟踪在制造过程中使用的汽车零件，但现在在全世界范围内应用广泛，包括存储网址、联系方式等各类信息。\n\n- https://support.google.com/chrome/answer/9979877?hl=en&co=GENIE.Platform%3DDesktop&oco=1\n\n\n## 支持browser和node env\n\n\n\n\n\n\n### node-canvas"},{"title":"基于sharp提供图片处理服务","url":"/2023/08/30/基于sharp提供图片处理服务/","content":"- https://sharp.pixelplumbing.com/\n- https://github.com/lovell/sharp\n\n\n`sharp` 是一个用于处理图片的高性能 Node.js 模块，大量使用了本地资源，并且选用的内存分配策略在某些系统或架构上可能会引发问题。\n\n当你使用类似 `sharp` 这种包时可能会出现内存申请错误，部分原因可能是 Node.js 默认的内存分配器 `ptmalloc` (或在某些版本中的 `tcmalloc`) 与 `sharp`引用的本地库的内存管理发生冲突。\n\n解决这种问题的一个办法就是更换 Node.js 的内存分配器。你可以试试使用 `jemalloc` 或者 `tcmalloc`。这些分配器可以清晰地分隔 Node.js 堆外的内存，规避 `ptmalloc` 可能存在的问题。\n\n要使用 `jemalloc`，你需要在系统中安装它（在 Ubuntu 上可以使用 `sudo apt-get install libjemalloc-dev`），然后在启动 Node.js 时设置环境变量 `LD_PRELOAD`。具体做法是在启动脚本前加一个环境变量声明，比如 `LD_PRELOAD=/usr/lib/x86_64-linux-gnu/libjemalloc.so node app.js`。\n\n另外，为确保 `sharp` 正常工作，也请确保你的系统上已安装了其需要的依赖项，如 `libvips` 库。在 Docker 环境中，考虑选择 ubuntu 或 debian 打底的镜像基础，避开 Alpine。因为 `sharp` 的一些依赖在 Alpine 中可能会有问题。\n\n最后，对于大型项目或在生产环境中，最好是进行充分的内存管理测试，以确保选用的方案能在所有预期的使用情况下正常工作。"},{"title":"video-player-summary","url":"/2023/08/30/video-player-summary/","content":"### videojs-player\n- https://github.com/surmon-china/videojs-player\n- (有vue,react，vanilla)\n- star 4.86k"},{"title":"esno-tsx-ts-node-summary","url":"/2023/08/28/esno-tsx-ts-node-summary/"},{"title":"npm-check-updates-summary","url":"/2023/08/28/npm-check-updates-summary/","content":"- https://www.npmjs.com/package/npm-check-updates\n- nestjs - 9-> 10 ,推荐使用"},{"title":"swc-summary","url":"/2023/08/28/swc-summary/","content":"- https://swc.rs/\n\nnestjs 10 使用了SWC\n- SWC（快速网络编译器）是一个基于 Rust 的可扩展平台，可用于编译和捆绑。将 SWC 与 Nest CLI 结合使用，是显著加快开发过程的简单好方法。\nSWC 的速度约为默认 TypeScript 编译器的 20 倍\n\nSWC is an extensible Rust-based platform for the next generation of fast developer tools. It's used by tools like Next.js, Parcel, and Deno, as well as companies like Vercel, ByteDance, Tencent, Shopify, and more.\n\nSWC can be used for both compilation and bundling. For compilation, it takes JavaScript / TypeScript files using modern JavaScript features and outputs valid code that is supported by all major browsers.\n\nSWC is 20x faster than Babel on a single thread and 70x faster on four cores.\n"},{"title":"minigame-canvas-engine-summary","url":"/2023/08/28/minigame-canvas-engine-summary/","content":"微信小游戏相关\n\n- https://wechat-miniprogram.github.io/minigame-canvas-engine/ （文档）\n- https://github.com/wechat-miniprogram/minigame-canvas-engine\n- https://segmentfault.com/a/1190000021297495?_ea=27021986\n\n\n- Layout 的目标在于用 Web 的开发方式来开发简单的 Canvas 应用。\n\n\n\n```\n微信小游戏引擎插件使用说明\n游戏引擎插件是微信 v7.0.7 新增的一项功能。此插件内置了 Cocos Creator 引擎的官方版本，若玩家首次体验的游戏中启用了此插件，则所有同样启用此插件的游戏，都无需再次下载 Cocos Creator 引擎，只需直接使用公共插件库中的相同版本引擎，或者增量更新引擎即可。\n\n例如，当一个玩家玩过了由 Cocos Creator v2.2.0 开发的 A 游戏，里面已启用了此插件。然后他又玩了同样是 v2.2.0 开发的 B 游戏，如果 B 游戏也启用了此插件，那么就无需重新下载 Cocos Creator 引擎。即使 B 游戏使用的是 v2.2.1 的 Cocos Creator，微信也只需要增量更新引擎两个版本的差异部分。这样就可以大幅减少小游戏的下载量，提升小游戏启动速度 0.5 ~ 2s，获得更好的用户体验。\n```\n\n## 基础能力\n### 网络\n\n### 存储\n\n### 文件系统\n\n### 渲染\n\n### 分包加载\n\n### 权限\n\n\n### 模块化\n\n\n### 场景值\n\n\n### 独立分包\n\n\n### worker基础能力\n\n\n### 周期性更新\n\n### 数据预拉取\n\n### 服务端API\n\n\n### 游戏引擎插件\n- https://developers.weixin.qq.com/minigame/dev/guide/base-ability/game-engine-plugin.html"},{"title":"vuepress-summary","url":"/2023/08/25/vuepress-summary/","content":"- https://v2.vuepress.vuejs.org/zh/advanced/plugin.html"},{"title":"ant-design-vue-summary","url":"/2023/08/24/ant-design-vue-summary/","content":"- https://www.antdv.com/docs/vue/introduce-cn/"},{"title":"harmonyOS-dev-summary","url":"/2023/08/15/harmonyOS-dev-summary/","content":"- 真机测试\n- hdc 如果报inner error，先要确认真机的API版本，然后再进行开发\n\n## 开发模型\n- FA（不建议使用）\n- Stage（1.支持多窗口2.进程单ArkTS引擎）\n\n进程间的数据和内存共享是操作系统中一个重要的概念，特别是在多任务和并发编程中。如果一个引擎运行在单一进程上，并且所有应用程序也在这同一进程中运行，它们将能够直接访问相同的内存空间，实现无缝的数据共享。\n\n这种设计可以提高数据访问的效率，因为它消除了进程间通信（IPC）的需要，而进程间通信至少需要一次上下文切换和数据拷贝，这对性能的影响是很大的。另一方面，这种设计也会带来一些挑战，比如应用程序之间的隔离性和安全性问题，因为在同一进程中运行的应用程序理论上能够访问进程的所有资源。\n\n## HAP\n- 一个可以独立运行的完整模块\n- like - aab标准包格式\n- 华为HAP (HarmonyOS Ability Package) 是华为为其操作系统 HarmonyOS 设计的一种应用程序包格式。为了在 HarmonyOS 设备上运行，应用程序需要被打包为 HAP 包。\n以 HAP 格式打包的应用程序可以在多种类型的 HarmonyOS 设备上运行，包括智能手机、智能电视、智能穿戴装置等。\nHAP 包包含应用程序的所有资源，包括代码、静态文件、图标等。它们可以从华为的分发平台（如 AppGallery）上下载并安装。\n- 相同能力内敛+按需加载，共享能力减少包体积大小\n\n## ohpm\n- 基于npm,pnpm\n\n\n## HAR/HSP\n- 在app中是否以单例模式存在\n- har,在不同的模块，存在不同的包实例\n- hsp,模块的包实例是同一个\n\n## 组件和状态\nUI描述\n数据与数据状态交互处理（底层逻辑）\n\nArkUI - 声明式表达UI\nArkTS - ArkTS 是 HarmonyOS 优选的主力应用开发语言。ArkTS 围绕应用开发在 TypeScript（简称 TS）生态基础上做了进一步扩展，继承了 TS 的所有特性，是 TS 的超集。 \n"},{"title":"rapid-electron-app-summary","url":"/2023/08/15/rapid-electron-app-summary/","content":"```\nnpm ERR! command sh -c node install.js\nnpm ERR! RequestError: connect ETIMEDOUT 20.205.243.166:443\nnpm ERR!     at ClientRequest.<anonymous> (/Users/kuangyimin/rapid.app/node_modules/got/dist/source/core/index.js:970:111)\nnpm ERR!     at Object.onceWrapper (node:events:626:26)\nnpm ERR!     at ClientRequest.emit (node:events:523:35)\nnpm ERR!     at origin.emit (/Users/kuangyimin/rapid.app/node_modules/@szmarczak/http-timer/dist/source/index.js:43:20)\nnpm ERR!     at TLSSocket.socketErrorListener (node:_http_client:495:9)\nnpm ERR!     at TLSSocket.emit (node:events:511:28)\nnpm ERR!     at emitErrorNT (node:internal/streams/destroy:151:8)\nnpm ERR!     at emitErrorCloseNT (node:internal/streams/destroy:116:3)\nnpm ERR!     at process.processTicksAndRejections (node:internal/process/task_queues:82:21)\nnpm ERR!     at TCPConnectWrap.afterConnect [as oncomplete] (node:net:1571:16)\n```\n- electron 安装的网络问题\n- electron的install.js\n- 处理下网络代理即可\n- install.js -> @electron/get -> got \n\n\n### https://www.electronforge.io/\n- electronforge\n- Electron Forge 是打包和发布 Electron 应用程序的一体化工具。它结合了许多单一用途的软件包，创建了一个完整的构建管道，开箱即用，包括代码签名、安装程序和工件发布。对于高级工作流程，可通过其插件应用程序接口（Plugin API）在 Forge 生命周期中添加自定义构建逻辑。\n- 基本上在electron应用开发中的工程化和发布问题，都一站式解决了"},{"title":"CodeAnalysis-部署与应用","url":"/2023/06/30/CodeAnalysis-部署与应用/","content":"在 CentOS 8 上，可以使用以下命令来查看有关计算机的信息：\n1. 查看 CPU 信息：\n```\nlscpu\n```\n2. 查看内存使用情况：\n```\nfree -h\n```\n3. 查看硬盘空间及使用情况：\n```\ndf -h\n```\n4. 显示所有 PCI 设备：\n```\nlspci\n```\n5. 显示所有 USB 设备：\n```\nlsusb\n```\n6. 查看网卡信息：\n```\nip addr show\n```\n或\n```\nnmcli device status\n```\n7. 查看操作系统版本：\n```\ncat /etc/centos-release\n```\n8. 查看运行的进程：\n```\ntop\n```\n或\n```\nhtop\n```\n（需要先安装 htop：`sudo dnf install -y htop`）\n9. 查看已安装软件包：\n```\ndnf list installed\n```\n10. 查看系统负载：\n```\nuptime\n```"},{"title":"EdgeWebView2-summary","url":"/2023/06/29/EdgeWebView2-summary/","content":"- https://mp.weixin.qq.com/s/Dh2t_UcRNMUTrxVVPVQVbw\n- Electron末日来了？又一应用将其抛弃！WhatsApp强制推行原生应用：速度更快、内存占用更少\n- 十年“屎山”终重构，但 QQ选用了微软 Teams 放弃的 Electron\n(微软teams转到了EdgeWebView2)\n```\n该如何选择跨平台框架\n虽然多端统一带来很多便利，但跨平台框架并非万能。“跨平台意味着需要花费很多时间来解决平台差异性问题，同时要面临第三方库不够原生平台丰富健壮的现状。跨平台其实是牺牲部分功能和体验，换取开发速度和一致性的权衡，并不是业务开发的银弹。”腾讯微信客户端工程师方秋枋曾说道。\n\n目前，并没有一个能完善解决这些问题的解决方案。事实上，GitHub 重写应用的团队也曾表示，Web 并非完美的平台，不过原生应用也不是。使用 Electron 重写原生应用只不过是在不同的权衡点之间进行了交换。\n\n方秋枋认为，从框架开发者的角度，跨平台开发的难点就在于处理平台差异性。从框架使用者的角度，难点在于如果框架出问题了，维护成本将会变得非常高。\n\n那么，企业如何选择适合自己的跨平台开发框架？\n\n阿里巴巴淘系技术部资深无线技术专家黄刚（花名：腾渊）曾分享道，从应用的 Life Cycle 来看，研发阶段只是其中一个阶段，是否具有长久的可维护性、可运维性也是需要重点考虑的问题。\n\n腾渊表示，如果在当下的业务形态里，前台展现是高度产品化、比较稳定或者对于性能以及交互的要求极度苛刻的，那么 Cross-Platform First 未必是一个理想的选择。一方面，多平台开发工作在整个研发成本里的占比不高，ROI 未必高；另一方面是 Cross-Platform First 是以牺牲平台特性为代价来达到跨平台的一致性。在达到一致性表现的过程中，工程上的填坑成本可能更高。\n\n反过来讲，如果当前的业务，前台的呈现比较不稳定并且整个前台开发占比较高，那么应用跨平台框架的收益就比较高了。\n\n腾渊认为，从 Hybrid 的方案到 React Native、Weex 再到 Flutter，本质上都是在研发成本、灵活性、性能体验三者间找一个平衡点，只是大家切入的点不太一样，最终导致整个解决方案有了不同。\n\n“假设现在你要做一个新的 App，可能整个开发团队是多前端、少客户端的，那我可能比较建议考虑 Hybrid 的模式；如果对性能要求比较高，可以考虑 Weex 或者 React Native；反过来，如果是客户端同学比较多，那么考虑下 Flutter 未尝不可。”腾渊说道。\n```"},{"title":"vuejs设计与实现-notes","url":"/2023/06/28/vuejs设计与实现-notes/","content":"### code地址\n- https://github.com/HcySunYang/code-for-vue-3-book.git\n"},{"title":"clipboard-summary","url":"/2023/06/28/clipboard-summary/","content":"https://github.com/zenorocha/clipboard.js"},{"title":"ckeditor-summary","url":"/2023/06/28/ckeditor-summary/","content":"### builder\n- https://ckeditor.com/docs/ckeditor5/latest/installation/getting-started/quick-start.html#creating-custom-builds-with-online-builder"},{"title":"nodejs-project-inspiration","url":"/2023/06/28/nodejs-project-inspiration/","content":"#### actionhero\n- Actionhero是一个具有集成集群能力和延迟任务的多传输API服务器。actionhero的目标是创建一个易于使用的工具包，为HTTP、WebSockets等制作可重复使用和可扩展的API。连接到actionhero服务器的客户端可以消费api，消费静态内容，并相互通信。Actionhero是集群就绪的，内置支持后台任务、0-downtime部署等。Actionhero提供了一个简单的Async/Await API来管理每一种类型的连接和后台任务。\n\n"},{"title":"nestjs-design-pattern-summary","url":"/2023/06/15/nestjs-design-pattern-summary/","content":"### adapter\n\n\n\n\n### nest-cli\ncommand-line interface tool\ninitialize, develop, and maintain your Nest applications\nscaffolding the project\nserving it in development mode\nbuilding and bundling the application for production distribution\nIt embodies best-practice architectural patterns to encourage well-structured apps\n\n#### @nestjs/schematics\n- Nest architecture element generation based on Angular schematics \n\n\n\n### builder\n\n\n\n\n\n## doc\n- 哲学 - 提供了应用程序“架构”\n- 安装（$ npm i --save @nestjs/core @nestjs/common rxjs reflect-metadata - 核心和支持文件）\n```\nrxjs - A reactive programming library for JavaScript - Reactive Extensions Library for JavaScript\nRxJS 是一个使用 Observables 进行反应式编程的库，可让异步或基于回调的代码更容易编写。\n```\n```\nreflect-metadata是一个用于装饰器的元数据反射API。这是一种在Javascript中实现元数据反射操作的工具，可以用于增强对象和函数等的功能。\n1. 安装导入\n   npm i reflect-metadata\n   import 'reflect-metadata';\n2. 使用装饰器：装饰器可以使用元数据来改进类、属性、方法等\n   @Reflect.metadata(metadataKey, metadataValue)\n   class MyClass {\n   }\n3. 查询元数据：\n   let data = Reflect.getMetadata(metadataKey, target);\n   let ownData = Reflect.getOwnMetadata(metadataKey, target);\n4. 避免全局污染：`reflect-metadata`库会污染全局环境，因此应该只在你的应用或库的主要入口点导入一次。它不应该被导入到内部模块中。\n5. 配置TypeScript：要在TypeScript中使用元数据反射，你需要在tsconfig.json文件中启用`emitDecoratorMetadata`和`experimentalDecorators`选项。\n   {\n       \"compilerOptions\": {\n           \"target\": \"ES5\",\n           \"module\": \"commonjs\",\n           \"experimentalDecorators\": true,\n           \"emitDecoratorMetadata\": true\n       }\n   }\n6. 明确元数据键：应该使用Symbol而不是字符串作为元数据键，以避免冲突。\n7. 测试：使用`reflect-metadata`时应确保进行适当的单元测试，在大型项目上可以考虑用Mock来模拟这些元数据\n```"},{"title":"vuetifyjs-summary","url":"/2023/06/15/vuetifyjs-summary/"},{"title":"Daemon-demon-summary","url":"/2023/05/31/Daemon-demon-summary/","content":"- \"daemon\" 和 \"demon\" 在英文中表示两个完全不同的概念，尽管它们发音相似，但分别具有不同的含义。\n\n1. Daemon（守护进程）：顾名思义，daemon 是关于计算机进程的术语，特指一种在后台运行的长期进程。它们通常不需要用户交互，负责完成各种自动任务。守护进程常用于提供操作系统或应用程序需要的基础服务。在计算机领域，它可以类比为一种无形的助手，默默为计算机提供服务。\n\n2. Demon（恶魔）：恶魔一词原意表示神话和宗教传统中的邪恶、恶意的精神或神秘力量。它们通常与神秘、超自然和邪恶行为联系在一起。在文学、电影和游戏中，恶魔角色形象多样，通常具有一定程度的魔力和邪恶目的。这个词并没有计算机术语的含义。\n\n\n> \"daemon\" 这个名字起源于古希腊神话，最初是 \"δαίμων\" (daimon)。在古希腊文化中，daimon 是指介于神与人之间的神秘力量或精神，它通常被认为是有意识且具有某种程度的个性的实体。它们在某些场景中可以对人类产生积极或消极的影响，也可以作为神与人之间传递信息的媒介。\n\n- 在计算机术语中，daemon（有时也称为守护进程或守护程序）是一种在后台运行的程序，它通常用于处理定期的任务、监听传入的连接请求或执行系统维护任务。因为它们持续在后台工作、在很大程度上独立于用户交互，并且无需人工干预即可自动执行特定任务，这使得计算机领域中的守护进程与古希腊中的 daimon（神灵）有某种程度的相似性。这些守护进程习惯沿用\"daemon\"作为名称以代表其与古希腊神话中类似的功能性。\n\n"},{"title":"metro-summary","url":"/2023/05/31/metro-summary/","content":"\n### metro\nMetro 是一款由 Facebook 开发的自动化打包器和优化器，用于加速 React Native 和 Node.js 的开发。Metro 不仅在 Facebook 得到了广泛应用，还在其他很多公司和开源项目中使用。一些使用 Metro 的知名案例包括：\n\nWalmart：全球最大的零售商之一，使用 Metro 优化其 React Native 应用程序。\nExpo：提供了一个从头开始开发 React Native 应用程序的工具套件，内部使用了 Metro。\nCallstack：专门从事 React Native 项目开发的 IT 公司，使用 Metro 作为其优化器和打包器。\nWix：为其 React Native 应用程序使用 Metro 进行打包和优化。\nMicrosoft: 使用 Metro 作为其 React Native for Windows 和 React Native for macOS 项目的一部分。\n\n- metro提供Javascript的bundler的功能\n## 概念\n#### 构建阶段 - bundling process\n- Resolution：此阶段Metro会从入口文件出发分析所依赖的模块生成一个所有模块的依赖图，主要是使用jest-haste-map这个包做依赖分析。这个阶段和Transformation阶段是并行的；\n- Transformation：此阶段主要是将模块代码转换成目标平台可识别的格式；\n- Serialization：此阶段主要是将Transform后的模块进行序列化，然后组合这些模块生成一个或多个Bundle\n\n### cases\n#### React Native工程Monorepo改造实践\n- https://juejin.cn/post/7177585131861835837\n#### 基于 React Native 的动态列表方案探索\n- https://juejin.cn/post/7142819695840722975\n\n\n## deep dives\n里面四个点可以看看\n#### bundle formats\n#### caching\n#### module resolution\n#### source map format"},{"title":"turbo-summary","url":"/2023/05/31/turbo-summary/","content":"> https://github.com/vercel/turbo\n- 是vercel家的\n\n- Turbo是一个用于前端开发的下一代工具链，用Rust编写。它由3个主要部分组成：\n\n- Turbopack：一个增量的捆绑器（Webpack的后继者）\n- Turborepo：一个增量的构建系统\n- Turbo引擎：一个低级别的增量计算和记忆化引擎\n\n\n### 使用的项目\n- https://github.com/vercel/vercel"},{"title":"pixijs-summary","url":"/2023/05/30/pixijs-summary/","content":"\n\n\n\n### 其他\n#### eva.js\n- https://github.com/eva-engine/eva.js\n```\nEva.js 是一个专注于开发互动游戏项目的前端游戏引擎。\n易用：Eva.js 提供开箱即用的游戏组件供开发人员立即使用。是的，它简单而优雅！\n高性能：Eva.js 由高效的运行时和渲染管道 (Pixi.JS) 提供支持，这使得释放设备的全部潜力成为可能。\n可扩展：得益于 ECS（实体-组件-系统）架构，你可以通过高度可定制的 API 扩展您的需求。唯一的限制是你的想象力！\n```\n- https://eva.js.org/playground/#/resource\n"},{"title":"justjavascript-summary","url":"/2023/05/29/justjavascript-summary/","content":"- https://justjavascript.com/\n\nExplore the JavaScript Universe\nRebuild your mental model from the inside out.\n\nDan通过帮助构建一个认知模型（图形化的方式），让读者能够随着他帮忙构建的模型，去认知JS中基础的一些概念（或者说任何一个语言中，我们自己去判断分析问题时，自己心中构建的认知模型）\n\n基本上围绕着：\n```\nValues & variables\nStatements & expressions\nPrimitive types\nObjects & functions\nnull & undefined\nProperties & prototypes\n```\n能够明白基本类型和对象的区别，然后哪些设计上的问题其实是可以忽略的；\n什么是值，什么是变量\n表达式到底是什么，遵循的规则\n空和未定义为什么会有\n属性是什么，怎么建立模型\n原型是什么，怎么建立模型\n```\n・ Mental Models\n・ The JavaScript Universe\n・ Values and Variables\n・ Studying from the Inside\n・ Meeting the Primitive Values\n・ Meeting Objects and Functions\n・ Equality of Values\n・ Properties\n・ Mutation\n・ Prototypes\n```\n里面核心阐述了一个问题，怎么通过建立正确的模型，让面对问题的时候，不再有不确定的感觉\n而训练的模式也很有趣，先是讲解，然后通过quiz exercises不断强化这些概念\n\n当看完整个的时候，基本上遇到问题，就可以画出现首页上面的那个图了，从而可以帮助判断问题；\n\n> Dan 在YTB上面也有视频，可以瞅瞅，他在线写代码时候，思考问题的方式\n\n- https://github.com/allenGKC/Just-Javascript-Reading-Notes.git"},{"title":"petite-vue","url":"/2023/05/26/petite-vue/","content":"## 文档中提及部分\n### 使用Vue的多种方式\n#### 独立脚本​\nVue 可以以一个单独 JS 文件的形式使用，无需构建步骤！如果你的后端框架已经渲染了大部分的 HTML，或者你的前端逻辑并不复杂，不需要构建步骤，这是最简单的使用 Vue 的方式。在这些场景中你可以将 Vue 看作一个更加声明式的 jQuery 替代品。\n\nVue 也提供了另一个更适用于此类无构建步骤场景的版本 petite-vue。它为渐进式增强已有的 HTML 作了特别的优化，功能更加精简，十分轻量。\n\n\n### Vue 与 Web Components\n#### 基于 Vue 构建自定义元素库\n当使用 Vue 构建自定义元素时，该元素将依赖于 Vue 的运行时。这会有大约 16kb 的基本打包大小，并视功能的使用情况而增长。这意味着如果只编写一个自定义元素，那么使用 Vue 并不是理想的选择。你可能想要使用原生 JavaScript、petite-vue，或其他框架以追求更小的运行时体积。但是，如果你需要编写的是一组具有复杂逻辑的自定义元素，那么这个基本体积是非常合理的，因为 Vue 允许用更少的代码编写每个组件。在一起发布的元素越多，收益就会越高。\n\n### 工具链\n#### 浏览器内模板编译注意事项\n默认的工具链中都会使用仅含运行时的版本，因为所有 SFC 中的模板都已经被预编译了。如果因为某些原因，在有构建步骤时，你仍需要浏览器内的模板编译，你可以更改构建工具配置，将 vue 改为相应的版本 vue/dist/vue.esm-bundler.js。\n\n如果你需要一种更轻量级，不依赖构建步骤的替代方案，也可以看看 petite-vue。\n\n### 为什么要使用 SFC\n当然，在一些轻量级场景下使用 SFC 会显得有些杀鸡用牛刀。因此 Vue 同样也可以在无构建步骤的情况下以纯 JavaScript 方式使用。如果你的用例只需要给静态 HTML 添加一些简单的交互，你可以看看 petite-vue，它是一个 6 kB 左右、预优化过的 Vue 子集，更适合渐进式增强的需求。\n如果你只在渐进式增强的场景下使用 Vue，并想要避免使用构建步骤，请考虑使用 petite-vue (只有 6kb) 来代替。"},{"title":"UUID-summary","url":"/2023/05/22/UUID-summary/","content":"### UUID\n\n\n#### nanoid\n与UUID的比较\nNano ID与UUID v4（基于随机）相当。它的ID有类似的随机位数（Nano ID为126，UUID为122），所以它有类似的碰撞概率：\n\n要想有十亿分之一的重复机会，必须产生103万亿个版本4的ID。\n\nNano ID和UUID v4之间有两个主要区别：\n\nNano ID使用更大的字母表，所以类似数量的随机比特被包装在仅仅21个符号中，而不是36个。\nNano ID代码比uuid/v4包小4倍：130字节而不是423字节。"},{"title":"twind-inspiration-notes","url":"/2023/05/22/twind-inspiration-notes/","content":"- https://twind.style/\n```\nInspiration\nIt would be untrue to suggest that the design here is totally original. Other than the founders' initial attempts at implementing such a module (oceanwind and beamwind) we are truly standing on the shoulders of giants.\n\nTailwind: created a wonderfully thought out API on which the compiler's grammar was defined.\nstyled-components: implemented and popularized the advantages of doing CSS-in-JS.\nhtm: a JSX compiler that proved there is merit in doing runtime compilation of DSLs like JSX.\ngoober: an impossibly small yet efficient CSS-in-JS implementation that defines critical module features.\notion: the first CSS-in-JS solution specifically oriented around handling CSS in an atomic fashion.\nclsx: a tiny utility for constructing class name strings conditionally.\nstyle-vendorizer: essential CSS prefixing helpers in less than 1KB of JavaScript.\nUnoCSS: for the configuration syntax.\nCSSType: providing autocompletion and type checking for CSS properties and values.\n```\n文档里面有一段inspiration，列举了参考的设计\n- Tailwind：创造了一个经过深思熟虑的API，在此基础上定义了编译器的语法。\n- styled-components：实现并推广了在JS中使用CSS的优势。\n- htm：一个JSX编译器，证明了对DSL（如JSX）进行运行时编译的好处。\n- goober：一个小得不能再小但高效的CSS-in-JS实现，定义了关键的模块特性。\n- otion：第一个CSS-in-JS解决方案，专门用于以原子方式处理CSS。\n- clsx：一个用于有条件地构建类名字符串的小工具。\n- style-vendorizer：在不到1KB的JavaScript中提供基本的CSS前缀辅助工具。\n- UnoCSS：用于配置语法。\n- CSSType：为CSS属性和值提供自动补全和类型检查。\n\n\n\n### windi css\n- Windi CSS is a next-generation utility-first CSS framework.\n- 为什么选择 Windi CSS？\n作者的一段话应能说明他创建 Windi CSS 的动机：\n当我的项目变得越来越大，有大约几十个组件时，初始编译时间达到了 3 秒，而使用 Tailwind CSS 进行热更新则需要 1 秒以上。- @voorjaar\n通过扫描 HTML 和 CSS 并按需生成实用程序，Windi CSS 能够在开发过程中提供更快的加载时间和更快的 HMR，而在生产过程中则无需清除。"},{"title":"log相关-summary","url":"/2023/05/19/log相关-summary/","content":"- https://javascript.plainenglish.io/can-console-log-cause-memory-leaks-how-to-make-a-browser-crash-with-console-log-b94e4d248ed8\n- console.log在不同运行时中，是否会导致内存泄露\n\n在 Node.js 中，当你使用 `console.log` 打印对象时，对象会被转换为字符串形式，这样才能在终端（控制台）中显示。这个过程中，Node.js 会使用 `util.inspect()` 函数来对传入的对象进行检查，并将其转换为字符串。`util.inspect()` 提供了一定程度的自定义，例如显示深度（默认为 2）以及其他格式选项。\n\n`console.log` 本质上是一个用于调试的工具，Node.js 会将转换好的字符串传递给运行时的标准输出（stdout）流。然后，终端程序会显示这个字符串，便于我们查看和理解代码运行结果。\n\n以下是一个简单示例：\n\n```javascript\nconst obj = {\n  a: {\n    b: 1,\n    c: [2, 3],\n  },\n};\n\nconsole.log(obj);\n```\n\n当运行这段代码时，Node.js 会将 `obj` 转换为字符串，并在终端中显示如下：\n\n```\n{\n  a: {\n    b: 1,\n    c: [ 2, 3 ]\n  }\n}\n```\n\n需要注意的是，在处理大型对象时，`console.log` 可能会对性能产生一定影响。当你需要打印诸如循环引用、数千个属性的对象等内容时，会影响性能。在生产环境中，你应该避免使用 `console.log`，而使用结构化的日志记录库来记录可能需要的日志信息。这样可以更好地管理日志，并调整日志级别以避免性能问题。\n"},{"title":"nodejs-issue-观察周记","url":"/2023/05/19/nodejs-issue-观察周记/","content":"### 新运行时\n1. Deno：\n   - 由Node.js的创始人Ryan Dahl创建，致力于纠正Node.js中他认为的设计缺陷。\n   - 采用V8引擎和Rust编程语言。\n   - 内置TypeScript支持。\n   - 提供类似Go语言的导入方式，允许从公共URL导入模块。\n   - 遵循浏览器兼容的API。\n   - 默认安全模式，需要明确授权才能访问文件系统，网络，环境变量等。\n   - 支持WebAssembly。\n\n2. Just：\n   - 是一个轻量级的Node.js替代品。\n   - 采用V8引擎和C++编写。\n   - 面向内存优化、嵌入式编程和基于事件循环的高性能场景。\n   - 包括少量内置模块和简化的核心API。\n   - 支持Linux和macOS，但对Windows支持有限。\n   - 非同步I/O，并专注于运行时性能。\n\n3. Bun：\n   - 由PolyFis创建，专注于高性能、小尺寸和安全性。\n   - 采用V8引擎和C++编写。\n   - 支持记号输出、优化跳过解析和单线程异步I/O。\n   - 包括jsdom、WebSocket、HTTP/2等特性。\n   - 支持WebAssembly。\n   - 独特的内存分配和回收策略。\n   - 支持Linux、macOS 和 Windows。\n"},{"title":"nodejs-vm","url":"/2023/05/17/nodejs-vm/","content":"- https://nodejs.cn/api/vm.html\n\n"},{"title":"Nodejs-WebInteroperableRuntime","url":"/2023/05/17/Nodejs-WebInteroperableRuntime/"},{"title":"nodejs-packages-summary","url":"/2023/05/15/nodejs-packages-summary/"},{"title":"插件设计","url":"/2023/05/05/插件设计/","content":" \n易于扩展，借助社区开发者扩展新能力，保持主体程序稳定。\n\n逻辑解耦，主程序和插件代码保持独立，降低主程序复杂度。\n\n动态插拔，用户可以按需引入指定插件，提升工具灵活性。\n\n\n\n### 代码分析工具\n代码分析工具有固定的分析范式，也就是代码分析的主程序，在此基础上需要拓展的是各种 API 调用分析指标，引入插件体系可以将处理分析指标的逻辑从主程序中剥离出来，主要目的：\n\n使得插件代码与主程序代码在工程上解耦，对插件开发者隔离主程序逻辑复杂度，便于其独立开发。\n\n不论是系统开发者，还是社区第三方开发者，都可以参与拓展新的分析指标，提升分析工具生命力。\n\n"},{"title":"代码静态分析","url":"/2023/04/28/代码静态分析/","content":"### 腾讯云静态分析\n- TCA, Tencent Cloud Code Analysis  code-named: CodeDog\n- https://cloud.tencent.com/product/tcap\n- https://github.com/Tencent/CodeAnalysis\n- https://github.com/Tencent/CodeAnalysis/blob/main/README_ZH.md\n\n#### 部署\n- https://tencent.github.io/CodeAnalysis/zh/quickStarted/dockerDeploy.html\n\n### why\n- 制定了规则之后\n- 定时收集分析 + 检查 -》 了解并管控\n- API文档无法表述真实的依赖关系（有问题的API调用，hack行为等 =》 API提供方-被动向后兼容）\n\n### what\n- 代码静态分析是指在不实际执行程序的情况下，对代码语义和行为进行分析\n\n#### example\n- eslint - 定位语法错误\n- git hook + gitlab CI\n- 应用分析report\n- 应用分析platform\n\n### how\n\n#### Dart Analyzer\n- Flutter针对Android Studio和VS Code开发的插件，使用Android Studio或者VS Code进行开发，不需要配置就可以看到Dart Analyzer工具提供的静态分析结果\n- Dart Analyzer工具会使用默认的analysis_options.yaml文件中的内容执行代码静态分析\n\n\n#### typescript\n- https://jkchao.github.io/typescript-book-chinese/compiler/scanner.html#%E8%A7%A3%E6%9E%90%E5%99%A8%E5%AF%B9%E6%89%AB%E6%8F%8F%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8\n#### tools\n- https://www.softwaresecured.com/\n- https://www.veracode.com/products/binary-static-analysis-sast\n- https://embold.io/\n- https://deepscan.io/\n- https://www.codacy.com/\n- https://www.sonarsource.com/products/sonarqube/\n- https://deepsource.com/\n\n\n\n### 基于 AST 的代码处理工具工作流程\n#### Parsing（解析）\n这个过程由编译器实现，会经过词法分析和语法分析两个过程，生成 AST\n\n#### Traversing（遍历）\n深度优先遍历 AST ，访问树上各个节点的信息\n\n#### Transforming（修改）\n在遍历的过程中可对节点信息进行修改/转化，生成新的 AST\n\n#### Printing（输出）\n将转化后新的 AST 输出成新的代码块\n\n### 编译器 Parser\n- Parser 的 API 可以帮助我们完成代码的词法分析与语法分析，并返回对应的 AST 对象\n- JS Parser： esprima、 acorn、 espree、@babel/parser。\n- TS Parser：typescript (https://github.com/microsoft/TypeScript/)\n\n\n## cases\n### 依赖调用分析\n- 遍历其所有 import 节点，分析并记录从目标依赖引入的 API 信息，并排除非目标依赖项的干扰。\n\n- 判定引入的 API 在具体代码中是否有调用，过程中还需要排除局部同名变量等一系列干扰。\n\n- 根据分析指标如用途识别等对该 API 调用进行指标判定分析，命中则记录到指定 Map 中。\n\n- 依次遍历所有项目中指定的 TS(JS) 文件，就可以得到全部应用对于特定依赖的 API 调用分析数据了，最后根据使用场景（告警、评分、代码报告、代码建议等）对分析数据进行标记，二次整理，即可输出最终的分析结\n\n\n### 抽象成分析模型 - 如何设计解决问题的通用方法论\n#### 依赖调用分析模型\n- 依赖调用方\n- 依赖提供方\n- 面向对象编程\n```\nWebpack - Compiler\n```\n- 生成一个基础类\n### codeAnalysis\n- Webpack：把依赖调用分析过程中涉及的方法，属性都封装在名为 codeAnalysis 的基础类中\n- 依赖调用分析流程的抽象，在生成分析实例后，通过实例来驱动整个分析流程\n- 基础类中包括扫描代码文件、解析 AST、遍历 AST、统计信息、安装插件、执行插件、链式检查、黑名单标记和代码评分等在内的一系列方法，重要属性\n\n### 分析范式\n- 执行时序 -> 执行生命周期（分析范式）\n- 根据分析范式步骤完善基础类的过程就是实现代码分析工具的过程\n\n### 解耦性、拓展性、可用性\n- 辅助模块\n- 架构设计: 解耦性、拓展性、可用性\n\n\n#### 分析 Import 节点\n-  Import 模块是一种特殊的声明语句，isImportDeclaration\n- 局部导入 named import\n- 默认全局导入 default import\n- 局部别名导入 namespaced import \n- 全局别名导入 namespaced import \n- 每种导入类型都存在唯一的判定条件\n- moduleSpecifier.text\n- 自上而下的分析（先找到所有的 Import 节点，然后通过观察不同导入方式下 AST 及其子节点结构特征，总结出了各种导入方式的唯一性判断条件，然后根据这些判定条件完成了分析逻辑）\n\n#### 判定API调用\n- 遍历 Identifier 节点\n- 排除 Import 中同名节点干扰（pos 与 end  identifierPos 和 identifierEnd）\n- 排除局部声明的同名节点干扰（symbolPos symbolEnd ）\n- 检测链式调用\n- 自下而上的分析（以 identifier 这种处于 AST 末端的节点作为切入点来实现判定逻辑）\n\n\n#### API调用信息统计\n```\n// context : codeAnalysis分析实例上下文\n// tsCompiler : typescript编译器\n// node : 基准分析节点baseNode\n// depth : 链式调用深度\n// apiName : api完整调用名（含链式调用）\n// matchImportItem : API调用在import节点中的声明信息\n// filePath : 代码文件路径\n// projectName : 待分析代码文件所在的项目名称\n// line : API调用所在代码文件中的行信息\n```\n\n### Method API 分析\n- CallExpression\n- 需要排除被当成方法入参调用的场景\n\n### Type API 分析\n- 不论是普通类型还是泛型，都可以通过判断其基准节点的父级节点是否为 TypeReference 类型来判定该 API 是否属于类型调用\n### 插件方案\n- 通过插件方案来解决主程序与子程序之间的代码结构问题\n- 插件模式来管理可拓展能力(webpack, eslint)\n"},{"title":"openai-summary","url":"/2023/04/28/openai-summary/","content":"- azure部署相关\n- https://github.com/Yidadaa/ChatGPT-Next-Web/issues/371\n- https://github.com/Yidadaa/ChatGPT-Next-Web/blob/main/docs/faq-cn.md\n\n\n\n#### voice\n- speech - recognize - 端上能力（web-浏览器提供能力，Apple-ios10-speech）\n- https://chatgpt.sonng.dev/\n- heychatgpt\n\n#### chatgpt\n- chat generative pre-training transformer\n- natural language processing - NLP\n- 对话系统\n- 图灵测试\n- ChatGPT 在接收到用户的提问输入后，输出的文字并不是一口气直接生成的，而是一个字、一个字生成的，这种逐字生成，即生成式（Generative） \n- 基于规则的 NLP - 符号主义\n- 基于统计的 NLP - 连接主义（利用机器学习算法从大量的语料库中学习自然语言的规律特征）标注数据 => 建立模型、确定输入输出 => 训练模型 => 利用已训练好的模型进行工作（在 ChatGPT 中，主要采用预训练（ Pre-training ） 技术来完成基于统计的 NLP 模型学习。最早，NLP 领域的预训练是由 ELMO 模型（Embedding from Language Models）首次引进的，后续 ChatGPT 等各种深度神经网络模型广泛采用了这种方式。）（黑盒不确定性，即规则是隐形的，暗含在参数中）（基于统计的方式能够让模型以最大自由度去拟合训练数据集）\n- 基于强化学习的 NLP（ChatGPT 模型是基于统计的，然而它又利用了新的方法，带人工反馈的强化学习（Reinforcement Learning with Human Feedback，RLHF） ）（强化学习就是赋予模型更大的自由度，让模型能够自主学习，突破既定的数据集限制）\n\n#### Transformer 的核心是自注意力机制（Self-Attention）\n- 自注意力机制可以将输入序列中的每个位置都表示为一个向量，这些向量可以同时参与计算，从而实现高效的并行计算\n\n\n#### AI - document - search\n- aircodelab\n- documate(https://github.com/aircodelabs/documate)"},{"title":"执行器和执行容器","url":"/2023/04/27/执行器和执行容器/","content":"### 执行器\n- 执行器的概念也是一致的，将问题域隔离开来，使设计更加简单明了\n\n- Linux 进程是 Linux 操作系统中的主要执行器。另外，还有线程，虽然 Linux 中的线程与进程相比，由 Linux内核操作完全一样。\n```\n将一个独立的执行单元称为执行器\n以执行器的身份运行一个执行序列\n执行单元是在一个上下文中运行\n或者在一个环境下运行\n我们称执行环境为上下文\n```\n隔离运行的执行器拥有自带的内部数据，并通过一些预定的通道（套接字、 管道、文件、共享内存等）与其他执行器进行通信或对整体环境进行修改\n\n每种类型的执行器功能不同，运行成本不同，但都会消耗资源。所以，我们 应该合理的架构和使用它们，使整体性能更好。\n\n每个执行器都有一个生命周期，它总是由另一个执行器创建的。执行器的生 命周期应该正确管理，操作系统会为执行器分配一些资源，并在释放执行器 之前索回资源。\n\n\n\n执行器（Executor）在计算机科学领域通常是一个广义的概念，是指负责实现和执行计算任务的工具、算法或组件。简而言之，执行器负责对指定的代码或任务进行计算和运行。在不同的编程领域和场景中，执行器的概念和实现可能有所不同。下面列举了一些与执行器相关的概念和领域：\n\n1. 线程池和Executor框架 (Java)：在Java多线程编程中，Executor是一个接口，通常与线程池一起使用，负责控制和管理线程的调度、执行和生命周期。例如，Java标准库提供了ThreadPoolExecutor类，它实现了Executor接口，提供了线程访问、任务提交等功能，并为任务的执行提供了内部线程池。\n\n2. 异步编程 (例如Node.js)：在异步编程中，执行器可以指定回调函数、Promise和async/await异步技术中负责控制和并发执行异步任务的组件。\n\n3. 任务队列和事件循环：在事件驱动型应用中，执行器经常出现在任务队列和事件循环的情景下。它负责处理异步请求并执行回调。例如在JavaScript中，setTimeout、setInterval和Promise等异步API，都需要将回调函数放入任务队列，由事件循环中的执行器执行。\n\n4. 大数据处理：在大数据处理领域，比如Spark、Hadoop等分布式计算框架中，具有执行器的概念。执行器负责在集群中执行各种计算任务，并将结果返回给主节点或存储至分布式文件系统。\n\n5. GPU编程：在面向图形处理器（GPU）的编程中，执行器可以是负责在GPU上执行并行计算任务的一组线程。例如CUDA和OpenCL是两种常见的GPU编程模型，它们都有自己的执行器组件，控制任务在GPU上的分配和处理。\n\n每个执行器都有自己的特点和优势，取决于所处的领域和使用场景。在学术研究中，执行器通常涉及到调度算法、资源管理、并发控制、性能优化等诸多方面。\n\n### 执行容器\n执行容器（Execution Container）通常是指在计算机科学领域里的一种抽象概念，它代表一个可运行和管理处理任务的环境。这种环境可以为任务提供所需的资源、依赖管理和执行上下文。在不同的计算模型和技术领域中，执行容器可以有不同的体现形式和应用场景。\n\n\n1. **Java的Java EE容器**：在Java EE应用中，执行容器有两类，一种是Web容器，另一种是EJB容器。这些容器为Java EE应用提供了所需的运行时环境、资源管理和调度等功能，简化了开发过程，让开发者能够专注于业务逻辑的实现。\n\n2. **OSGI容器**：OSGI(Open Service Gateway Initiative)是一种模块化、动态部署和动态更新的Java应用框架。OSGI容器主要负责管理、部署、运行这些框架下的模块，它提供了一个具有运行时隔离、动态部署、资源调度等功能的环境。\n\n3. **Docker容器**：Docker容器是目前比较流行的一种轻量级虚拟化技术，它可以将应用及其依赖打包在一个独立的、可移植的、安全的运行环境下（也即执行容器）。Docker容器使用Linux内核的特性(例如CGroups和Namespaces)实现了对应用的隔离和资源限制，使得容器之间可以同时运行在同一台主机上，且具有较高的性能和隔离性。\n\n4. **Serverless执行环境**：Serverless是一种无服务器架构，用户无需直接管理服务器资源，而是将代码部署到执行容器（如AWS Lambda、Azure Function等）。这些容器按需分配资源，可自动扩展，并根据实际执行时间计费。这大大简化了基础设施的管理，并允许资源更加灵活地响应业务需求。\n\n总的来说，执行容器这一概念在计算机科学领域具有广泛的应用，它主要通过为任务提供一个可控的、隔离的和可扩展的执行环境来简化开发和运维复杂性、优化资源利用率和提高软件灵活性。不同类型的执行容器有不同的特性和优势，需要根据具体的应用场景和需求来选择和使用。\n\n#### 常见执行容器\n- 服务\n- 服务器和云实例\n- 进程（一般来说，只有 CPU开销大的计算才能通过多进程来加速。）\n- 线程（众所周知，用线程和锁来编写和调试高性能的并发程序是非常困难 的。我们必须处理死锁、数据竞争等问题。一些现代编程语言甚至没 有用户态线程的概念，比如 Node.js或PHP）\n- 协程（coroutine是指在一个进程中创建的用户空间轻量级线 程。每个 coroutine都可以以协作的方式地将执行权交给其他 coroutine）\n#### 抢占调度多任务和协同调度多任务\n协同调度是coroutine的多任务调度所采用的思想。它解决了一个非常简单 的问题，允许多个正在一起工作的任务共享CPU。每个coroutine通过显 式调用函数yield()主动释放CPU给其他任务。被释放的coroutine可以通 过调用函数resume()来请求CPU。 协同调度的成本更低，更容易实现或使 用。协同调度的最佳用例是单用户和单供应商系统，比如如小型物联网设 备。\n如果一个任务忙于运行而 没有调用yield()函数，其他的coroutine可能会被挂起而无法执行\n抢占调度是现代操作系统所使用的调度方法，它解决了一个非常复杂的问 题，就是让所有的任务有效地共享CPU资源。每一个任务在经过一段时间 或CPU周期后，都会获得使用CPU的机会。由于系统越来越复杂，大多数 现代设备和OS 都有抢占调度的功能\n\n#### 通信和状态同步\n当我们抽象出一个执行器或者执行容器的时候，我们面临的是类似的输入、 输出和任务执行等问题\n我们要解决的两大问题非常简单。I/O和 CPU。通常我们可以预期 I/O是慢 的，CPU是快的。通信成本总是高于执行实际任务的成本\n\n\n### 生命周期 \n某些元素的生命周期是由操作系统或运行时管理的。例如，我们不 必释放一个进程被杀死的内存；我们不必释放一个局部变量的内存。\n管理资源的时候，我们要考虑 到资源的生命周期\n"},{"title":"node-cli-模式","url":"/2023/04/27/node-cli-模式/","content":"\nNode.js CLI (命令行界面) 相关的项目主要包括创建命令行工具、编写CLI脚本，以及提供执行Node.js脚本所需要的依赖库等。以下是一些常见的Node.js CLI相关项目：\n\n1. Commander.js\nCommander.js 是一个流行的Node.js CLI库，用于创建命令行应用程序。它提供了一种简单的方法来定义命令、选项和参数，使你能够快速开发复杂的命令行工具。\nGitHub: https://github.com/tj/commander.js\n\n2. Inquirer.js\nInquirer.js 为命令行应用提供了一个用户友好的交互提示功能。\nGitHub: https://github.com/SBoudrias/Inquirer.js\n\n3. Yargs\nYargs 是一个功能强大的命令行参数解析库，它可以使你更容易地创建具有复杂数字参数的Node.js CLI应用程序。\nGitHub: https://github.com/yargs/yargs\n\n4. Chalk\nChalk 是一个流行的颜色输出库，用于在控制台输出带颜色的文本。它可以帮助开发人员创建美观、易于阅读的日志输出和错误消息。\nGitHub: https://github.com/chalk/chalk\n\n5. Ora\nOra 是一个简单的终端旋转器，用于显示命令行程序中的异步进度。它提供了一个简单的方法来在UI中显示和更新任务状态。\n\n6. ShellJS\nShellJS 是一个用于在Node.js脚本中执行Unix shell命令的库。它可以帮助开发人员编写跨平台兼容的CLI应用程序。\nGitHub: https://github.com/shelljs/shelljs\n\n7. Cli-table3\nCli-table3 是一个用于创建和管理控制台表格的库。它让你能够以优雅的方式向用户展示数据。\nGitHub: https://github.com/cli-table/cli-table3\n\n这些项目只是Node.js CLI生态系统中的一部分，根据你的需求和项目目标，你还可以找到其它相关开源项目，来帮助你构建健壮、易用的命令行工具。\n\n\n```\nCoroutine（协程）是一种编程技术，用于更有效地处理并发问题。协程允许程序在异步操作（比如I/O操作）上挂起与恢复执行，从而在等待一个异步操作完成的过程中避免阻塞调用线程。换句话说，协程允许程序继续在一个线程中执行其他任务，从而提高了系统的整体吞吐量。\n\n与传统的多线程编程相比，使用协程有以下优势：\n\n更简单的代码结构：协程可以让你编写看起来像同步代码的异步程序。这有助于简化代码逻辑，降低了程序的复杂性。\n更高的性能：相较于线程，协程使用较少的系统资源，如内存和CPU时间。这使得协程在高并发场景下表现出更好的性能。\n更好的资源管理：协程通常只在需要时被创建，并且在执行完任务后销毁。这让程序更好地管理系统资源，减小资源耗尽的风险。\n更易于解决传统并发问题：协程通常会比多线程模型更容易解决锁和竞争条件等传统并发问题。\n要实现协程，可以使用支持协程的编程语言（如Python、JavaScript、Kotlin、Go等），或者使用特定的协程库（如Python的asyncio）。\n\n协程的运作流程通常如下：\n\n一个函数通过协程关键字（如Python中的async）声明为异步函数。\n当需要等待一个异步操作完成（如I/O操作），在该异步函数中使用特定的关键字（如Python中的await）表示挂起操作。\n调度器调度其他任务，异步操作被挂起并等待完成。\n异步操作完成后，挂起的协程恢复执行。\n总之，协程是一种处理并发问题的思路，通过简化代码结构、提高性能和优化资源管理来优化系统。\n```"},{"title":"服务基础-性能和并发","url":"/2023/04/27/服务基础-性能和并发/","content":"- 同步过程\n- 异步过程\n\n- 客户端 I/O和 Linux进程解耦\n- 解耦客户端I/O和Linux进程意味着让这两个过程能够相互独立运行和扩展，不会相互依赖或阻塞彼此的执行。这种解耦可以提高系统的可伸缩性、稳定性和可维护性。\n```\nAWS Lambda\n```\n\n### 快速组件和慢速组件\n在实践世界中，并发问题来自于一个应用或系统的每个组件运行速度不一样：内存访问快，磁盘访问慢，本地网络快，远程网络慢，CPU快，但 I/O 慢\n\n在一个系统中，我们经常会遇到慢速组件和快速组件，例如数据库、文件系统、缓存、网络API等。理解两者之间的关系以及如何处理并发问题，在优化系统性能和可扩展性方面起着重要作用。\n\n并发问题：并发是指在一个时间段内，独立执行多个任务的过程。在一个多线程或异步环境下，并发问题通常会涉及资源共享、任务调度和优先级等的处理。为了防止资源争用（是单个资源在同一时间由多个任务使用造成的问题），文件损坏和性能瓶颈，需要为系统设计合适的并发策略。\n\n快速组件：快速组件相对便捷地完成其工作，通常是基于内存的操作，如缓存（如Redis）或提供快速服务的API。这些组件响应速度快，具有低延时，因此在处理并发任务时，通常不会成为性能瓶颈。\n\n慢速组件：相比之下，慢速组件较为缓慢地执行任务，如磁盘I/O操作（如文件系统和数据库操作）和缓慢的网络服务等。这类组件的响应速度相对较慢，可能会在高并发场景下出现性能瓶颈。\n\n快速组件与慢速组件之间的关系：在整个系统中，快速组件和慢速组件需要协同工作。一个请求可能需要从快速组件（如缓存）获取数据，然后从慢速组件（如数据库）获取更多数据。为了确保性能和可扩展性，系统设计者需要确定这些组件如何协同工作。\n\n解决并发问题的策略：\n\n1. 避免不必要的全局锁，锁会限制资源，降低系统性能。尽量采用异步I/O，避免阻止事件循环。\n\n2. 在构建仅依赖快速组件的服务时，请确保足够的资源应对高并发的请求。\n\n3. 选择适当的空间复杂度和时间复杂度算法，以及数据结构以优化对快速和慢速组件的使用。\n\n4. 使用缓存和消息队列等技术来缓解慢速组件的性能瓶颈。\n\n5. 在代码层面上控制并发，使用连接池来复用数据库连接。\n\n6. 实现负载均衡、分片等方案以分散资源压力。\n\nhttps://research.google/people/jeff/\n\n### 并发模型\n- 在不太降低性能或不占用太多资源的情况下线性扩展并发量\n- 如何保持状态的同步。\n- https://unixism.net/2019/04/\n- https://unixism.net/2019/04/linux-applications-performance-introduction/\n- 并发模型有 fork、prefork、线程、线程池、 poll、epoll\n\n### 并发编程模型\nErlang中的 Actors模型\nGolang中的 Communicating Sequential Processes (CSP)\nClojure 中的 So Transactional Memory (STM)\nRuby 3 中的 Guilds\n\n\nActors 和 CSP  - 不通过共享内存进行通信，而是通过通信共享内存\nActors 和 CSP 有一些区别：CSP 中的进程是匿名的，而 actors 是有标识 的；CSP中的 Channel是有标识的，但在 actors的系统中没有标识； actors 也可以异步发送数据，但 CSP 中的进程却不能。\n\nSTM - 使用共享内存但不使用锁的模型"},{"title":"ios-Frameworks-summary","url":"/2023/04/18/ios-Frameworks-summary/","content":"- framework是一个有层级的目录\n- 讲动态代码库，nib  files, 图片文件，头文件和参考文件全部封装成一个单一的资源包\n- 对于Xcode, framework是一个文件后缀为.framework的文件包\n\n### ios 系统框架\nUIKit：UIKit是iOS开发中最重要的框架之一，它为应用程序提供了各种用户界面元素和控件，如标签、按钮和文本字段等。\n\nFoundation：Foundation框架提供了许多基本的数据类型和工具，如字符串、日期和网络通信等，用于处理iOS应用程序的核心功能。\n\nCore Data：Core Data是一个对象关系映射框架，用于管理应用程序的数据模型，并提供对持久化储存的支持。\n\nCore Animation：Core Animation是一个强大的动画框架，可用于创建流畅的界面过渡和动画效果。\n\nCore Location：Core Location提供了访问iOS设备位置信息的API，可以用于创建地图、导航和其他位置相关应用程序。\n\nMetal：Metal框架是一个高性能的图形渲染框架，用于创建游戏和其他图形密集型应用程序。\n\nAVFoundation：AVFoundation框架提供了音频和视频处理的API，可用于创建多媒体应用程序和游戏。\n\n### 系统框架分层\niOS系统框架可以分为四个层次，从最底层到最顶层依次是：\n\n#### Core OS层：\nCore OS层提供了操作系统的核心功能，包括内存管理、文件系统、安全和网络等。\n\n#### Core Services层：\nCore Services层构建在Core OS层之上，提供了更高级别的系统服务，如网络通信、数据管理、XML解析和位置服务等。\n\n#### Media层：\nMedia层提供了音频、视频和图形处理功能，包括相机、媒体播放器和基于OpenGL ES的图形渲染引擎等。\n\n#### Cocoa Touch层：\nCocoa Touch层是iOS应用程序开发的核心，提供了用户界面元素、多点触摸手势、加速计和硬件访问等API，以及其他框架如Core Data和Core Animation等。"},{"title":"OC-summary","url":"/2023/04/17/OC-summary/","content":"### 介面与实现 - 编写\n#### 类的介面 - interface\n- 只有声明，没有实现\n- 可以声明：属性，变量，方法\n\n#### 类的实现 - implementation\n- 需要实现介面声明的方法\n- 可添加介面没有的：变量，方法（私有）\n\n- 在 TypeScript 中，类定义是使用关键字 class 来声明的，而不是 Objective-C 中的 @interface 或 @implementation。\n\n#### .h\n- 可被.h/.m引入\n- @interface可写在.h/.m\n#### .m\n- 不可被引入\n- @implementation可写在.m\n\n### 对象与构造函数\n- 创建对象\n- override父类的构造函数\n- 声明，实现带参数的构造函数\n\n### 函数方法\n- 声明\n- 实现\n- 方法调用 - 实例方法，静态方法\n\n### 成员变量\n- interface变量\n- implementation 变量\n- 外部透过对象访问公开成员变量\n- 内部可以访问公开和私有成员变量\n\n### 访问变量\n- 公开Get/Set方法\n- _私有变量\n\n### @property属性\n- 属性特性\n\n### 协议 @protocol\n- 语法\n\n### 动态增删改方法 -> runtime, oc黑魔法"},{"title":"Xcode工程-summary","url":"/2023/04/17/Xcode工程-summary/","content":"Workspace\nProject\nTarget\nProduct\nScheme \n- http://chuquan.me/2021/12/03/understand-concepts-in-xcode/\n- https://juejin.cn/post/7115664639181979655\n\n\nXcodeproj\n\n### 搜索\n#### 文件搜索\n按下快捷键 Command + Shift + O（字母 O），这将激活快速打开功能。\n在快速打开对话框中，输入你想要搜索的文件名或关键字。搜索结果会实时显示，你可以在这个列表中找到你需要的文件。\n#### 内容搜索\ncmd+shift+F 就是全局搜索"},{"title":"WWDC-summary","url":"/2023/04/17/WWDC-summary/","content":"### IOS && ipadOS\n\n\n\n### CoreML AR"},{"title":"AOSP-厂商定制系统","url":"/2023/04/13/AOSP-厂商定制系统/","content":"- https://source.android.com/"},{"title":"node-util-summary","url":"/2023/04/13/node-util-summary/","content":"- https://nodejs.cn/api/util.html\n> node:util 模块支持 Node.js 内部 API 的需求。 许多实用工具对应用程序和模块开发者也很有用"},{"title":"CEF-summary","url":"/2023/04/13/CEF-summary/"},{"title":"ios-工程化相关","url":"/2023/04/12/ios-工程化相关/","content":"\n\n\n\n### ad-hoc-distribution\n- 跟着下面这个走，比较新的xcode\n- https://dev.to/gualtierofr/ad-hoc-distribution-for-ios-1524\n\n\n## 适用于 iOS 视图调试的免费开源 macOS 应用程序\nhttps://github.com/hughkli/Lookin/\nhttps://lookin.work/\n- 依赖项目（https://qxh1ndiez2w.feishu.cn/docx/YIFjdE4gIolp3hxn1tGckiBxnWf）\n```\nReactiveObjC\n- https://github.com/ReactiveCocoa/ReactiveObjC\nUsed for asynchronous programming.\nPeertalk\n- https://github.com/rsms/peertalk\nUsed for data communication between iOS and macOS.\nSparkle\n- https://sparkle-project.org/\nUsed for software updates.\nMicrosoft AppCenter\n- https://appcenter.ms/\nUsed for reporting crashes and relevant user data.\n```"},{"title":"auth相关","url":"/2023/03/23/auth相关/","content":"APP_TOKEN_CACHE_KEY 是一个常量值，通常在开发移动应用时使用。它表示在客户端（如 Android 或 iOS 应用）中缓存应用程序的访问令牌（Access Token）所使用的键名。\n\nAccess Token 是一种用于授权访问受保护资源的凭证，通常在 OAuth 2.0 认证流程中使用。为了避免频繁地从授权服务器（如 Auth0、Okta 等）请求新的 Access Token，我们通常会在客户端中将其缓存起来，并在需要时直接使用缓存中的值\n\n## OAuth\n- 2007 年 OAuth 1.0 面世\n- 2011 OAuth 2.0 草案\n\n\n#### reference\n- OAuth2协议规范\n- OpenID Connect explained\n\n#### Lucia\n- https://github.com/lucia-auth/lucia\n\n\n### 微信登录\n- code只有一次有效。无论调用成功与否，只要发起httprequest，这个code就被消费掉了。需要重新获取code。\n- 是的，微信官方的登录凭证（code）是唯一的，每次用户在微信登录后服务器都会返回一个新的code。这是为了保证每次用户操作的安全性和唯一性。所以理论上来说，每一个code只能使用一次，使用后就会失效。\n\n这正体现了幂等性的原理，即不论操作执行一次还是多次，效果都是一样的。也就是说，无论一个code使用多少次，结果都是一致的，这个结果就是该code失效。\n\n这样既保证了用户信息的安全，也提高了系统的效率，因为系统只需要处理一次操作，而不是处理多次相同的操作。"},{"title":"抓包-wireshark-tcpdump","url":"/2023/03/17/抓包-wireshark-tcpdump/","content":"`ip a`\n`tcpdump -i lo -w fortest.cap`\n- \"ip a\" 命令用于显示系统中所有网络接口的详细信息，包括它们的 IP 地址、MAC 地址、状态等\n- 在本地回环接口（loopback interface）上抓取网络流量，然后将抓包结果保存到名为 fortest.cap 的文件中\n- 在终端窗口中按下 Ctrl + C 组合键即可停止 tcpdump 的运行\n\n"},{"title":"nestjs-summary","url":"/2023/03/10/nestjs-summary/","content":"\n### github\n- 代码拉下来，node 14.X的才能正常install,默认lock文件不ignore(Fix the upstream dependency conflict, or retry\nnpm ERR! this command with --force or --legacy-peer-deps\nnpm ERR! to accept an incorrect (and potentially broken) dependency resolution.)\n-  \"engines\": {\n    \"node\": \">= 16\"\n  },\n- 当您使用 npm v7 及更高版本时，默认情况下，peer 依赖项将自动安装，并在遇到冲突时中止安装并报错。这是为了确保所有依赖项与其 peer 依赖项完全兼容，避免后续的问题\n\n### publish\n- 较为完备的多packages的publish脚本\n### doc\n- https://docs.nestjs.cn/\n\n#### @nestjs/cli\nnew | generate\n\nmonorepo | multirepo\n\n## 内置框架选择\n- fastify - 基准测试 - 性能 - like QPS\n- \n\n### 能力\n\n- IOC：自己实现了模块机制，可以导入导出 provider，实现自动依赖注入，简化了对象的创建\n- AOP：抽象了 Guard、Interceptor、Pipe、Exception Filter 这 4 种切面，可以通过切面抽离一些通用逻辑，然后动态添加到某个流程中\n- 任意切换底层平台：nest 基于 ts 的 interface 实现了不和任何底层平台耦合，http 可以切换 express 和 fastify，websocket 可以切换 socket.io 和 ws。而且 4 种切面也实现了可以跨 http、websocket、微服务来复用。\n\n\n### github - examples\n- https://github.com/Ignition-Space/fast-gateway/\n- https://wanago.io/\n- https://github.com/hantsy/nestjs-rest-sample\n\n### 全局模块\n- 模块可以通过 @Global 声明为全局的，这样它 exports 的 provider 就可以在各处使用了，不需要 imports。\n\n\n### 生命周期\n\nprovider、controller、module 都支持启动和销毁的生命周期函数，这些生命周期函数都支持 async 的方式。\n\n可以在其中做一些初始化、销毁的逻辑，比如 onApplicationShutwon 里通过 moduleRef.get 取出一些 provider，执行关闭连接等销毁逻辑。\n\n全局模块、生命周期、moduleRef 都是 Nest 很常用的功能。"},{"title":"react-router-summary","url":"/2023/03/10/react-router-summary/"},{"title":"react-context","url":"/2023/03/08/react-context/","content":"#### composition vs inheritance\n- https://reactjs.org/docs/composition-vs-inheritance.html#gatsby-focus-wrapper\n\n#### context\nhttps://zh-hans.reactjs.org/docs/context.html#gatsby-focus-wrapper\n\n#### 16.3之后和之前的API\n- https://zh-hans.reactjs.org/docs/legacy-context.html"},{"title":"react-ref","url":"/2023/03/06/react-ref/","content":"## Ref对象创建\n#### 类组件React.createRef\n- react/src/ReactCreateRef.js\n- 类组件有instance 能够维护像 ref 这种信息\n#### 函数组件 useRef\n- useRef 产生的 ref 对象挂到函数组件对应的 fiber 上，函数组件每次执行，只要组件不被销毁，函数组件对应的 fiber 对象一直存在，所以 ref 等信息就会被保存下来\n\n## React本身对Ref的处理\n> React对Ref属性的处理 - 标记ref\n\n#### 类组件获取Ref的三种方式\n- Ref属性是一个字符串\n- Ref属性是一个函数\n- Ref属性是一个ref对象\n\n## ref高阶用法\n#### forwardRef\n- 解决ref不能跨层级捕获和传递的问题\n- forwardRef接受父级元素标记的ref信息，并把它转发下去，使子组件可以通过props来接受到上面层级的ref\n```\n- 跨层级获取\n- 合并转发ref\nforwardRef 让 ref 可以通过 props 传递\n如果用 ref 对象标记的 ref ，那么 ref 对象可以通过 props 的形式，提供给子孙组件消费\n子孙组件也可以改变 ref 对象里面的属性\n绑定在 ref 对象上的属性，不限于组件实例或者 DOM 元素，也可以是属性值或方法\n- 高阶组件转发 higer-order components\n```\n\n#### ref实现组件通信\n- 数据层托管层组件 - antd -form\n```\n类组件ref\n函数组件forwardRef + useImperativeHandle\n函数组件缓存数据 - useRef(useRef 可以创建出一个 ref 原始对象，只要组件不销毁，ref 对象就一直存在，可以把不依赖于视图更新的数据储存到 ref 对象中)\n```\n\n#### ref原理\n- commitDetachRef\n- commitAttachRef\n- safelyDetachRef\n- safelyAttachRef\n- 如果是字符串 ref=\"node\" 或是 函数式 ref={(node)=> this.node = node } 会执行 ref 函数，重置新的 ref \n- react-reconciler/src/ReactChildFiber.js\n- react-reconciler/src/ReactFiberCommitWork.js\n"},{"title":"react-lifecycle","url":"/2023/03/06/react-lifecycle/","content":"> React 类组件 - 生命周期钩子函数\n\n## React 阶段\n- React 在调和( render )阶段会深度遍历 React fiber 树 -> 发现不同( diff )，不同的地方就是接下来需要更新的地方，对于变化的组件，就会执行 render 函数\n- 在一次调和过程完毕之后，就到了commit 阶段，commit 阶段会创建修改真实的 DOM 节点\n- 调和的过程中，发现了一个 fiber tag = 1 类组件的情况，就会按照类组件的逻辑来处\n- react-reconciler/src/ReactFiberBeginWork.js\n- 组件初始化 ｜ 组件更新 ｜ 组件销毁\n### 初始化阶段\n#### render阶段\n- constructor（constructClassInstance，mountClassInstance） ｜ getDerivedStateFromProps | componentWillMount | render\n\n#### commit阶段(before mutation | mutation | layout)\n- 更新DOM ｜ componentDidMount（react-reconciler/src/ReactFiberCommitWork.js）\n\n### 更新阶段\n- componentWillReceiveProps ｜ getDerivedStateFromProps ｜ shouldComponentUpdate ｜ componentWillUpdate ｜ getSnapshotBeforeUpdate ｜ componentDidUpdate\n\n### 销毁阶段\n- componentWillUnmount\n\n## 具体API\n#### constructor\n- 在类组件创建实例时调用\n- 初始化state ｜ 对类组件的事件做处理（绑定this，节流，防抖）\n- 生命周期劫持，渲染劫持（HOC）\n\n#### getDerivedStateFromProps\n- getDerivedStateFromProps(nextProps,prevState)\n- 在初始化和更新阶段，接受父组件的 props 数据， 可以对 props 进行格式化，过滤等操作，返回值将作为新的 state 合并到 state 中，供给视图渲染层消费\n- componentWillMount 和 componentWillReceiveProps  替代\n\n#### unsafe\n- React V16.3 componentWillMount ，componentWillReceiveProps ， componentWillUpdate\n- 在render之前执行\n- componentWillReceiveProps（一个思路 - 可以做一个状态提升，数据层托管父组件，子组件无副作用只负责渲染props）\n- PureComponent在 componentWillReceiveProps 执行之后浅比较 props 是否发生变化\n- getSnapshotBeforeUpdate 来代替 UNSAFE_componentWillUpdate\n\n#### render\n- 一次 render 的过程，就是创建 React.element 元素的过程\n- render -> createElement创建元素 , cloneElement 克隆元素 ，React.children 遍历 children 的操作\n\n\n#### getSnapshotBeforeUpdate\n- 在 commit 阶段的before Mutation ( DOM 修改前)\n- 配合componentDidUpdate 一起使用，计算形成一个 snapShot 传递给 componentDidUpdate ,保存一次更新前的信息\n\n#### componentDidUpdate\n- DOM 已经更新，可以直接获取 DOM 最新状态\n- 如果使用 setState ，一定要加以限制，否则会引起无限循环\n- 接受 getSnapshotBeforeUpdate 保存的快照信息\n\n\n#### componentDidMount\n- 做一些关于 DOM 操作，比如基于 DOM 的事件监听器\n- 初始化向服务器请求数据，渲染视图\n\n#### shouldComponentUpdate\n- 性能优化\n- 如果有 getDerivedStateFromProps 生命周期 ，它的返回值将合并到 newState ，供 shouldComponentUpdate 使用\n\n\n#### componentWillUnmount\n- 清除延时器，定时器\n- 一些基于 DOM 的操作，比如事件监听器\n\n## 函数组件\n\n### API\n#### useEffect\n- 异步调用 ，对于每一个 effect 的 callback， React 会放入任务队列，等到主线程任务完成，DOM 更新，js 执行完成，视图绘制完毕，才执行\n- effect 回调函数不会阻塞浏览器绘制视图\n\n\n#### useLayoutEffect\n- 同步执行\n- 在 DOM 更新之后，浏览器绘制之前\n- callback 中代码执行会阻塞浏览器绘制\n\n#### useInsertionEffect - v18\n- 解决 CSS-in-JS 在渲染中注入样式的性能问题\n\n\n## 对比\n\n### componentDidMount | useEffect\n```\nReact.useEffect(()=>{\n    /* 请求数据 ， 事件监听 ， 操纵dom */\n},[])  /* dep = [] */\n\n```\n\n### componentWillUnmount | useEffect\n```\n React.useEffect(()=>{\n        /* 请求数据 ， 事件监听 ， 操纵dom ， 增加定时器，延时器 */\n        return function componentWillUnmount(){\n            /* 解除事件监听器 ，清除定时器，延时器 */\n        }\n},[])/* dep = [] */\n```\n\n### componentWillReceiveProps\n```\nReact.useEffect(()=>{\n    console.log('props变化：componentWillReceiveProps')\n},[ props ])\nReact.useEffect(()=>{\n    console.log('props变化：componentWillReceiveProps')\n},[ props.abc ])\n```\n\n### componentDidUpdate - 同步执行，commit阶段\n```\n异步执行，commit阶段\nReact.useEffect(()=>{\n    console.log('组件更新完成：componentDidUpdate ')     \n}) /* 没有 dep 依赖项 */\n// 没有第二个参数，那么每一次执行函数组件，都会执行该 effect\n```"},{"title":"react-props","url":"/2023/03/06/react-props/","content":"> react中的props\n\n### React组件层级\n- 父组件把数据层传递给子组件渲染消费\n- 子组件通过props中的callback，向父组件传递信息\n- 将视图容器作为props进行渲染\n\n\n### React更新机制\n- props 可以作为组件是否更新的重要准则，变化即更新（ PureComponent ，memo ）\n\n### React插槽\n- React 可以把组件的闭合标签里的插槽，转化成 Children 属性\n\n\n### 监听props改变\n#### 类组件 - unsafe_componentWillReceiveProps\n```\nIf you define UNSAFE_componentWillReceiveProps, React will call it when the component receives new props. It only exists for historical reasons and should not be used in any new code. Instead, use one of the alternatives\n在16.3.0中被标记为unsafe\n在16.9.X中被废除，新增功能处理不要使用了\n因为这个生命周期超越了 React 的可控制的范围内，可能引起多次执行等情况发生\n每次父组件更新都会触发当前组件的componentWillRecieveProps\ngetDerivedStateFromProps - 组件一旦使用派生状态，很有可能因为没有明确的数据来源导致出现一些bug和不一致性，理解场景，正确使用\n官方根据不同使用场景，给出的替代方案（https://beta.reactjs.org/reference/react/Component#unsafe_componentwillreceiveprops）\n\nhttps://reactjs.org/docs/react-component.html#unsafe_componentwillreceiveprops\n```\n#### 函数组件 - useEffect\n\n\n### props children模式\n#### prop + child\n- props插槽组件 ｜ render props模式 ｜ 混合模式\n- react-router (Switch, Route) - The `<Routes>` component recurses through its `props.children`, strips their props, and generates an object like this\n- antd (Form , FormItem)\n\n### skills\n- 抽象props\n- 抽离props\n- 注入props\n- 隐式注入props"},{"title":"immutable-summary","url":"/2023/03/01/immutable-summary/","content":"> Dan Abramov : Only copy the parts that actually changed.Libraries like immutability-helper,updeep,immer help with this\n\n- immutable - 利用结构共享形成的持久化数据结构，一旦有部分被修改，那么将会返回一个全新的对象，并且原来相同的节点会直接共享\n\n- immutable 对象数据内部采用是多叉树的结构，凡是有节点被改变，那么它和与它相关的所有上级节点都更新\n\n## immutable\n### fromJS\n### toJS\n- 需要让immutable对象调用\n\n\n## 结合Redux使用\n- https://immutable-js.com/\n- 官方文档\n- https://github.com/gajus/redux-immutable\n- 按usage操作即可"},{"title":"nextjs-core-summary","url":"/2023/02/24/nextjs-core-summary/","content":"### 服务器操作\n\n\n\n\n\n\n\n\n\n\n\n### vercel \n```\nvercel.json\n{\n  \"version\": 2,\n  \"builds\": [\n    {\n      \"src\": \"./index.js\",\n      \"use\": \"@vercel/node@2.5.10\"\n    }\n  ],\n  \"routes\": [\n    {\n      \"src\": \"/(.*)\",\n      \"dest\": \"/\"\n    }\n  ]\n}\n\n```"},{"title":"React-state","url":"/2023/02/20/React-state/","content":"#### React mode\n- legacy\n- blocking(concurrent的优雅降级和过渡版本)\n- concurrent\n\n> 下面的state，是基于legacy模式\n\n### 类组件中的state\n#### setState\n- `setState(updater[, callback])`\n- https://reactjs.org/docs/react-component.html#setstate\n- https://zh-hans.reactjs.org/docs/faq-state.html\n- render阶段render函数执行 - commit 阶段真实DOM替换 - setState回调函数执行cb\n#### 类组件限制state更新视图\n- pureComponent对state和props进行浅比较，如果没有发生变化，组件不更新\n```\n/**\n * Convenience component with default shallow equality check for sCU.\n */\nfunction PureComponent(props, context, updater) {\n  this.props = props;\n  this.context = context;\n  // If a component has string refs, we will assign a different object later.\n  this.refs = emptyObject;\n  this.updater = updater || ReactNoopUpdateQueue;\n}\n```\n- shouldComponentUpdate - 通过判断state变化来决定组件是否更新\n- enqueueSetState(类组件初始化过程中绑定了负责更新的Updater对象，调用 setState 方法，实际上是 React 底层调用 Updater 对象上的 enqueueSetState 方法)\n```\n/react-reconciler/src/ReactFiberClassComponent.js\nreact-dom/src/events/DOMLegacyEventPluginSystem.js\n```\n- React同一级别setState 更新优先级： flushSync > 正常执行上下文 > setTimeout > Promise\n### 函数组件中的state\n\n在 useState 的 dispatchAction 处理逻辑中，会浅比较两次 state ，发现 state 相同，不会开启更新调度任务；\n- 如果直接改变state，在内存中指向的地址相同（state.name = 'b'）\n\n\n\n### useState - 原理"},{"title":"React-Component","url":"/2023/02/17/React-Component/","content":"\n## 类组件\n#### 类组件底层只需实例化一次，实例中保存了组件的state等状态，更新只要调用render方法和对应的生命周期即可\n\n#### react-reconciler/src/ReactFiberClassComponent.js\n- constructClassInstance\n```\nexport {\n  adoptClassInstance,\n  constructClassInstance,\n  mountClassInstance,\n  resumeMountClassInstance,\n  updateClassInstance,\n};\n```\n\n#### \n在 class 组件中，除了继承 React.Component ，底层还加入了 updater 对象，组件中调用的 setState 和 forceUpdate 本质上是调用了 updater 对象上的 enqueueSetState 和 enqueueForceUpdate 方法\n\n- react/src/ReactBaseClasses.js\n\n\n\n## 函数组件\n#### 函数组件中，每次更新是新的函数执行，里面的变量会重新声明\n\n#### react-reconciler/src/ReactFiberHooks.js\n```\nexport function renderWithHooks<Props, SecondArg>\n```\n\n\n### references\n#### getderivedstatefromprops\nhttps://zh-hans.reactjs.org/docs/react-component.html#static-getderivedstatefromprops\n\n#### fiber tag\nreact-reconciler/src/ReactFiber.js\nreact-reconciler/src/ReactWorkTags.js\n```\nexport const FunctionComponent = 0;\nexport const ClassComponent = 1;\n```\n\n\n### 组件通信方式\n- props callback - 父组件通过props将信息传递给子组件，子组件可以通过执行props中的回调函数callback来触发父组件的方法\n- ref\n- react-redux | react-mobx 等状态管理工具\n- context 上下文\n- @event bus -> 适合用React做基础构建的小程序 - Taro\n```\n问题：\n- 需要手动绑定和解绑\n- 后期难以维护，组件之间状态未知\n- 违背了React数据的流向的大原则\n```\n\n### 组件的强化方式\n#### 类组件继承\n- state和声明周期会被继承后的组件修改\n\n#### 函数组件自定义hooks\n\n#### HOC高阶组件\n\n\n\n\n### reconciliation\n- React渲染机制 - reconciliation过程\n- props或state改变 - render函数返回不同的元素树 - 新旧DOM树diff - 针对差异的地方进行更新 - 渲染为真实的DOM树\n- shouldComponentUpadate - 合理利用 - 避免不必要的reconciliation过程 - 类组件！- PureComponent - （props或state改变时进行浅层比较）\n- memo - 函数组件 - 只进行了props的浅比较\n\n\n### diff（不同React版本，也是持续优化中）\n- 永远只比较同层节点 ｜ 不同的两个节点产生不同的树 ｜ 通过key值指定哪些元素是相同的 - O(n)\n- 执行的具体流程（元素类型是否相同）\n- 遍历子节点列表的情况（子节点是否有key）\n- 选择key值策略 - 不需要全局统一，但必须列表\n\n\n## HOC - 高阶组件\n\n### Why\n> 解决大量的代码复用，逻辑复用问题\n\n#### 拦截问题\n- 对渲染的控制(例如权限控制是否渲染)\n- dva - dynamic - 懒加载/动态加载组件\n\n#### props中混入需要的\n- withRoute  - HOC 把改变路由的 history 对象混入 props 中\n\n#### 监控组件的内部状态，赋能组件\n- 监控组件内的事件\n- 增加额外生命周期\n\n### what\n#### 基本概念\n- 高阶组件是以组件作为参数，返回组件的函数。返回的组件把传进去的组件进行功能强化\n\n#### 属性代理\n- 用组件包裹一层代理组件，在代理组件上，可以做一些，对源组件的强化操作\n- 返回的是一个新组件，被包裹的原始组件，将在新的组件里被挂载\n\n\n#### 反向继承\n- 包装后的组件继承了原始组件本身，所以无须再去挂载业务组件\n\n### how\n#### 强化props\n\n\n#### 控制渲染\n- 渲染劫持 - HOC 反向继承模式，可以通过 super.render() 得到 render 之后的内容，利用这一点，可以做渲染劫持 ，还可以修改 render 之后的 React element 对象\n#### 动态加载 \n- dva 中 dynamic 就是配合 import ，实现组件的动态加载的，而且每次切换路由，都会有 Loading 效果\n#### 组件赋能\n- ref获取实例\n- 事件监控\n\n### tips\n- 谨慎修改原型链\n- 不要在函数组件内部&&类组件render函数中使用\n- 多个HOC嵌套，应该留意一下HOC的顺序，还要分析出要各个 HOC 之间是否有依赖关系\n- 类组件，可以用装饰器模式，对类组件进行包装\n- 属性代理 HOC 本质上返回了一个新的 component ，那么如果给原来的 component 绑定一些静态属性方法，如果不处理，新的 component 上就会丢失这些静态属性方法 - （手动继承 or hoist-non-react-statics）\n\n### cases\n- 管理后台，权限隔离"},{"title":"oceanbase-summary","url":"/2023/02/17/oceanbase-summary/","content":"> OceanBase is an enterprise distributed relational database with high availability, high performance, horizontal scalability, and compatibility with SQL standards.\n"},{"title":"JSX深入理解","url":"/2023/02/16/JSX深入理解/","content":"#### search\n- 在https://reactjs.org/docs/getting-started.html，搜索JSX\n```\n- 高级指引\n  - 不使用JSX的React - 每个 JSX 元素只是调用 React.createElement(component, props, ...children) 的语法糖。因此，使用 JSX 可以完成的任何事情都可以通过纯 JavaScript 完成。\n  - 深入JSX - https://zh-hans.reactjs.org/docs/jsx-in-depth.html#gatsby-focus-wrapper\n- 核心概念\n  - JSX简介 - https://zh-hans.reactjs.org/docs/introducing-jsx.html - why & how\n- FAQ\n  - Babel、JSX及构建过程 - https://zh-hans.reactjs.org/docs/faq-build.html\n- API Reference\n  - React术语词汇表 - JSX\n\n```\n- 在https://beta.reactjs.org/，搜索JSX\n  - Writing Markup with JSX\n  - JavaScript in JSX with Curly Braces\n\n\n#### 老版本的React中，写JSX文件，默认引入React\n- jsx被babel编译后，React.createElement，所以需要引入React，防止找不到React报错\n\n\n### Fiber\n- https://github.com/acdlite/react-fiber-architecture\n- Fiber is the new reconciliation engine in React 16. Its main goal is to enable incremental rendering of the virtual DOM.\n- 在调和阶段，React element 对象的每一个子节点都会形成一个与之对应的fiber对象，然后通过sibling，return，child将每一个fiber对象联系起来\n\n```\nexport const FunctionComponent = 0;       // 函数组件\nexport const ClassComponent = 1;          // 类组件\nexport const IndeterminateComponent = 2;  // 初始化的时候不知道是函数组件还是类组件 \nexport const HostRoot = 3;                // Root Fiber 可以理解为根元素 ， 通过reactDom.render()产生的根元素\nexport const HostPortal = 4;              // 对应  ReactDOM.createPortal 产生的 Portal \nexport const HostComponent = 5;           // dom 元素 比如 <div>\nexport const HostText = 6;                // 文本节点\nexport const Fragment = 7;                // 对应 <React.Fragment> \nexport const Mode = 8;                    // 对应 <React.StrictMode>   \nexport const ContextConsumer = 9;         // 对应 <Context.Consumer>\nexport const ContextProvider = 10;        // 对应 <Context.Provider>\nexport const ForwardRef = 11;             // 对应 React.ForwardRef\nexport const Profiler = 12;               // 对应 <Profiler/ >\nexport const SuspenseComponent = 13;      // 对应 <Suspense>\nexport const MemoComponent = 14;          // 对应 React.memo 返回的组件\n```\n\n```\nchild： 一个由父级 fiber 指向子级 fiber 的指针。\nreturn：一个子级 fiber 指向父级 fiber 的指针。\nsibling: 一个 fiber 指向下一个兄弟 fiber 的指针。\n```\n\n```\n在 jsx 中写的 map 数组结构的子节点，外层会被加上 fragment \nmap 返回数组结构，作为 fragment 的子节点\n```\n\n\n### babel\nJSX 语法实现来源于这两个 babel 插件：\n\n@babel/plugin-syntax-jsx ： 使用这个插件，能够让 Babel 有效的解析 JSX 语法。\n@babel/plugin-transform-react-jsx ：这个插件内部调用了 @babel/plugin-syntax-jsx，可以把 React JSX 转化成 JS 能够识别的 createElement 格式。\n#### automatic Runtime\n- 新版本 React 已经不需要引入 createElement ，这种模式来源于 Automatic Runtime\n```\n\"presets\": [    \n    [\"@babel/preset-react\",{\n    \"runtime\": \"automatic\"\n    }]     \n],\n```\n#### Classic Runtime\n- 经典模式下，使用 JSX 的文件需要引入 React ，不然就会报错\n\n#### code\n- 可以调用babel API试试编译结果\n```\nconst fs = require('fs')\nconst babel = require(\"@babel/core\")\n\n/* 第一步：模拟读取文件内容。 */\nfs.readFile('./element.js',(e,data)=>{ \n    const code = data.toString('utf-8')\n    /* 第二步：转换 jsx 文件 */\n    const result = babel.transformSync(code, {\n        plugins: [\"@babel/plugin-transform-react-jsx\"],\n    });\n    /* 第三步：模拟重新写入内容。 */\n    fs.writeFile('./element.js',result.code,function(){})\n})\n\n```\n\n- The term \"JSX\" in React refers to \"JavaScript XML\". It's a syntax extension for JavaScript, used within React to represent HTML-like components. This combination of JavaScript and XML (HTML-like syntax) allows developers to create their own components or reuse components in a very readable and intuitive way."},{"title":"react-项目总结","url":"/2023/02/16/react-项目总结/","content":"#### why\n- 交互式UI-简单\n- 组件化\n- 跨平台\n\n#### history - feature\n`https://github.com/facebook/react/releases`\n- v16.0 - 2017.09 \n```\n重写Reconciler - 性能，Fiber - 性能 ，createPortal API - 让节点渲染到指定容器内，更好实现弹窗功能 ，componentDidCatch -> 划分了错误边界，捕获渲染中的异常\n```\n- v16.2\n```\nReact\nAdd Fragment as named export to React. (@clemmy in #10783) -> 解决数组元素问题\nSupport experimental Call/Return types in React.Children utilities. (@MatteoVH in #11422)\n\n```\n- v16.3\n```\nReact\nAdd a new officially supported context API. (@acdlite in #11818)\nAdd a new React.createRef() API as an ergonomic alternative to callback refs. (@trueadm in #12162)\nAdd a new React.forwardRef() API to let components forward their refs to a child. (@bvaughn in #12346)\nFix a false positive warning in IE11 when using React.Fragment. (@XaveScor in #11823)\nReplace React.unstable_AsyncComponent with React.unstable_AsyncMode. (@acdlite in #12117)\nImprove the error message when calling setState() on an unmounted component. (@sophiebits in #12347)\n```\n- v16.6\n```\nReact\nAdd React.memo() as an alternative to PureComponent for functions. (@acdlite in #13748) - 控制子组件的渲染\nAdd React.lazy() for code splitting components. (@acdlite in #13885) - 代码分割\nReact.StrictMode now warns about legacy context API. (@bvaughn in #13760)\nReact.StrictMode now warns about findDOMNode. (@sebmarkbage in #13841)\nRename unstable_AsyncMode to unstable_ConcurrentMode. (@trueadm in #13732)\nRename unstable_Placeholder to Suspense, and delayMs to maxDuration. (@gaearon in #13799 and @sebmarkbage in #13922)\nReact DOM\nAdd contextType as a more ergonomic way to subscribe to context from a class. (@bvaughn in #13728) - 方便类组件使用context\n```\n- v16.8 - Add Hooks — a way to use state and other React features without writing a class. (@acdlite et al. in #13968) - 使函数组件也能做类组件做的一切事儿\n- v17 - 2020.10 - 事件绑定（document -> container ）, 移除事件池\n`https://reactjs.org/blog/2020/10/20/react-v17.html`\n\n\n#### react-scripts\n- https://www.npmjs.com/package/react-scripts\n- @svgr/webpack\n```\nThis package includes scripts and configuration used by Create React App.\nPlease refer to its documentation:\n```\n\n#### better-scroll\n```\nBetterScroll 是一款重点解决移动端（已支持 PC）各种滚动场景需求的插件。它的核心是借鉴的 [iscroll](https://github.com/cubiq/iscroll) 的实现，它的 API 设计基本兼容 iscroll，在 iscroll 的基础上又扩展了一些 feature 以及做了一些性能优化。\n\nBetterScroll 是使用纯 JavaScript 实现的，这意味着它是无依赖的。\n```\n- https://github.com/ustbhuangyi/better-scroll\n\n\n#### react-lazyload\n\n#### react-flow\n- https://github.com/wbkd/react-flow\n- 高度可定制的库，用于构建基于节点的交互式用户界面、工作流程编辑器、流程图或静态图\n\n#### react-transition-group\n\n#### @emotion/react\nEmotion is a library designed for writing css styles with JavaScript. It provides powerful and predictable style composition in addition to a great developer experience with features such as source maps, labels, and testing utilities. Both string and object styles are supported.\n\n\n## 优化\n"},{"title":"TecentSOE-summary","url":"/2023/02/16/TecentSOE-summary/","content":"- https://aiedu.qcloud.com/soe/TencentSOE-0.1.4.js\n- 没有开源，或者提供开发版文件，只能引入后debug调试看处理逻辑\n\n\n### lame.all.js\n\nUncaught NetworkError: Failed to execute 'importScripts' on 'WorkerGlobalScope': The script at 'https://imgcache.qq.com/open/qcloud/soe/lame/lame.all.js' failed to load.\n\nLame.js 是 LAME 编码器的 JavaScript 版本。LAME 是一种广泛使用的 MP3 编码器。\nLame.js 可以把 WAV 音频转换为 MP3 格式。它能在浏览器环境运行，不需要安装任何插件\n在一些需要实现语音记录、音频处理的网页应用中，常常会使用到 Lame.js。它可以获取用户的音频输入，处理并编码成 MP3 格式，然后上传到服务器或者进行其他处理。\n\n```javascript\nvar mp3encoder = new lamejs.Mp3Encoder(1, 44100, 128);\nvar mp3Data = [];\n\nMixer.on('postSample', function(buffer) {\n  var mp3buf = mp3encoder.encodeBuffer(buffer);\n  if (mp3buf.length > 0) {\n    mp3Data.push(mp3buf);\n  }\n});\n\nMixer.on('mixFinished', function() {\n  var mp3buf = mp3encoder.flush();\n  if (mp3buf.length > 0) {\n    mp3Data.push(mp3buf);\n  }\n});\n```\n不过要注意，使用 Lame.js 需要遵循其相关的授权和使用条件，并且由于 LAME 编码器的特性，Lame.js 对浏览器的性能有一定的要求，可能不适合所有的环境和应用。\n\n- https://imgcache.qq.com/open/qcloud/soe/lame/lame.all.js\n\n\nimportScripts会阻塞worker，直到所有的脚本都加载完成\n如果load失败，主要原因是网络，会抛错，每日万次调用，个位数报错（1-2）\n\n\n### lame\n- https://sourceforge.net/projects/lame/\n- LAME is an educational tool to be used for learning about MP3 encoding. The goal of the LAME project is to improve the psycho acoustics, quality and speed of MP3 encoding. Note: we provide source code only!\n- LAME is a high quality MPEG Audio Layer III (MP3) encoder licensed under the LGPL.\n- https://lame.sourceforge.io/\n- 最新 LAME 版本：v3.100（2017 年 10 月）\n\n\n- Lamejs 是对 Jump3R-Code （是对libmp3lame 的重写）的重写\n- https://github.com/zhuker/lamejs\n\n\n Lamejs 是 LAME 项目（LAME Ain't an MP3 Encoder）的一种实现，此项目最初是用 C 语言编写的。Java 有一个开源库叫做 JLayer，它是 LAME 的 Java 实现（或者说，是 MPEG 1/2/2.5 audio Layer 1/2/3 的 Java 解码器）。\n\n ### github-https://github.com/zhuker/lamejs\n - 里面提供了Java对lame的实现版\n - worker-example提供了worker版的使用方式"},{"title":"异步I/O","url":"/2023/02/16/异步I-O/","content":"## 基本概念\n#### epoll\n- https://en.wikipedia.org/wiki/Epoll\n```\nepoll is a Linux kernel system call for a scalable I/O event notification mechanism, first introduced in version 2.5.44 of the Linux kernel.[1] Its function is to monitor multiple file descriptors to see whether I/O is possible on any of them. It is meant to replace the older POSIX select(2) and poll(2) system calls, to achieve better performance in more demanding applications, where the number of watched file descriptors is large (unlike the older system calls, which operate in O(n) time, epoll operates in O(1) time[2]).\n\nepoll is similar to FreeBSD's kqueue, in that it consists of a set of user-space functions, each taking a file descriptor argument denoting the configurable kernel object, against which they cooperatively operate. epoll uses a red–black tree (RB-tree) data structure to keep track of all file descriptors that are currently being monitored.[3]\n```\n\n#### 文件描述符\n\n#### POSIX\n- https://en.wikipedia.org/wiki/POSIX\n```\nThe Portable Operating System Interface (POSIX) is a family of standards specified by the IEEE Computer Society for maintaining compatibility between operating systems.[1] \n```\n\n\n\n\n\n\n## libuv\n"},{"title":"vitest-summary","url":"/2023/02/16/vitest-summary/","content":"- https://github.com/vitest-dev/vitest/blob/main/examples/vue/vitest.config.ts\n\n```\nimport { defineConfig } from 'vite'\nimport Vue from '@vitejs/plugin-vue'\n\nexport default defineConfig({\n  plugins: [\n    Vue(),\n  ],\n  test: {\n    globals: true,\n    environment: 'jsdom',\n  },\n})\n```\n处理需要操作DOM的环境\n\n- https://cn.vitest.dev/guide/"},{"title":"nodejs底层","url":"/2023/02/06/nodejs底层/","content":"- 之前博文链接 - Libuv-summary\n\n\n\n## http模块\n#### http协议\n- https://developer.mozilla.org/en-US/docs/Web/HTTP\n```\nHypertext Transfer Protocol (HTTP) is an application-layer protocol for transmitting hypermedia documents, such as HTML. \nIt was designed for communication between web browsers and web servers, but it can also be used for other purposes. \nHTTP follows a classical client-server model, with a client opening a connection to make a request, then waiting until it receives a response. \nHTTP is a stateless protocol, meaning that the server does not keep any data (state) between two requests.\n```\n- 总结下：\n- 应用层协议\n- 客户端-服务端模型\n- 无状态协议\n\n#### http解析器\n- https://github.com/nodejs/llhttp\n- 钩子函数\n- https://github.com/nodejs/llhttp/blob/main/src/native/api.h\n\n#### http服务器\n- 1.通过net模块启动一个TCP服务器\n- 2.通过llhttp来解析TCP服务器上收到的http数据\n\n- 管道化（1.0 2.0 3.0）- 在同一个TCP连接中并发发送多个请求，但是响应需要按需返回\n\n- Http Connect方法 - 通过connect让http代理服务器转发客户端的tcp流量到另一个真正的服务器中\n\n- 协议升级（WS）- 通过http协议协商升级到另一个通信协议，后续就可以使用新的协议进行通信了\n\n\n#### HTTP客户端\n- 请求Agent（对TCP连接进行了池化管理）（key的计算 + 创建一个socket， 使用连接池）\n\n\n## worker_threads 模块\n- 工作线程对于执行 CPU 密集型的 JavaScript 操作很有用。 它们对 I/O 密集型的工作帮助不大。 Node.js 内置的异步 I/O 操作比工作线程更高效。\n- http://nodejs.cn/api/worker_threads.html\n- vscode - \n\n\n## cases\n\n- V8 和 libuv 来实现一个 APM（应用性能监控）watchdog  -> 解决单线程限制。\n- 建立一个与 Node.js 主线程并行的 V8 工作线程。\n\n以下是一些步骤和建议来实现一种 APM watchdog：\n\n1. 使用 V8 的 Isolate::New 和 Locker 构造新的 Isolate，以提供一个可以在新线程中执行 JavaScript 的隔离环境。为 V8 工作线程创建一个新的 Isolate，并与 Node.js主线程进行隔离。\n2. 使用 V8 的 Platform::CallOnBackgroundThread 方法，使得 V8 可以将任务传送到后台线程运行，用于提供多线程的性能监控。\n3. 使用 libuv 中的 uv_loop_new 和 uv_async_send 方法，他们提供简化跨线程通信的能力。用 libuv 来创建一个事件循环，为事件驱动的异步调度提供支持。\n4. 设计一个来自于主线程的通知机制。当主线程发现超时或者其他错误发生时，向工作线程发送通知。\n5. 使用 V8 的 CPUProfiler API 来抓取 CPU profile，它可以在工作线程和主线程都使用。这将帮助查詢那些很可能会导致应用程序性能降低的代码片段。\n6. 设计策略以避免争用条件或数据不一致，并确保应用程序代码的线程安全。当涉及访问多线程共享资源时，请选择互斥锁，读写锁等同步原语。\n7. 在你需要的时候，定期启动或暂停 watchdog 线程以汇报其性能数据。可以通过 HTTP 服务暴露相应的性能数据。\n\n"},{"title":"vant-weapp-summary","url":"/2023/01/28/vant-weapp-summary/","content":"- 项目中用到了这个库\n- 团队内部小程序组件库构建参考这个改的\n- https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/"},{"title":"聊聊underscore","url":"/2023/01/28/聊聊underscore/","content":"- https://github.com/you-dont-need/You-Dont-Need-Lodash-Underscore\n- debounce"},{"title":"install-pkg-summary","url":"/2023/01/28/install-pkg-summary/","content":"- https://www.npmjs.com/package/@antfu/install-pkg"},{"title":"open-url-summary","url":"/2023/01/28/open-url-summary/","content":"- https://github.com/sindresorhus/open\n- Open stuff like URLs, files, executables. Cross-platform.\n- child_process"},{"title":"IOS-APP相关summary","url":"/2023/01/22/IOS-APP相关summary/","content":"## APP\n#### 展示界面\n- 底部TabBar\n- navigation导航\n- 列表\n- 图片imageview\n- button/label\n- textview\n- webview\n\n#### 动画\n\n#### 通用技术架构\n- 网络\n- 存储\n- 图片\n- 音频\n- 视频\n- 数据解析\n- 布局/渲染\n- 启动\n- 日志系统\n- 上报系统\n\n## tools\n#### xcode\nhttps://help.apple.com/xcode/mac/current\n\n## pre\n#### subModule\n- git\n- 使用简单｜功能少，只能下载全部项目\n- debug方便\n\n#### CocoaPods\n- ruby\n- 中心化管理，生产workspace\n- debug方便\n\n#### Carthage\n- swift\n- 去中心化的管理，提供framework文件\n- debug不便\n\n#### MVC in IOS\n- View - UIView\n- Controller - UIViewController\n\n#### UIView\n- 最基础的视图类\n- 管理屏幕上一定区域的内容展示\n- 作为各种视图类型的父类，提供基础的能力\n- 外观，渲染和动画\n- 相应区域内的事件\n- 布局（设置大小，位置frame ｜ addSubView）\n- 使用栈管理管理全部的子视图（位置重叠的展示最后入栈的｜可以随时调整位置｜插入到指定位置）\n\n#### UIViewController\n- 视图控制器，管理View层级结构\n- 自身包含View，可以理解为一个容器（管理View的生命周期，响应用户操作，和APP整体交互，视图的切换，作为container管理多个Controller和动画）\n- ViewController生命周期\n```\ninit\nviewDidLoad\nviewWillAppear\nviewDidAppear\nviewWillDisappear\nviewDidDisappear\nDealloc\n```\n#### 页面结构\n- 单页面展示（列表展示简介，较长滚动页面展示内容）\n- 多页面管理（4，5个底部按钮，通过push的方式进行页面切换）\n\n#### UITabBarController\n- 管理多个UIViewController切换\n\n#### UITabBar\n#### TabBar实现\n- 使用系统函数实现\n- 相关开源项目框架和项目\n#### UINavigationController\n- 通过栈管理页面间的调整\n- 通常只展示栈顶页面\n- push/pop操作\n- 通过UINavigationBar响应操作，处理UIViewController的切换\n#### UINavigationBar\n- UINavigationController管理\n- 顶部UIViewController变化，UINavigationBar同步变化\n#### Navigation实现\n- 使用系统函数实现\n- 相关开源项目框架和项目（开源Navigation相关集中在过渡动画的样式上）\n\n#### UIWindow\n- 特殊形式的UIView，提供App中展示内容的基础窗口\n- 只作为容器，和ViewController一起协同工作\n- 通常屏幕上只存在、展示一个UIWindow\n- storyboard会帮我们自动创建\n- 手动创建（UIWindow｜rootViewController｜makeKeyAndVisible）\n### 签名\n\n\n\n\n### 证书\n\n\n\n### 常用iOS唯一标识符\n\n\n### 打包\n\n\n\n### 上架流程\n\n\n## 线上问题处理\n\n#### 用户反馈登录验证码无法收到\n- 需要调用服务端接口\n- 接口无响应或者报错\n- 查看bonree埋点(用户会话只保留一周)\n- 因为没有登录，所以无法根据用户id查，只能用时间查异常会话了，查网络错误的\n- 发现对应会话日志提示（URLSessionTask failed with error:此服务器证书无效）\n- 辅助信息，对应设备在使用同样产品的微信小程序端时，也有request：fail errorcode:-201的提示，对应状态码是SSL证书过期或者无效的提示\n- 同样的网络情况下，别的请求都正常，只是涉及到我们的域的请求有问题\n- 查了下证书日期，快到期了，让用户调整了系统时间，解决，我们这边也及时续期"},{"title":"sed","url":"/2023/01/21/sed/","content":"> 之前写过一个awk,见之前博文2020-03-12的awk\n\n`sed`（stream editor）是一个在 Unix、Linux 和 macOS 上常用的命令行文本处理工具，它用于对文本文件的内容执行基本的文本转换。操作形式包括：插入、删除、追加、查找和替换。`sed` 常用于脚本和管道处理中。\n\n常用的 `sed` 命令格式如下：\n\n```\nsed [options] 'script' input_file\n```\n\n1. options: 选项，可选。\n2. script: 脚本，为 `sed` 命令\n3. input_file: 输入文件，作用的文本文件。\n\n以下是一些常用的 `sed` 选项：\n\n- `-e`: 允许在同一个文件中执行多个编辑操作\n- `-i`: 对文件执行原地编辑，即将操作后的内容覆盖到源文件\n- `-n`: 操作后的内容只输出到终端，源文件不受影响\n\n以下是一些常用的 `sed` 命令：\n\n1. 替换文本中的字符串（要注意转义符）：\n\n```\nsed 's/old-string/new-string/g' input_file\n```\n\n上述命令会将 `input_file` 中所有的 `old-string` 字符串替换为 `new-string`。\n\n\n2. 删除文本中的某行：\n\n```\nsed 'nd' input_file\n```\n\n其中，`n` 表示行号，例如 `3d` 则表示删除第三行。\n\n3. 添加新行（在某行之前或之后）：\n\n在第 `n` 行之前添加新行：\n\n```\nsed 'nia\\\\\nnew_line_content' input_file\n```\n\n在第 `n` 行之后添加新行：\n\n```\nsed 'na\\\\\nnew_line_content' input_file\n```\n\n请注意 a 和 i 的位置：'a' 表示在该行之后添加，'i' 表示在该行之前添加。\n\n这些仅是 `sed` 的一些基本操作。`sed` 还可以执行复杂的文本编辑和过滤操作，例如正则表达式匹配。\n"},{"title":"pandas-data-analysis-with-python-notes","url":"/2023/01/20/pandas-data-analysis-with-python-notes/","content":"> 朋友临时问了些数据分析的问题，引起了兴趣，花了两天看了下这个经典的课程，记录些琐碎的启发\n\n- Daniel Chen\n\n"},{"title":"chaos-engineering-summary","url":"/2023/01/20/chaos-engineering-summary/","content":"> https://github.com/dastergon/awesome-chaos-engineering\n#### chaos engineering\n- if something hurts,do it more often!\n\n- 如果问题经常发生，人们就会学习和思考解决它们的方法\n\n```\nchaos under control\n- terminate host\n- inject latency\n- inject failure\n```\n\nhttp://principlesofchaos.org\n\n#### 原则\nBuild a Hypothesis around Steady State Behavior\n\nVary Real-world Events\n\nRun Experiments in Production\n\nAutomate Experiments to Run Continuously\n\n\nMinimize Blast Radius\n\n#### github\n- chaosmonkey - Netflix\n- service_decorators - easierway - go语言"},{"title":"bonree-项目经验-summary","url":"/2023/01/20/bonree-项目经验-summary/","content":"- https://www.bonree.com/\n\n- 公司采购的，android和IOS端都接入了，作为问题上报，排查监控的工具\n\n\n#### 网络问题\n- 发现切换到特定网络后，报网络问题，ip已解析出来没问题，但是客户端的连通性有问题\n- https://cloud.tencent.com/document/product/213/14638\n- 帮忙收集下mtr的信息，我们看看具体是哪个设备的问题，目前看目的端是正常。初步看应该是在客户端或者中间设备有异常\n- 如果用户是手机端的话，可以安装这个工具来探测：IOS：iNetTools 到App Store安装下，免费的 安卓：pingTools，到应用商店安装下，免费\n\n\n### 小程序\n- skyline\n\n### rum\nAndroid && IOS\n存储周期：最近7天日志；(可花钱升级)\n15s上报一次\n每次上报不能超过200条(若超出，丢弃队尾)\n单条日志不能超过1w个字符\n全量上报：是 \n存储位置：内存"},{"title":"Flink-overview-summary","url":"/2023/01/20/Flink-overview-summary/"},{"title":"Nuxt-core-summary","url":"/2023/01/20/Nuxt-core-summary/","content":"- https://nuxt.com/\n\n### 核心原理\n"},{"title":"cookie-summary","url":"/2023/01/20/cookie-summary/","content":"> 之前好多文章也提过cookie，基于它的工作中问题的解决，浏览器相关的why,what,how\n\n\n### 减少cookie\n- 问题：旧项目，页面打开问题，cookie过大，页面跳转携带cookie，网络较差情况下，cookie会导致出现空白\n- 浏览器对cookie大小的限制（不同浏览器不一样），服务侧对header大小的限制（看配置）\n- 策略： 主站设置白名单｜定期删除非白名单cookie\n- 好处：减少页面间传输大小｜对cookie进行有效管理"},{"title":"WebVitals","url":"/2023/01/20/WebVitals/"},{"title":"Electron-why-what-how","url":"/2023/01/20/Electron-why-what-how/","content":"- ytb - CovalenceConf\n- 工具链上面的应用 +++ 效率应用，开发者工具\n- 业务上的应用 - 商家端，办公工具 - 快速上线桌面端，快速试错\n- atom,slack,vs code,whatsapp,wordpress\n- Frameworks\n\n- 客户端和基于浏览器的交互是不一样的，不要局限\n\n## Basic\n- Chromium - UI - 效率,web pages\n- Nodejs - 底层能力 - filesys + network\n- Native APIs - 跨平台，原生能力\n\n## history\n- 2011 - NW - 王文睿，赵成\n- 2015 - electron - 赵成 - atom-shell\n\n\n\n### electron-builder\n"},{"title":"WebRTC","url":"/2023/01/20/WebRTC/"},{"title":"netty-summary","url":"/2023/01/20/netty-summary/","content":"\n\n\n## study\n- https://github.com/arthur-zhang/netty-study.git\n\n### source code\n- backlog\n- ServerBootstrapAcceptor\n- io.netty.channel.nio.AbstractNioChannel#AbstractNioChannel \n- io.netty.channel.nio.AbstractNioChannel#doBeginRead\n- io.netty.channel.nio.NioEventLoop#run\n- Reactor 模型\n- 事件循环模式\n- Allocator\n- 边缘触发\n- 水平触发\n- io.netty.channel.AbstractChannelHandlerContext#write(java.lang.Object, io.netty.channel.ChannelPromise)\n- Netty Idle检测\n- NioEventLoopGroup\n- 零拷贝\n- ByteBuf\n- ByteBuf 的读写操作是非阻塞\n- Netty Recycler\n- FastThreadLocal"},{"title":"Android-ART-notes","url":"/2023/01/11/Android-ART-notes/","content":"## history\nDalvik\n- 使用解释  JIT\n\nART(4.4Kitkat-5.0Lollipop) Android RunTime\n- gc优化\n- AOT(Ahead-of-time)\n\nART（7.0Nougat）\n- 三种执行方式并存，引入speed profile\n\n### overview\n- compiler&interpreter\n  - 解释器\n  - JIT\n  - AOT\n- runtime\n  - 内存管理\n  - 类管理\n  - intrinsic\n  - 异常\n  - String\n  - 调试\n  - 线程\n  - JNI\n  - monitor\n\n## 对象\n### 对象如何分配出来的\nwho = 类的管理\nfrom where = 内存分配\nto where = 内存回收\n\n### 对象lifecycle\n- 对象分配\n  - 分配多大 - 类\n  - 怎么分配 - 内存管理\n- 对象使用\n  - 执行类的方法\n  - 访问对象成员\n- 对象销毁\n  - 内存回收 - GC && 清理\n\n#### 类管理 - 决定一个对象的大小和行为\n- 类主要描述的是一个对象的内存布局和函数信息\n- 内存布局： 类成员的大小、类型和排布\n- 函数信息： 主要是虚表的信息-某个函数定义在当前类函数表的第几个位置；因为java是支持继承的，因此类的捏成布局和函数虚表需要做继承链全展开以后才能真正确认（这也是动态性的来源）\n#### 类管理 - 基类Object的秘密\n\n- 类加载\n  - 一个类分配的对象大小，是由继承链决定的\n  - Java的类，是在第一次使用的时候，才会进行加载\n\n- 内存布局\n- 双亲继承\n  - 本质上，双亲委派就是认为划定的一个规矩，保证系统内同一个类的一致性\n- 合理的继承抽象的好处\n  - 合理的抽象，不是因为图方便直接放在顶层基类上，这就是好处\n#### 内存分配\n- 分配器 - APP的java对象内存分配是托管到VM来处理的，并不会直接向操作系统去申请，实际上对OS内存的占用和内存布局，是VM控制的（预留-扩展）\n- 不同分配器的特点\n- 典型场景\n  - bitmap在Android高版本，被隐藏到了native，不直接使用虚拟堆；内存一样，量小，方便快捷，但是大块儿的内存用起来慢，要从大池子里取，集中管理\n- 内存碎片\n  - ART内存分配的根本原理，给使用者在最优范围内找到一块大小符合的连续内存\n  - 希望可用内存尽可能连续\n\n#### 内存回收\n- GC（垃圾回收garbage collection），要定期查找系统内不用的对象，并且释放占用的内存\n- RC（引用计数reference counting），指的是对一个对象引用进行计数，多一个引用者，就+1，少一个，-1，为0就释放；典型的如IOS的swift就使用RC进行内存管理\n- RC的问题和解决\n- ART的引用\n  - 强引用：直接持有的\n  - 软引用：内存不够时候会回收\n  - 弱引用：只要触发GC就会被回收\n- 触发GC的条件\n  - 想要不被预期外的GC导致卡顿，可以考虑适当预留内存\n  - 大小有上限可预期的情况，new一个大数组，比分配一大堆到容器里面要好\n- apple内存少的原因之一\n- GC的方式\n  - GC roots的概念\n- tracing GC\n  - 从roots遍历，所有mark的对象是有holder的，释放掉没有holder的object\n- copying GC\n  - 从roots遍历，把有用的对象拷贝到另一个区域，然后集中释放掉当前区域的内存\n- ART的做法\n  - 前台GC ｜ 后台GC\n- 内存友好的代码\n- 回收之后\n  - finalize方法一般用来跟随对象的生命周期，清理掉绑定的native资源\n  - 一个对象的finalize方法只会执行一次，再次激活之后的对象是不会出发finalize的\n## 执行\n### 虚拟机为了保证代码执行提供的机制\n#### 虚拟机的执行方式\n- 解释执行-dex code\n- JIT-profile-JIT compile-JIT code\n- AOT- speed-profile -dex2oat-AOT code\n  - 在程序运行之前，对APK中的函数进行编译\n  - 和程序是否运行无关\n  - 编译的范围不是以函数为单位，以dex为单位\n  - 结果会持久化\n- 延迟绑定（绑定的越迟，动态性越好，性能越差）\n#### 栈管理 - 开始和结束\n- ART对于解释执行和编译后指令采用不同的策略\n  - 对于解释执行-栈托管到虚拟机完成\n  - 对于编译后的-压栈处理和native代码是一样的，遵从对应指令集的约定\n- 不同执行方式之间的切换\n  - 对于AOT，JIT到解释执行，或者反之的调用，ART采用trampoline-bridge机制来进行切换\n- 总结\n  - 压栈-出栈的速度不同，解释执行的速度慢\n  - 解释执行的栈结构是托管的，编译执行的栈结构是遵从虚拟机规则的\n  - 解释执行传递参数有额外的空间成本，编译执行没有\n  - 不同执行方式之间调用切换采用trampoline/bridge进行\n#### 异常处理\n- 当拿到一个异常的时候，会逐级回栈\n  - 回一级栈看看要不要\n  - 不要就跳出\n### 多线程 - 高效的执行\n- synchronize\n - JAVA 引入sync机制，让我们加解锁很方便\n\n### 同步机制 \n- monitor：如果我们对一个对象是用了sync，这个对象就会生成一个lock，保留在这个shadow monitor指向的内存地址中\n- 胖瘦锁切换\n\n- 深入理解Android-Java虚拟机ART\n- 虚拟机设计与实现-以JVM为例"},{"title":"Android-design-notes","url":"/2023/01/11/Android-design-notes/","content":"\n手段\n业务抽象\n分而治之\n标准规范\n组织管理\n\n演进\n解决问题\n保持重构\n迭代升级\n应对衰退\n\n公共问题\n- 编程思想\n- 问题分解\n- 领域建模\n- 服务治理\n- 流程机制\n- 架构标准\n\n业务发展 - 越来越复杂 - 必然趋势\n- 理解成本变高\n  - 宏大的规模不好理解\n  - 复杂的结构不好理解\n\n- 预测难度变大\n  - 业务变化\n  - 技术变化\n\n## Android OS\n#### 应用框架层\nApp开发者直接使用的接口层，UI的实现，数据的处理，资源的使用，都是用这一层的API\n#### Binder IPC\n提供跨进程访问的能力，App可以高效的访问由系统进程暴露的能力，App进程与系统进程之间的通信是典型的C/S模型\n#### 系统服务\n提供窗口管理，相机，音视频等系统能力，包含各种子系统，内部逻辑很庞大，往下调用HAL层封装的硬件能力；往上通过Binder暴露可以远程调用的API\n\n#### 硬件抽象层\n屏蔽底层不同驱动的差异，使得系统服务层可以快速适配到不同的硬件设备\n\n#### Linux内核\nCPU、内存、唤醒服务等重要的驱动实现都给予该层操作系统等核心实现\n\n## IOS\n#### 应用框架层 Cocoa touch(application layer)\n- EventKit\n- GameKit\n- MapKit\n- PushKit\n\n#### 图形图像层 media layer\n- ULKit\n- Animation\n- Graphics\n- Images\n\n#### 核心服务层 core services\n- Location\n- Motion\n- Health\n- GPS\n- Telephony\n- Foundation\n\n#### 内核层 core os\n- Bluetooth\n- Security\n- Accessories\n\n### Android vs IOS\nActivity  ViewController\nIntents   Segues/ViewControllers\nService   \"Backgrond Mode\"\nContentProvider   CoreData\nLayouts   Storyboards and scenes\n\n## Flutter\n#### UI框架层\n提供不同样式的组件和动画，声明式UI，Dart作为编程语言，同时支持JIT和AOT\n#### 引擎层\n将上层定义的UI树转换成屏幕像素，提供平台调用接口和Dart虚拟机\n\n#### 嵌入层\nFlutter引擎需嵌入不同的平台\n\n- 架构设计是为了解决特定领域不同发展阶段的业务问题\n- 不同领域的架构有明显的技术差异，但是也有相似性\n- 架构要面临技术挑战，还要应对组织业务膨胀的熵增\n- 移动端需要利用有限的设备资源设计符合小屏幕的架构\n\n\n### 小的架构手段\n#### GoF设计模式\n#### MVC\n- View和Controller容易膨胀\n- View和Model没有完全分离\n#### MVP\n- View和Model完全分离，可以修改试图而不影响模型，交互都发生在Presenter\n- Presenter与View的交互是通过接口来进行的，方便单元测试\n- 页面逻辑复杂的话，响应的接口也会变多，增加维护成本\n#### MVVM\n- ViewModel只负责处理和提供数据\n- ViewModel里面只包含数据和业务逻辑，没有UI，方便单元测试\n- 数据绑定使得程序较难调试，因为数据都是自动更新到UI\n\n#### AOP\n- OOP\n```\n类：代码以函数（Method）和字段（Field）的形式封装在类中\n函数：定义函数签名和函数体\n函数题：定义函数的执行逻辑\n编译器：将源代码转换成可执行代码\n```\n- AOP \n```\n类：代码以切点（PointCuts），属性（Attributes）、植入（Advice）的形式封装在类中\n切点：定义植入（Advice）的锚点\n植入：定义需要植入的逻辑\n植入器：将植入逻辑插入到锚点处\n```\n\n#### loC\n- 直接依赖：一个对象A要完成其功能，通常需要依赖于其他对象B，C等，其具体的实现方式就是在对象A中构建（new）其所依赖的对象B、C等，这就相当于A控制了它所依赖的对象B、C\n- 控制反转：打破A直接控制B这层关系，B对象的生命周期交由loC容器来控制，A不用再去寻找和初始化（控制）其所依赖的B、C了，只用等着loC容器的投喂就可以\n- 实例SPI\n\n### 大的架构手段\n- 单体架构\n- 分离架构\n- 分层架构\n- 服务化架构\n  - 需要约定模块可以对外提供的能力\n  - 模块之间需要遵循相同的调用方式\n  - 旧的模块需要按照相同的标准来改造\n  - 使用方不应该直接依赖于实现方\n- 事件驱动架构\n- 宿主-插件架构\n- 微内核架构\n- 微服务架构\n- 领域驱动架构\n\n## summary\n- 不同架构手段对共同目标是高内聚低耦合\n- 找到适合业务场景的脚骨\n- 一个复杂系统是多种架构模型的组合体\n\n> 定义问题 确定架构 方案落地 结果复盘\n\n> 认清问题 - 分类 && 分级\n## 基础能力\n### 常规能力建设\n#### 服务发现（SPI）\n- 基础能力服务化是一个重要的解耦手段\n#### 路由能力\n- 统一schema信息管理，规范多端路由框架的使用接口\n#### 字节码增强能力\n- 加强字节码增强技术的易用性，同时避免滥用\n#### 网络能力\n\n\n### 跨端能力建设\n#### Web容器\n- 建设更好的web容器生态，为业务提供容易接入，性能可靠，灵活性高的容器组件\n#### JSBridge\n- 统一多套JSB框架，多端暴露一致的Native能力\n\n#### Flutter\n\n\n### UI相关能力建设\n\n#### 基础UI控件\n- 保持基础的UI控件在多端的一致性\n#### 夜间模式\n- 夜间模式能提升图文场景下的用户体验\n#### Native容器\n- Native容器的统一有利于代码复用和页面基础能力建设\n### 技术栈突破\n#### 静默灰度能力\n- 显著提升版本升级率，加快需求验证\n#### 新技术预研\n- 保持技术热情，探寻更好的解决方案\n\n## 标准化\n### 规范\n- 树立共同的认知\n#### 公约/考试\n#### 数据公示\n#### 工程素养小活动\n\n### 工具\n- 保障规范的落地\n#### 重复资源\n#### 大文件、大函数、圈复杂度\n#### 依赖检测\n\n#### 宏观指标\n- 重复率\n- 组件数\n\n#### 无用代码\n- 无用setting\n- 未调用的函数\n## 工程架构\n### 物理结构优化\n- 良好的工程结构-开发的第一印象\n#### 工程组织模式\n- 提供简洁高效的工程组织关系\n#### 仓库治理\n- 保持仓库层级和数量在标准范围\n#### 多端工程一致性\n- 保持多端在公共仓库和组件使用上的一致性\n### 组件治理\n- 目的：更新技术栈，服务多元业务\n#### 组件依赖治理\n- 消费和拦截不合理的组件间以来\n#### 组件内标准化改造\n- 保持每个组件职责清晰\n#### 多端组件能力统一\n- 抹平不必要的组件多端差异\n\n### 插件治理\n- 持续提升插件这项重度使用的动态化能力，能够让业务迭代更为灵活\n#### 插件间依赖治理\n#### 插件能力建设\n- 完善插件相关各项基础能力\n#### 插件标准化改造\n- 规范多端插件调用和启动方式\n### 全局复杂度治理\n#### 工具建设\n- 完善有利于代码复杂度问题消费的工具\n#### 存量问题消费\n- 持续为各业务方消费存量代码复杂度问题做好配套服务\n#### 防劣化建设\n- 通过规范或流程卡口帮助复杂度指标不劣化\n\n## 业务架构\n### 解耦\n#### 多业务之间的依赖\n- 提升单个业务迭代效率\n-> 形成业务间依赖规范\n#### 组件之间的不合理依赖\n- 降低组件迁移成本\n-> 形成组件间接口规范\n\n### 逻辑优化\n#### 业务设计和实现优化\n- 提升业务的复用率\n\n#### 组件逻辑优化\n- 提升组件的通用性\n-> 减少重复代码，能力更稳定\n\n### 核心能力中台化\n#### 视频\n#### 图文\n#### Feed\n\n#### 内容生产\n\n## 目标\n### 技术基建\n- 工具流程易使用\n- 品质优化可复制\n- 质量基建强约束\n- 整体架构高可用\n\n#### 目标\n- 平台接入工具便捷 -> 持续集成流水线、埋点上报和分析平台，实验平台等\n- 本地工具随取随用 -> 各类IDE插件、编译工具链等可直接用于新产品\n- 通用场景直接复用 -> 诸如磁盘、内存、线程调度优化等，可直接复制迁移\n- 特殊场景沉淀基建 -> 诸如启动、预加载、分片处理等，需沉淀框架能力，形成通用组件\n- 线下监测分析准入 -> 代码静态检查和运行时监控、自动化测试、、内测众测等通用能力和流程\n- 线上监控止损归因 -> 各类指标监控报警手段、反馈舆情收集、熔断和回滚机制\n- 工程结构简洁清新 -> 架构模型、演进思路、工程要素的组织关系要做到清晰明确\n- 技术栈保持先进性 -> 工具、组件、Android版本、跨端、热修等动态化能力需持续更新\n\n### 多个业务\n- 业务之间低耦合\n- 扇入扇出标准化\n- 业务集合可维护\n\n#### 目标\n- 服务注册发现机制 -> 利用中心服务管理模块进行解耦\n- 公共模块下沉机制 -> 利用具备公共代码的模块进行解耦\n- 接口使用规范一致 -> 多业务对外暴露的接口遵循相同的命名、参数、语义规范\n- 业务外部依赖收敛 -> 最小化业务对外部的依赖，同步多业务相同依赖的版本\n- 业务复用的清单制 -> 业务组合的场景很多，比如大业务拆开分层组合，需整体维护组合清单\n- 业务集合的准入制 -> 大而全，但整体可复用程度低的业务稽核，不如少而精\n\n\n### 单个业务\n- 具备好的扩展性\n- 支持傻瓜式集成\n- 宿主依赖接口化\n\n#### 目标\n- 外围能力可插拔 -> 业务内部具备事件路由能力，能够将事件调度到外围\n- 扩展定制有范式 -> 差异化改造可用参照已有的扩展方式，不需要魔改\n- 样例文档完备 -> 可用人工支持频次的降低来衡量样例文档是否健全\n- 侵入式改造少 -> 减少集成的改造点和代码量\n- 数据链路闭环 -> 从外部获取数据后，尽量业务内部闭环处理，交付结果给外部\n- 默认实现兜底 -> 外部依赖尽可能有兜底实现，可让业务独立可调试"},{"title":"Android-performance-notes","url":"/2023/01/11/Android-performance-notes/"},{"title":"算法-cases-notes","url":"/2023/01/09/算法-cases-notes/"},{"title":"map-miniprogram-summary","url":"/2022/12/14/map-miniprogram-summary/","content":"### 报错\n#### Uncaught (in promise) undefined(env: macOS,mp,1.06.2209190; lib: 2.26.1)\n- https://developers.weixin.qq.com/community/develop/article/doc/00046a101ccec0124c9e3cba45bc13\n- Uncaught (in promise) undefined(env: macOS,mp,1.06.2209190; lib: 2.26.1)\n- 解决 - 更换调试基础库"},{"title":"Libuv-summary","url":"/2022/12/14/Libuv-summary/","content":"## 数据结构和通用逻辑\n- https://libuv.org/\n- https://github.com/thlorenz/libuv-dox/blob/master/types.md\n```\nTable of Contents generated with DocToc\n- loop\nuv_loop_t\n- requests\nuv_req_t\nuv_getaddrinfo_t : uv_req_t\nuv_shutdown_t : uv_req_t\nuv_write_t : uv_req_t\nuv_connect_t : uv_req_t\nuv_udp_send_t : uv_req_t\nuv_fs_t : uv_req_t\nreq->result\nuv_work_t : uv_req_t\nuv_connect_t : uv_req_t\n- buffers\nuv_buf_t\n- handles\nuv_handle_t\n- streams\nuv_stream_t : uv_handle_t\nuv_tcp_t : uv_stream_t\nuv_tty_t : uv_stream_t\nuv_pipe_t : uv_stream_t\n- udp\nuv_udp_t : uv_handle_t\n- poll\nuv_poll_t : uv_handle_t\n- prepare\nuv_prepare_t : uv_handle_t\n- idle\nuv_idle_t : uv_handle_t\n- async\nuv_async_t : uv_handle_t\n- timer\nuv_timer_t : uv_handle_t\n- process\nuv_process_t : uv_handle_t\n- file system\nuv_fs_event_t : uv_handle_t\nuv_fs_poll_t : uv_handle_t\n- signal - uv_signal_t\n- cpu info\nuv_cpu_info_t\n- interface address\nuv_interface_address_t\n- file info\nuv_stat_t\nuv_timespec_t\n- stdio\nuv_stdio_container_t\n- process\nuv_process_options_t\n- enumerations\nuv_errno_t\nuv_handle_type\nuv_req_type\nuv_udp_flags\nuv_poll_event\nuv_stdio_flags\nuv_process_flags\nuv_fs_type\nuv_fs_event\nuv_fs_event_flags\n```\n\n## 事件循环\n\n\n## 线程池和线程间通信\n\n\n## 流机制\n\n\n## C++胶水层把libuv功能引入JS"},{"title":"httpVersion-summary","url":"/2022/12/09/httpVersion-summary/","content":"- http://www.alloyteam.com/2016/07/httphttp2-0spdyhttps-reading-this-is-enough/\n```\ncite: \n对比 HTTPS 的升级改造，HTTP2.0 或许会稍微简单一些，你可能需要关注以下问题：\n\n前文说了 HTTP2.0 其实可以支持非 HTTPS 的，但是现在主流的浏览器像 chrome，firefox 表示还是只支持基于 TLS 部署的 HTTP2.0 协议，所以要想升级成 HTTP2.0 还是先升级 HTTPS 为好。\n当你的网站已经升级 HTTPS 之后，那么升级 HTTP2.0 就简单很多，如果你使用 NGINX，只要在配置文件中启动相应的协议就可以了，可以参考 NGINX 白皮书，NGINX 配置 HTTP2.0 官方指南。\n使用了 HTTP2.0 那么，原本的 HTTP1.x 怎么办，这个问题其实不用担心，HTTP2.0 完全兼容 HTTP1.x 的语义，对于不支持 HTTP2.0 的浏览器，NGINX 会自动向下兼容的。\n```\n- https://http2.akamai.com/\n```\nhttps://caniuse.com/?search=http2\nhttp://www.alloyteam.com/2015/03/http2-0-di-qi-miao-ri-chang/\n```\n- https://http3-explained.haxx.se/zh\n\n\n- https://cloud.tencent.com/developer/article/1464264\n\n### 腾讯云点播\n\n- 腾讯云点播，如果想支持http2.0，发下需要配置的域名，腾讯云点播后台来配置就行，有个变更窗口了，需要下周一才能配置\n\n- 配置之后，就会支持http2.0\n\n- head of lin blocking - 对同一个域下请求数量的限制 - 2.0 基于二进制分帧，可避免这个问题\n\n- 影响绝大多数应用性能的并非带宽，而是延迟，而2.0能解决这个问题； 我们这边云点播就出现用户反馈，观看卡顿，用腾讯云的华佗测速工具，发现延迟较大，带宽是OK的；\n\n### 腾讯云CDN\n- https://cloud.tencent.com/document/product/228/41689\n```\nHTTP2.0 作为最新的 HTTP 协议，大幅提升了 Web 性能，进一步减少了网络延迟。已配置证书启用 HTTPS 加速的域名，可自助开启 HTTP2.0 协议支持。\n注意：\n目前仅支持 HTTP2.0 访问，暂不支持 HTTP2.0 协议回源。\n（\"回源\"是网络技术中的术语，主要在CDN（内容分发网络）技术中使用。回源是指当CDN的边缘节点收到用户请求时，如果节点没有请求的内容，那么这个节点就需要向原服务器（源站）请求这个内容的过程，这个过程就叫“回源”。\n\n一般来说，在CDN中，用户的请求首先会被指向最近的边缘节点。如果这个节点有用户请求的内容（比如网页、图片、视频等），那么就直接从这个节点把内容提供给用户。这样可以大大提高用户访问的速度，因为内容的传输距离变短了。\n\n但是，如果这个边缘节点没有用户请求的内容，那么它就需要向原服务器（源站）请求这个内容。源站把内容返回给边缘节点，节点再把内容提供给用户，这个过程就是“回源”。\n\n\"回源\"的过程对于CDN服务提供商来说，需要消耗较高的带宽和资源，因此通常会尽量通过缓存等技术，减少回源的发生。）\n```\n- CDN - 把数据放到离用户地理位置更近的地方，减少每次TCP连接的网络延迟，增大吞吐量\n\n### 推荐书\n- web性能权威指南 - qq阅读上面有，可当工具书查看使用\n\n### http 基础\n#### 数据传输\n- url param\n- query\n- form-urlencoded\n- form-data\n- json\n\n### 项目数据\n- 先升了腾讯云点播的域名(支持http2.0)\n- xxxvod.xxx.cn"},{"title":"useEffect-summary","url":"/2022/12/09/useEffect-summary/","content":"- https://overreacted.io/zh-hans/a-complete-guide-to-useeffect/\n\n- https://zh-hans.reactjs.org/docs/hooks-effect.html\n关注点分离"},{"title":"proxy-js-summary","url":"/2022/12/09/proxy-js-summary/","content":"- https://cn.vuejs.org/guide/essentials/reactivity-fundamentals.html#reactive-proxy-vs-original\n- https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy"},{"title":"win11-dev-setup","url":"/2022/11/29/win11-dev-setup/","content":"#### 软件安装管理\n- https://github.com/chocolatey/choco\n\n#### 快捷键处理\n\n- https://www.autohotkey.com/ - 按指导下载安装autohotkey\n- \n```\n# 具体脚本配置参考这篇\nhttps://blog.csdn.net/weixin_44839047/article/details/126166602\n```\n- 右键脚本，更多选项，compile，这样就可以生成一个.exe的可执行文件\n- 把这个可执行文件放在开机自动启动的地方（%USERPROFILE%\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup）\n\n#### vscode\n```\n在 ESLint 中，\"Delete cr (Carriage Return) eslint\" 是一个规则，它用于检测代码中是否包含了 Windows 风格的行尾符（即 Carriage Return + Line Feed，或者简写为 CRLF）。\n\n由于不同操作系统使用不同的行尾符，因此在不同操作系统之间共享代码时，可能会出现类似“missing newline at end of file”的问题。这个规则就是用来解决这个问题的。\n\n当启用 \"Delete cr (Carriage Return)\" 规则时，ESLint 将会检测代码中是否包含了 Windows 风格的行尾符，并将其替换为 Unix 风格的行尾符（即 Line Feed，简写为 LF），从而消除跨平台共享代码时遇到的行尾符问题。\n\n例如，在以下代码中：\n\nfunction add(a, b) {\n  return a + b;\n}\n如果该文件使用的是 Windows 风格的行尾符，则该文件的结尾将会有一个 Carriage Return 字符，这可能会导致 ESLint 报告 \"missing newline at end of file\" 错误。启用 \"Delete cr (Carriage Return)\" 规则后，ESLint 将自动删除该字符并将其替换为 LF 字符，以消除这个错误。\n\n需要注意的是，如果您想在语法上保留 Windows 风格的行尾符，请勿启用 \"Delete cr (Carriage Return)\" 规则，或者调整相关配置，以便在特定情况下忽略或禁用该规则。\n\nwarning: in the working copy of 'src/app.controller.spec.ts', LF will be replaced by CRLF the next time Git touches it\n这个警告信息是 Git 在 Windows 系统上的表现，它提示您在 Git 操作过程中可能会修改文件的行尾符格式。\n\n具体来说，该警告表示您的 Git 工作副本中包含了使用 Unix 风格的行尾符（即 LF 字符），但是当 Git 在 Windows 平台上操作该文件时，它将自动替换为 Windows 风格的行尾符（即 CRLF 字符）。这可能会导致一些问题，例如代码格式化和跨平台共享代码等问题。\n\n为了避免这个问题，可以在 Git 配置中设置 core.autocrlf 属性。如果您希望在提交代码时将其转换为 Windows 风格的行尾符，则可以将此属性设置为 true；如果您希望保留原始的行尾符格式，则可以将此属性设置为 false；如果您希望在 Windows 平台上自动转换为 CRLF 行尾符，并在其他平台上保留原始格式，则可以将此属性设置为 input。\n\n例如，要将 core.autocrlf 设置为 true，可以执行以下命令：\n\ngit config --global core.autocrlf true\n这将告诉 Git 在提交代码时将所有行尾符都转换为 CRLF 格式。\n\n需要注意的是，行尾符格式的问题可能会对代码的版本管理和跨平台共享造成影响，请谨慎处理并选择适合您的项目和团队的最佳实践。\n\n在 Windows 中，您可以使用多种方法修改文件的行尾符类型，以便与 Unix/Linux 或 macOS 上的文件相兼容。下面是一些常见的修改行尾符的方法：\n\n使用文本编辑器：大多数文本编辑器都支持设置行尾符类型。例如，在 Visual Studio Code 中，您可以单击底部状态栏中的 CRLF 按钮，以切换行尾符类型。选择 LF 将使其更改为 Unix 风格的行尾符，而选择 CR 和 CRLF 则将其更改为 Macintosh 和 Windows 风格的行尾符。\n\n使用 Git 命令：如果您正在使用 Git 进行版本控制，则可以使用以下命令将所有文件的行尾符转换为 LF（Unix 风格）：\n\ngit config --global core.autocrlf input\ngit rm --cached -r .\ngit reset --hard\n这将配置 Git 在提交代码时自动将行尾符转换为 LF，并将所有文件的缓存清除并重新检出。\n\n使用 PowerShell 脚本：您可以编写一个 PowerShell 脚本来递归地遍历目录并将所有文件的行尾符转换为 LF，如下所示：\nGet-ChildItem -Recurse | Where-Object {-not $_.PSIsContainer} | ForEach-Object {\n  (Get-Content $_.FullName) | Set-Content $_.FullName -Encoding UTF8\n}\n此脚本将读取所有文件的内容并将其写入同一文件中，但同时将行尾符转换为 LF。\n\n需要注意的是，修改行尾符可能会影响代码在其他操作系统上的兼容性，因此请谨慎操作并确保您了解相关风险和最佳实践。\n```"},{"title":"云函数-summary","url":"/2022/11/28/云函数-summary/","content":"- 腾讯云： https://cloud.tencent.com/document/product/583/19805"},{"title":"cocos-creator-summary","url":"/2022/11/19/cocos-creator-summary/","content":"## 文档&论坛\n- http://docs.cocos.com/creator/manual/zh/getting-started/install/\n- https://forum.cocos.org/\n\n## 设置 - language - 可以切换语言\n\n\n## basic \n- Cocos Creator 是一款基于 Cocos2d-x 引擎的游戏开发工具，它实现了组件式开发、场景编辑器、动画编辑器等丰富特性\n- Cocos Creator 3.x 是该引擎的最新版本，相较 2.x 的版本，它在渲染、物理、脚本系统等方面有很大的改进\n\n1. 基础架构\n\nCocos Creator 使用的是基于 Entity-Component-System (ECS) 的组件化开发模式。\n在 ECS 架构中\n实体 (Entity) 是游戏世界中的各个独立对象，如游戏角色、场景物体等；\n组件 (Component) 是用来描述实体的属性和行为的模块，如渲染、物理、用户输入等；\n系统 (System) 是用来处理组件之间的交互和更新组件状态的逻辑。\n\nCocos Creator 中的实体使用 `Node` 类来表示，组件使用 `Component` 类，系统使用 `System` 类。开发者可以通过创建自定义组件和系统来拓展游戏的功能。\n\n2. 渲染\n\nCocos Creator 3.x 的渲染系统使用了全新的渲染管线，支持高性能的 native 渲染和 Web 渲染。核心渲染相关的代码位于 `engine/renderer` 目录下。\n\n主要的渲染类有：\n\n- `Pipeline`：渲染管线，负责渲染任务的调度处理。\n- `RenderView`：渲染视图，用来定义各种渲染参数。\n- `Pass`：渲染过程，描述了绘制一次材质的操作。\n- `FrameBuffer`：帧缓冲区，用于存储渲染生成的像素数据。\n\nCocos Creator 支持 forward 渲染管线（正向渲染）和 deferred 渲染管线（延迟渲染），可以根据游戏需求选择合适的渲染方式。\n\n3. 物理\n\nCocos Creator 3.x 集成了开源物理库 Ammo.js 和 cannon.js，为开发者提供了一整套的物理系统解决方案。核心物理相关的代码位于 `engine/physics` 目录下。\n\n主要的物理类有：\n\n- `RigidBody`：刚体，用于表示物体的质量、速度等属性。\n- `Collider`：碰撞器，用于检测物体之间的碰撞。\n- `PhysicsSystem`：物理系统，用于处理刚体、碰撞器的更新和物理世界的模拟。\n\n4. 脚本系统\n\nCocos Creator 3.x 支持 JavaScript 和 TypeScript 两种脚本语言，开发者可以选择自己熟悉的语言进行游戏开发。核心脚本相关的代码位于 `engine/scripting` 目录下。\n\n主要的脚本类有：\n\n- `Script`：脚本基类，所有的游戏脚本都需要继承自这个类。\n- `Component`：组件脚本基类，用于创建自定义组件。\n- `System`：系统脚本基类，用于创建自定义系统。\n\n#### gfx\ngfx（Graphics API Framework，图形 API 框架）是 Cocos Creator 3.x 引擎的图形渲染部分的底层实现。它是一个跨平台的图形 API 抽象层，可为不同的图形 API 提供统一的接口。引擎通过 gfx 来实现跨平台渲染的能力。这个框架使得引擎可以在不同的平台上适配不同的底层图形 API，例如 WebGL、WebGL2、Metal、Vulkan 和 Direct3D 等。\n\ngfx 主要包括以下几个部分：\n\n抽象层：这里定义了所有跨平台的图形 API 的基本接口，例如管线、缓冲区、纹理、着色器等。开发者可以使用这些接口编写能在不同平台上运行的渲染代码。\n\nAPI 实现层：这个层次实现了 gfx 抽象层中各个接口的具体实现。针对每种图形 API，引擎都实现了一套 API 实现层。这里包括 WebGL、WebGL2、Metal、Vulkan 等对应的 API 实现。\n\n命令缓冲：为了优化渲染性能，引擎采用了命令缓冲的技术，将渲染命令先缓存起来，然后在合适的时机统一提交给 GPU。这样可以减少 CPU 和 GPU 之间的通信成本，提高渲染性能。\n\n资源管理：gfx 还提供了一套资源管理机制，让开发者可以方便地管理渲染所需的资源，如纹理、缓冲区、渲染目标等。这一部分也会处理资源生命周期和内存管理等问题。\n\n通过 gfx，Cocos Creator 3.x 在底层实现了一套高效、跨平台的渲染系统。从而使开发者可以专注于游戏逻辑的开发，而无需关心不同平台的底层实现细节。\n\n\n### 发布\n\n#### 小程序\n- https://developers.weixin.qq.com/minigame/dev/guide/game-engine/cocos-laya-egret.html\n- 物理静音键问题\n\n### web audio\n- https://mp.weixin.qq.com/s/8DCFok78lzqgCrp_w5rEmw\n\n### 虚拟摇杆\n\n组件和属性的设置\n触摸事件的监听\n触摸移动计算\n杆的运动边界限制\n\n\n## others\n### laya"},{"title":"babel-debug","url":"/2022/11/17/babel-debug/","content":"\n\n## 插件机制\n\n- babel 插件 - 进一步封装成了预设（preset）, out of box\n\n### core\n- babel本身的优势在于可以实现各种插件，从而解析和转换JS代码\n### 原理\n- babel -> JavaScript代码转换器（transpiler）\n- Abstract Syntax Tree 抽象语法树\n- code PARSE(解析 -> Abstract Syntax Tree)\n- TRANSFORM（transpile-转换 -> 对AST进行 traverse&&replace）\n- GENERATE（生成 -> 根据新的AST生成编译后的code） code\n- babel插件的作用 - 在上面的过程中，对AST进行修改，从而达到转换的目的\n\n### cases\n\n#### 简化向量运算\n- https://spritejs.com/#/\n- https://github.com/toji/gl-matrix\n- https://www.npmjs.com/package/babel-plugin-transform-gl-matrix\n- 测试先行\n\n### babel-plugin\n- https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md\n\n\n### @babel/traverse\n- 用于遍历和更新抽象语法树（Abstract Syntax Tree，AST）\n- \"@babel/traverse\" 的模块对于做语法分析、代码转化、代码生成等任务非常实用。\n\n在 Babel 的转换流程中，“解析”阶段会生成一棵 AST，然后 \"@babel/traverse\" 在“转换”阶段遍历这棵 AST，根据需要进行各种转换。你可以在插件或 preset 中使用它，以实现你想要的转换。\n\n```javascript\nimport * as parser from \"@babel/parser\";\nimport traverse from \"@babel/traverse\";\nconst code = \"function square(n) { return n * n; }\";\nconst ast = parser.parse(code);\n\ntraverse(ast, {\n  enter(path) {\n    if (path.isIdentifier({ name: \"n\" })) {\n      path.node.name = \"x\";\n    }\n  }\n})\n```"},{"title":"mysql-why-and-how","url":"/2022/11/14/mysql-why-and-how/","content":"\n> backend - storage - practice\n#### concept\n- mysql数据库实例 - 代表着mysql服务器程序的进程\n- 进程ID - PID\n- 性能消耗 + 业务架构设计要求\n- 复杂读写操作-组合索引查询多表 | 读写分离 | 表结构拆解\n\n## MySQL - 高可用，分片问题\n\n#### NewSQL\n- Google - Cloud Spanner\n- OceanBase\n- CockroachDB - 小强数据库\n\n#### No SQL\n性能好，存储结构简单-容易组成分布式集群，水平扩展，高可用，高可靠，不支持SQL\n- Redis\n- KV 存储系统\n\n## 数据库扩展\n- 读操作是最耗数据CPU的操作 => 读写分离CQRS-Command and Query Responsibility Segregation\n- https://www.slideshare.net/planetcassandra/codecentric-ag-cqrs-and-event-sourcing-applications-with-cassandra"},{"title":"依赖包源码debug","url":"/2022/11/13/依赖包源码debug/"},{"title":"HarmonyOS-summary","url":"/2022/11/07/HarmonyOS-summary/","content":"\n#### 在线教育和小游戏\n- 分布式任务调度 - 延迟问题，高吞吐问题 | 分布式数据库 - 频繁访问问题，软总线使用限制\n- 分布式调度涂鸦画板\n- 分布式游戏 - （终端设备，大屏显示+音响+控制端）\n- 应用在不同设备迁移\n- 分布式音乐立体播放（不同设备同时播放） - 分布式音频控制调度 - harmonyos软总线能力\n- 分布式硬件控制 - HiSpark赛车\n\n#### 直播 - 互动跨端迁移流转\n- 1688商家直播\n- 设备间高效协同\n- 大屏互动\n- 连接线路少\n- 高性价比设备\n- 之前有的Android端应用，增加harmonyos能力支持\n- 难点 - 混合开发，64位（Android与harmonyos兼容性） | 跨设备通信-IDL双向通信\n"},{"title":"小程序-tips-summary-dev","url":"/2022/10/29/小程序-tips-summary-dev/","content":"\n### 几个问题\n双线程模型 - 复杂的渲染和通信设计；\n多页面栈模型 - vsSPA\n包体积限制\n\n#### 设置\n- app | page | app&&page\n\n#### 版本\n预览版本 -> (开发版本 -> 体验版本) -> 审核版本 -> 线上版本\n\n#### 自动化测试\n工具 - 自动化测试\n\n#### 开发框架\n- WeiXin Markup Language\n- feature => 数据绑定 | 列表渲染 | 条件渲染 | 模板引用\n\n\n## 其他\n### finclip\n- https://www.finclip.com/mop/document/introduce/introduction/finclip.html\n- FinClip是一款小程序容器，不论是移动 App，还是电脑、电视、车载主机等设备，在集成FinClip 小程序 SDK之后，都能快速获得运行小程序的能力。"},{"title":"ts-migration","url":"/2022/10/26/ts-migration/","content":"ts-migrate\n\nhttps://github.com/airbnb/ts-migrate\n\nhttps://medium.com/airbnb-engineering/ts-migrate-a-tool-for-migrating-to-typescript-at-scale-cd23bfeb5cc"},{"title":"小程序-底层框架设计及实现","url":"/2022/10/24/小程序-底层框架设计及实现/","content":"- 解包lib库\n- 开发者工具里面，console -> openVendor\n- wxappUnpacker - github - 按操作说明解压包 - 但是因为被混淆了，所以可读性不太行"},{"title":"go-summary","url":"/2022/10/20/go-summary/","content":"\n> go程序设计语言 ｜ 面向模式的软件架构-模式系统\n## go\n#### what\n- 高性能，高并发\n- 语法简单，学习曲线平缓\n- 丰富的标准库\n- 完善的工具链\n- 静态链接\n- 快速编译\n- 跨平台\n- 垃圾回收\n\n#### 应用-公司\n- 字节，腾讯，美团，滴滴，百度，谷歌。Facebook。七牛云，bili, pingcap\n\n#### 字节why - go\n- 最初python，性能问题换成了go\n- C++不适合在线Web业务\n- 早期团队非Java背景\n- 部署简单，学习成本低\n- 内部RPC和HTTP框架的推广\n#### 开发环境\n- golang安装\n- 配置集成开发环境\n- 基于云的开发环境 \n\n#### 语言基础语法\n\n## 进阶\n- 并发编程\n### 并发VS并行\n> go可以充分发挥多核优势，高效运行\n#### Coroutine\n- 用户态-内核态\n- 线程：用户态，轻量级线程，栈MB级别\n- 协程：内核态，线程跑多个协程，栈KB级别\n\n#### CSP - communicating sequential processes\n- 通过通信共享内存\n- 通过共享内存实现通信\n- 提倡通过“通信共享内存”而不是通过共享内存而实现通信\n\n#### channel\n- make（chan元素类型，[缓冲大小]）\n- 无缓冲通道 - make(chan int)\n- 有缓冲通道 - make(chan int,2)\n\n#### 并发安全lock\n\n#### WaitGroup\n\n## 依赖管理\n- 背景：工程项目不可能基于标准库0～1编码搭建\n- 管理依赖库\n#### go依赖管理演进\n- 不同环境（项目）依赖的版本不同\n- 控制依赖库的版本\n- GOPATH | Go Vendor | Go Module\n\n#### GOPATH\n- 场景：A和B依赖于某一package的不同版本\n- 问题：无法实现package的多版本控制\n\n#### Go Vendor\n- 项目目录下增加vendor文件，所有依赖包副本形式放在$ProjectRoot/vendor\n- 依赖寻址方式： vendor=>gopath\n- 通过每个项目引入一份依赖的副本，解决了多个项目需要同一个package依赖冲突问题\n- 无法控制依赖的版本\n- 更新项目又可能出现依赖冲突，导致编译出错\n\n\n\n"},{"title":"evan_22_web_trend_frontend_summary","url":"/2022/10/19/evan-22-web-trend-frontend-summary/","content":"- https://juejin.cn/book/7127092198096502822/section/7127210360884428812\n> evan\n## 讲稿笔记\n> 以下内容均为讲稿笔记\n### 开发范式&底层框架\n#### React Hooks\n- 已经彻底取代了Class Components\n- 启发了组件逻辑表达和逻辑复用的新范式\n- Vue Composition API | Sevelte | SolidJS\n\n#### React Hooks的开发体验问题逐渐被正视\n- Hooks执行原理和原生JS心智模型的差异\n- 不能条件式调用\n- Stale Closure（过期闭包）的心智负担\n- 必须手动声明useEffect依赖\n- 如何“正确”使用useEffect是个复杂的问题\n- 需要useMemo / useCallback等手动优化\n\n#### React 团队对改善开发体验的努力\n- useEvent RFC改善\n- useCallback 的问题\n- Dan Abramov花大量时间改进新版useEffect文档\n- 黄玄正在开发中的React Forget意再避免需要手动声明依赖\n\n#### 基于依赖追踪的范式重新得到重视\n- SolidJS ｜ Vue Composition API | Ember Starbeam\n- https://github.com/starbeamjs/starbeam\n- 共同点：一次调用，符合原生JS直觉；自动追踪依赖，无需手动声明；引用稳定，无需useCallback\n\n#### 基于编译的响应式系统\n- Svelte ｜ Vue Reactivity Transform | solid-labels\n- Svelte简洁的代价：只能在Svelte组件内使用｜组件外需要不同的API｜只能在顶层作用域使用，不可在函数体内使用\n- Vue Reactivity Transform | solid-labels ： 可在组件和普通JS/TS文件中使用\n\n#### 统一模型的优势和代价\n- 优势：利于长期的重构和服用\n- 代价：底层实现的抽象泄漏，初期的学习成本\n\n#### 基于编译的运行时优化\n- Svelte｜ Solid ｜ Vue Vapor Mode\n- 不同策略对生成代码量的影响（组件数量/打包后总大小）\n\n### 工具链\n#### 原生语言再前端工具链中的使用\n- esbuild(Go)\n- SWC(Rust)\n- Bun(Zig)\n- Parcel 2 (JS/Rust hybrid)\n- Vite(JS/ Go hybrid via esbuild)\n- napi-rs(Rust)\n\n#### 原生语言在前端工具链中的使用\n- 原生语言更适用于用例专注且标准相对稳定的情况，否则很难榨取最大化的性能优势\n- 原生语言会影响可扩展性，增加社区参与门槛，影响生态发展\n- JS/原生混合工具链将会成为常态\n\n#### 工具链的抽象层次\n- 专注于打包，抽象层次低 - browserify | webpack | rollup\n- 专注于应用，抽象层次高 - parcel ｜ vue-cli | cra\n- cli专注于应用，抽象层次高；API专注于支持上层框架，抽象层次中 - vite\n\n#### 基于Vite的上层框架\n- Nuxt3 | SvelteKit | Shopify Hydrogen | Astro | Qwik | FastifyDX | Solid Start | Laravel新默认前端方案\n\n### 上层框架Meta Frameworks\n> 一个语言，前后“打通”\n#### 数据的前后打通\n- Next - getStaticProps/getServerSideProps\n- Nuxt - API routes + useFeth + top level await\n- Remix loader/action + enhanced HTML Form\n\n- 通过显式引入共享类型\n- 自动基于DB schema生成类型\n- Nuxt3 自动基于文件布局生成API/路由类型\n\n#### 全栈的代价\n- 虽然数据已经渲染出了HTML，但还是需要额外发送一份数据用于Hydrate\n- 即使在客户端没有交互的组件依然会被打包发送至用户端\n- Hydrate 影响页面交互指标（TTI）\n\n#### 社区的探索方向\n- Server-only Components（Hydrogen, Next, Nuxt）\n- Partial hydration / Island Architecture (Astro, Isles, Fresh)\n- Fine-grained + resumable hydration (Owik)\n- Shell + partial hydration (VitePress)\n"},{"title":"superset_summary","url":"/2022/10/19/superset-summary/","content":"- Apache Superset is a Data Visualization and Data Exploration Platform\n- A modern, enterprise-ready business intelligence web application.\n> 数据埋点的后台看板，放在了私有化部署的superset上面\n\n### SQL工具箱\n\n### hive\n- Apache Hive ™数据仓库软件便于使用SQL读取、写入和管理分布式存储中的大型数据集。\n- https://hive.apache.org/\n```\nmsck repair table\n```"},{"title":"chrome-devtools-summary","url":"/2022/10/19/chrome-devtools-summary/","content":"- https://developer.chrome.com/docs/devtools/\n- https://leeon.gitbooks.io/devtools/content/learn_basic/overview.html\n- https://chromedevtools.github.io/devtools-protocol/\n\n### chrome - 页面层级\n- 控制台 --> 右边的三个小点 --> More Tools --> Layers\n- 页面的 3D 层级关系\n- z-index\n- 排查重绘过程（滚动过程）页面卡顿\n- https://codepen.io/Chokcoco/pen/oNdKzNX\n\n\n### Chrome 开发者工具的使用文档\n- https://developer.chrome.com/docs/devtools/network/reference/?utm_source=devtools#timing-explanation\n\n### source跨文件搜索\ncmd+option+F\n"},{"title":"generator-js-essay","url":"/2022/10/18/generator-js-essay/","content":"> git@github.com:akira-cn/bullshit-generator-js.git\n\n- 构建 - esbuild"},{"title":"ts编译之tsc和babel","url":"/2022/10/18/ts编译之tsc和babel/","content":"### tsc编译流程\n- typescript compiler\n- "},{"title":"chrome-extension-notes","url":"/2022/10/12/chrome-extension-notes/","content":"### 注册chrome开发者\n- https://chrome.google.com/webstore/developer/dashboard?utm_source=chrome-ntp-launcher&hl=zh-CN\n- manifest3 - https://developer.chrome.com/docs/extensions/mv3/intro/mv3-migration/\n- 开发文档： https://developer.chrome.com/docs/extensions/mv3/overview/\n\n### 开发指南\n- https://developer.chrome.com/docs/extensions/mv3/devguide/"},{"title":"Ioc控制反转","url":"/2022/09/27/Ioc控制反转/","content":"- https://medium.com/nmc-techblog/dip-ioc-di-know-them-better-abed5b57fd20\n- https://martinfowler.com/articles/injection.html\n\n```\n面向对象编程 - 设计原则\n控制反转（Inversion of Control，缩写为 IoC）\n降低代码之间的耦合度\n\n方式\n依赖注入（Dependency Injection）\n依赖查找（Dependency Lookup）\n\n通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体将其所依赖的对象的引用传递给它\n依赖被注入到对象中\n```\n\n\n1. InversifyJS：是一个强大且轻量的反转控制(IoC)容器，用于JavaScript和Node.js的开发，支持TypeScript。它使用了类似于Java的注解方式引入依赖，让开发者更专注于业务代码的开发。\n\n2. tsyringe：是一个轻量级的依赖注入容器，有着简洁易懂的API和易于操作的使用方式，也共享了类似Hilt的理念。它支持构造函数注入、属性注入和方法注入，大大方便了开发过程。\n\n3. NestJS：虽然它主要是一个Node.js后端开发框架，但其中内嵌了一套依赖注入系统。这个系统虽然简单，但非常灵活，可以帮助你管理项目中的各种服务和组件。\n\n4. TypeDI: 这也是一个强大的IoC容器库。它能和TypeORM，routing-controllers等库无缝集成，为开发者提供一套完整的开发解决方案。\n\n## nestjs\n- 实现了 IOC 容器\n- 从入口模块开始扫描\n- 分析 Module 之间的引用关系，对象之间的依赖关系\n- 自动把 provider 注入到目标对象\n\n- provider 一般都是用 @Injectable 修饰的 class\n- 构造器注入: 通过 provide 指定注入的 token，通过 useClass 指定注入的对象的类，Nest 会自动对它做实例化再注入\n- 属性注入: 通过 @Inject 指定注入的 provider 的 token\n- vs: 用 class 做 token 可以省去 @Inject\n- provider 的值可能是动态产生的，Nest 也同样支持(用 useFactory 来动态创建一个对象,useFactory 也支持参数的注入，支持异步)"},{"title":"数据库-3w","url":"/2022/09/24/数据库-3w/","content":"> reference： https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/gfs-sosp2003.pdf\n\n- the google file system\n\n### cases\n> 数据 - 产生-流动-持久化 - 生命周期\n\n- 持久化 -> 校验数据的合法性 - 修改内存（用高效的数据结构组织数据） - 写入存储介质（以寿命&性能友好的方式写入硬件）\n\n\n### 存储系统\n- 提供了读写，控制类接口\n- 安全有效地把数据持久化\n- user - medium - memory - network\n\n#### feature\n- 后端软件的底座，性能敏感\n- 存储系统软件架构，容易受硬件影响\n- 代码-“简单”&“复杂”\n\n#### 存储器层级结构\n- Computer Memory Hierarchy\n- size | capacity\n- 缓存 - 重要，贯穿整个存储体系\n- 拷贝 - 贵，尽量减少\n- 硬件设备五花八门，需要有抽象统一的接入层\n\n#### RAID\n- redundant array of inexpensive disks\n- 价格|写入性能|容错能力\n- 单块磁盘 vs 多块磁盘\n- RAID0|1|0+1\n\n### 数据库\n#### overview\n- 关系 - relation\n- Edgar.F.Codd于1970年提出“关系模型”\n- 关系代数 - 对关系作运算的抽象查询语言（交，并，笛卡尔积）\n- 关系 - 集合 - 任意元素组成的若干有序偶对 反应了事物间的关系\n- SQL - 一种DSL - 方便人类阅读的关系代数表达形式\n\n#### feature\n- 关系型数据库是存储系统，但是在存储之外，又发展出其他能力\n- 结构化数据友好 | 支持事务ACID | 支持复杂查询语言\n- 非关系型数据库也是存储系统，但是一般不要求严格的结构化\n\n#### 数据库 vs 经典存储\n- 结构化数据管理 （写入关系型数据库，以表形式管理 | 写入文件，自行定义管理结构）\n- 事务能力（突显出数据库支持事务的优越性）\n- 事务\n  - atomicity - 事务内的操作要么全做，要么不做\n  - consistency - 事务执行前后，数据状态是一致的\n  - isolation - 可以隔离多个并法事务，避免影响\n  - durability - 事务一旦提交成功，数据保证持久性\n- 复杂查询能力\n\n#### 数据库使用方式\n- everythining is domain specific language\n- maybe SQL\n\n### products\n#### 单机存储\n- 单个计算机节点上的存储软件系统，一般不涉及网络交互\n- 本地文件系统 | key-value 存储\n- linux - 一切皆文件\n- 文件系统的管理单元：文件\n- 文件系统接口： ext2/3/4,sysfs,rootfs等，都遵循VFS的统一抽象接口\n- index node: inode 是一个文件的唯一标识,记录文件元数据，如id，大小，权限，磁盘位置等\n- directory entry: dentry是内存结构，与inode的关系是N:1（hardlink），记录文件名，inode指针，层级关系等\n- key-value: put(k,v) & get(k)  |  LSM-tree,某种程度上牺牲读写性能，追求写入性能 | RocksDB\n\n#### 分布式存储\n- 在单机存储基础上实现了分布式协议，涉及大量网络交互\n- 分布式文件系统 | 分布式对象存储\n- HDFS - 大数据时代基石\n- Ceph - 开源分布式存储系统里的万金油\n\n\n#### 单机数据库\n- 单个计算机节点上的数据库系统\n- 事务在单机内执行，也可能通过网络交互实现分布式事务\n- 关系型 - Oracle | MySql | PostgreSQL\n```\n关系型数据库的通用组件\nquery engine - 负责解析query，生成查询计划\ntxn manager - 负责事务并发管理\nlock manager - 负责锁相关的策略\nstorage engine - 负责组织内存/磁盘数据结构\nreplication - 负责主备同步\n\n关键内存数据结构： b-tree b+-tree LRU- list\n关键磁盘数据结构： WriteAheadLog(RedoLog) Page\n```\n- 非关系型 - MongoDB | Redis | Elasticsearch\n- 不管是否关系型数据库，大家都在尝试支持SQL(子集)和“事务”\n\n\n### RDBMS 事务 ACID\n- 事务 - transaction - 一组SQL语句组成的一个程序执行单元，需要满足ACID的特性\n- ACID\n```\natomicity - 事务是一个不可再分割的工作单元，事务中的操作要么都发生，要么都不发生\nconsistency - 数据库事务不饿能破坏关系数据的完整性以及业务逻辑上的一致性\nisolation - 多个事务并发访问时，事务之间是隔离带，一个事务不应该影响其他事务运行的效果\ndurability - 在事务完成以后，该事务对数据库所做的更改便持久的保存在数据库之中，并不会被回滚\n```"},{"title":"artus-watch-notes","url":"/2022/09/19/artus-watch-notes/","content":"> https://www.yuque.com/antfe/featured/gi7ker (从 Egg 到 Artus，谈谈框架的框架的初心) \n\n- https://github.com/artusjs/core\n- https://github.com/artusjs/example.git\n\n\n```\nhttps://www.yuque.com/antfe/featured/gf0y3y\n● 更纯粹的框架的框架：提供插件复用能力及上层框架封装能力，渐进式的研发体验，初心不能忘。\n● 协议请求处理模型：不再基于 Koa，同时剥离原来的各种协议相关的内置插件，不再局限于 HTTP 场景。\n● 基于 IoC 的挂载机制，拥抱 TypeScript。\n● 基于 Manifest 的加载机制，新增构建期行为，增强企业级的扩展能力。\n```\n- https://www.yuque.com/egg/3.0/rfc-v1\n\n\n- Spec\n- https://github.com/artusjs/spec\n```\n核心设计，一定要看\n文档目录 Documentation Catalog\n格式约定\nCore Specification\n1. 架构介绍\n2. 加载机制\n3. 插件\n4. 框架\n5. 请求处理模型\n6. 异常处理\n```\n\n\n\n\n## midway 设计模式\n- https://www.midwayjs.org/docs/aspect\n```\n拦截器\n自执行代码\n流程控制\n服务工厂\n数据订阅\n数据源管理\n重试机制\n```\n- IoC"},{"title":"miniprogram-ci-summary","url":"/2022/09/14/miniprogram-ci-summary/"},{"title":"vite探索与实践","url":"/2022/09/09/vite探索与实践/","content":"https://www.yuque.com/vueconf/mkwv0c/ud1un9\n\n#### 依赖预构建 - 开发环境\n- .vite 目录下\n\n### others\n#### vite-node\n- Vite as Node runtime.\n- The engine powers Vitest and Nuxt 3 Dev SSR.\n\n### plugin-legacy\n- https://polyfill.io/v3/packages\n- https://polyfill.io/v3/url-builder\n```\nmodernPolyfills\nType: boolean | string[]\n\nDefault: false\n\nDefaults to false. Enabling this option will generate a separate polyfills chunk for the modern build (targeting browsers with native ESM support).\n\nSet to a list of strings to explicitly control which polyfills to include. See Polyfill Specifiers for details.\n\nNote it is not recommended to use the true value (which uses auto-detection) because core-js@3 is very aggressive in polyfill inclusions due to all the bleeding edge features it supports. Even when targeting native ESM support, it injects 15kb of polyfills!\n\nIf you don't have hard reliance on bleeding edge runtime features, it is not that hard to avoid having to use polyfills in the modern build altogether. Alternatively, consider using an on-demand service like Polyfill.io to only inject necessary polyfills based on actual browser user-agents (most modern browsers will need nothing!).\n```\n### vite 升级问题\n- https://v2.vitejs.dev/guide/migration.html\n- 1.8.4 有polyfill标准的问题 - 改成 proposalshipped\n- https://cn.vitejs.dev/config/build-options.html\n- https://github.com/vitejs/vite/issues/9794"},{"title":"移动端数据可视化","url":"/2022/09/09/移动端数据可视化/","content":"- https://www.yuque.com/antv/f2/intro\n- https://github.com/antvis/f2\n```\nF2，一个专注于移动，开箱即用的可视化解决方案，完美支持 H5 环境同时兼容多种环境（node, 小程序，weex）。完备的图形语法理论，满足你的各种可视化需求。专业的移动设计指引为你带来最佳的移动端图表体验。\n```"},{"title":"css-tricks-summary","url":"/2022/09/06/css-tricks-summary/","content":"\n## 一些基本的总结\n#### event偏移量\n- 相对左上角\nscreen - 屏幕 | page - 网页区域 | client - 浏览器可视区域 | offset - 父节点区域（无则是`<html>or<body>`）\n\n#### 问题分类\n- 结构 | 背景 | 点击 | 切换 | 悬浮 | 表单\n\n\n## 变量\n- 基于变量与JS通信，简化基于JS逻辑的效果\n#### 放大镜\n- scss\n- 变量（offset偏移量）随着鼠标移动而改变，offset控制伪元素的绝对定位\n- 伪元素的background实现放大镜显示内容\n- https://codepen.io/JowayYoung/pen/oNbGzPy\n- https://github.com/JowayYoung/idea-css\n\n#### 滚动渐变背景\n- event.target.scrollTop\n- 把鼠标相关参数赋值到变量中\n\n## 光影斑驳效果\nhttps://css-tricks.com/css-dappled-light-effect/\n\n\n\n#### 自动打字效果\n- https://codepen.io/JowayYoung\n\n#### 用CSS实现切换和表单效果\n## tools\n- https://codepen.io/\n- https://caniuse.com/\n- https://csstriggers.com/\n- https://cubic-bezier.com/\n- https://xluos.github.io/demo/flexbox/\n- https://gs.statcounter.com/\n"},{"title":"框架风格-decorator-egglike-function","url":"/2022/09/03/框架风格-decorator-egglike-function/"},{"title":"网络协议-summary","url":"/2022/08/11/网络协议-summary/","content":"### 容器网络\n\n#### 容器的思想\n- 变成软件交付的集装箱\n- 一是打包\n- 二是标准\n\n#### 封闭的环境：\n1. 看起来是隔离的技术：namespace，也即每个 namespace 中的应用看到的是不同的 IP 地址、用户空间、程号等。\n2. 用起来是隔离的技术：cgroup，也即明明整台机器有很多的 CPU、内存，而一个应用只能用其中的一部分。\n\n\n#### 标准：镜像\n\n\n#### 命名空间（namespace）（ip netns）\n至此为止，基于网络 namespace 的路由器实现完毕。\n\n#### 机制网络（cgroup）\n- cgroup 全称 control groups，是 Linux 内核提供的一种可以限制、隔离进程使用的资源机制。\n\n- net_cls，这个子系统使用等级识别符（classid）标记网络数据包，可允许 Linux 流量控制程序（tc）识别从具体 cgroup 中生成的数据包。cgroup 提供了一个虚拟文件系统，作为进行分组管理和各子系统设置的用户接口。要使用 cgroup，必须挂载 cgroup 文件系统，一般情况下都是挂载到 /sys/fs/cgroup 目录下。\n\n\n- 容器是一种比虚拟机更加轻量级的隔离方式，主要通过 namespace 和 cgroup 技术进行资源的隔离，namespace 用于负责看起来隔离，cgroup 用于负责用起来隔离。\n\n- 容器网络连接到物理网络的方式和虚拟机很像，通过桥接的方式实现一台物理机上的容器进行相互访问，如果要访问外网，最简单的方式还是通过 NAT。\n\n\n\n### 网络基础\n- 寻址和路由 ｜ 数据链路 ｜ 分片 ｜ 序列码 ｜ 封装 ｜ 拥塞控制 \n- 错误检测和校正 ｜ 数据重发 ｜ 重组\n\n#### 协议\n- 解决如何的问题\n- 不同协议处理不同层次的问题\n- 使用相同的协议\n- ISO - open system interconnection  reference model\n- OSI｜Rmodel\n- ISP｜ IEC 7489-1\n- 主机层 - 应用，表示，会话，传输\n- 网络各个节点之间\n"},{"title":"运维相关-notes","url":"/2022/08/10/运维相关-notes/","content":"- falcon\n- https://book.open-falcon.org/zh_0_2/intro/\n- 从falcon逐步调整到Prometheus了"},{"title":"unifiedjs-notes","url":"/2022/08/10/unifiedjs-notes/","content":"- https://unifiedjs.com/\n- Content as structured data\n\n```\nunified is two things:\n\nunified is a collective of 500+ free and open source packages that work with content as structured data (ASTs)\nunified is the core package to inspect and transform content with plugins\nDifferent kinds of content can be connected together. Particularly, markdown, natural language, HTML, XML, and JavaScript are frequently used.\n\nfor more about us, see unifiedjs.com\nfor how the collective is governed, see unifiedjs/collective\nfor updates, see @unifiedjs on Twitter\n```"},{"title":"操作系统相关-notes","url":"/2022/08/10/操作系统相关-notes/","content":"\n###\n#### 互斥量 \n广义 - 实现互斥作用的同步机制\n狭义 - mutex 二元锁机制\n作用 - 互斥 - mutual exclusive, 保护临界区（critical section）\n- https://www.coursera.org/lecture/os-pku/xin-hao-liang-ji-pvcao-zuo-sbhMU"},{"title":"压测","url":"/2022/07/27/压测/","content":"### jmeter \nhttps://jmeter.apache.org/"},{"title":"JavaScriptCore","url":"/2022/07/20/JavaScriptCore/","content":"- https://tech.meituan.com/2018/08/23/deep-understanding-of-jscore.html\n- https://developer.apple.com/documentation/javascriptcore\n- https://github.com/WebKit/WebKit/tree/main/Source/JavaScriptCore\n\n### JavaScriptCore 框架\nIOS7 - for OC && JS 交互\nApple 提供了OC的封装接口\n```\niOS7之后，苹果对WebKit中的JSCore进行了Objective-C的封装，并提供给所有的iOS开发者。JSCore框架给Swift、OC以及C语言编写的App提供了调用JS程序的能力。同时我们也可以使用JSCore往JS环境中去插入一些自定义对象\n```\n\n\n\n\n### JavaScriptCore 引擎\nSafari - JS引擎\n\n\n## acorn\n- https://www.npmjs.com/package/acorn\n- A tiny, fast JavaScript parser written in JavaScript.\n\n"},{"title":"服务基础-CS-状态","url":"/2022/07/18/服务基础-CS-状态/","content":"- 状态\n- 有状态\n- 无状态\n- 池化\n\nhttps://blog.csdn.net/qq_30154571/article/details/89017817 - 有状态｜无状态服务\n\n### 无状态架构\n- 大多数现代软件都是以无状态的方式进行架构的-扩展是大型服务一个必不可少的因素\n- 无状态的可扩展性更强，当你有更多的流量时，很容易通过扩展通过增加 更多的服务器来服务更多用户。\n- 开发者犯的错误更少，不用考虑内存泄漏(由于每次请求都会创建和销毁all)的问题。\n- 创建无状态应用更简单，开发人员不必过多考虑如何管理应用层的状态\n- 无状态设计是可扩展的。所有的状态都保存在外部存储中\n\n- 数据库和缓存是有状态的，并附加了持久化的存储\n- 应该根据应用需求选择单体或者微服务。\n- 有些状态可以在应用内部存储和重用；其他一些状态可以作为外部状态。\n- 无状态响应如 HTTP响应总是可以被大多数缓存服务器如 Varnish或 Nginx 和 CDN缓存\n```\n可以将系统的工作负载分派给负载均衡器，然后将工作负载平均分配给多个相同的无状态服务器以扩大或缩小系统的规模。 \n对于这种类型的系统，可以使用多种负载平衡算法。 \n如果服务器大小不同，则采用加权轮询； 如果每个服务器的性能都不相同并且请求的资源消耗没有太大变化，可以选择连接最少。 \n根据系统的要求，也可以使用其他的负载均衡算法。\n```\n#### 问题\n- 有些状态不能在不同请求之间共享。这些可共享状态的构建可能非常昂贵，比如从数据库中获取变量或者从远程服务器中获取变量。在无状态设计中，这些变量在每个请求中都要反复创建和销毁。\n- 外部存储可能无法随着进程数量的增加而扩展。建立过多的数据库连接可能会明显降低性能。我们可能需要一个中间层代理来限制与数据库的最大连接数，但这也会降低整体性能，因为有一个中间层成本。\n\n#### summary\n- 扩展性\n- 在外部保存状态而导致性能下降\n```\n通过对系统的一个组件进行不同的域划分，有状态组件也可以被看作是无状态组件。\n如果组件保持状态仅是高速缓存数据，则可以将一个有状态系统视为无状态组件。 正确而明智地管理状态是将系统性能提高10倍至100倍的关键。\n这种做法适用于许多现代软件架构，例如微服务。\n在这种情况下，每个组件都独立执行特定的功能，它们之间通过网络通信（如HTTP、gRPC等）进行数据交换。每个组件都可以独立扩展和部署，系统的整体负载由这些分散的组件共同承担，从而提高了系统的可伸缩性、可维护性和可用性。\n```\n```\n在分布式系统中，如果组件仅使用高速缓存暂时存储数据，并且在组件之间没有严格的数据共享需求，可以将其视为近似无状态组件。缓存的作用是提高性能，而不是永久存储状态。\n如果组件依赖高速缓存来存储重要状态信息，那么它实际上仍然是有状态组件。该组件需要缓存中的数据来恢复状态，以便在应用程序中正确执行操作。\n```\n```\n将有状态组件拆分为无状态组件可以带来许多优点，但在实际操作时需要注意以下事项：\n\n这种做法可能增加了组件之间的通信开销。\n需要对每个组件进行独立的管理和维护。\n部署和配置可能较为复杂。\n组件之间的依赖关系可能导致系统脆弱性。\n系统的整体复杂性可能会提高。\n```\n\n### 无状态模型\n无状态模型的一个问题是它浪费了资源来重建上下文来服务每个请求。这可能包括建立新的连接到远程服务和从数据库中获取数据。这些过程可能有多轮。\n在无状态模型中，有很多资源被浪费在建立执行上下文和建立依赖数据来处理实际的请求逻辑\n\n- 问题：\n1.  我们不重用可重用的变量，是否在浪费资源？ \n2.  我们每次请求都会从数据库中请求相同的没有变化的数据吗？ \n3.  我们是否在请求当前请求没有使用的数据？ \n4.  我们是否可以将远程数据缓存到本地？ \n5.  我们是否可以使用异步 I/O 而不是阻塞 I/O 来节省进程数量？ \n6.  我们是否可以将重任务推迟，将它们送入队列，另外执行\n\n\n### 性能问题\n性能问题也是我们互联网项目中最难解决的问题。第一步总是要找出整个系 统的瓶颈，避免局部优化\n。通过对状态复用的优化，我们可以看到 性能上的重大提升。性能问题与如何管理本地或远程的状态以及访问状态的 成本有关。\n"},{"title":"pythonVSnode图像识别及word操作","url":"/2022/07/18/pythonVSnode图像识别及word操作/","content":"设计模式：\n代码封装得越“高级”，解决的问题就越具体？？？（os:存疑\n越深入计算机底层，解决的问题就越通用\n\n冯诺伊曼计算机体系\n\n\t•\t冯诺伊曼体系：输入设备、存储器、控制单元、运算单元、输出设备\n\npython自动化办公体系\n\n输入：解决不同文件类型的批量合并和拆分\n运算：扩展常用的统计，搜索和排序功能\n控制：通过插件的方式增强办公软件以及周边软件，硬件的交互能力\n存储：和文件相关的很多常用的操作部分\n输出：智能化输出自动工作成果\n\n###\n- https://github.com/wilsonyin123/geekbangpython"},{"title":"bluetooth-miniprogram","url":"/2022/07/18/bluetooth-miniprogram/","content":"https://zhuanlan.zhihu.com/p/405202290 - 抓包\n\n## 蓝牙相关\n### 蓝牙设备\n- GATT 协议的低功耗设备 - 通过标准的 Web Bluetoot h API 进行通信，而 Chrome 浏览器已经支持了这个 API，所以我们可以直接使用这个 API 进行通信。\n- SPP 协议的设备 - 不能直接使用 Web Bluetooth API 进行通信，需要通过 Node.js 来实现一个蓝牙串口服务，然后通过这个服务来进行通信。\n\n- SPP 协议是一种基于串口的蓝牙通讯协议，它的特点是：\n\n串口通讯协议，即数据以字节流的形式传输，没有数据帧的概念。\n通讯速率较低，一般为 9600bps。\n通讯距离较短，一般为 10 米以内。\n \n通讯稳定性较高，一般不会出现数据丢失的情况。\n通讯延迟较低，一般为 10ms 以内。\n- https://github.com/tinyprinter/node-bluetooth-serial-port\n\n\n## 封装基类\n- Bluetooth"},{"title":"swoole-comparison","url":"/2022/07/16/swoole-comparison/","content":"- https://www.swoole.com\n- "},{"title":"Fedora-Setup","url":"/2022/07/14/Fedora-Setup/","content":"### dev\n- vscode\n- chrome\n\n\n\n### basic\n#### VPN\n- clashy - appimage客户端有点问题（）\n\n#### shortCut\n- 基本的复制粘贴 - 保证和Mac体验接近\n#### 远程控制\n- teamviewer - 有官方支持的版本 - https://www.teamviewer.cn/\n\n### 目前有问题的软件\n- 百度云盘 - 官方提供的rpm包不可用\n\n### Documents\n- https://docs.fedoraproject.org/en-US/fedora/latest/system-administrators-guide/Preface/\n\n\n### network\n```\nclient:\ntar xzvf xxx-x64-linux.tar.gz\ncd xxx-x64-linux\n./xxx(abbr)\n\nif clash\nprofiles \ndownload from a url\nallow LAN\nsystem proxy\nstart with linux\n\nsystem:\nnetwork proxy\nmanual\n\nhttp proxy LAN xxxx(port)\nhttps proxy LAN xxxx(port)\n```\n\n### keymapping\n- 哈哈，这个很重要，能避免mac和fedora使用时候，ctrl和cmd键的人工大脑切换，提高效率，降低切换成本\n- sudo dnf install gnome-tweaks\n- tweaks - Additional layout options - alt and win behavior - ctrl is mapped to win and the usual ctrl\n- 然后如果是想要控制别的，就可以使用系统提供的快捷键配置\n### wayland\n\n\n### 字体显示问题\n- 先是系统语言设置为了英文，这种情况下的中文渲染不是简体字，切换为中文系统语言，保留之前英文的文件夹命名\n\n#### rpm\n- https://docs.fedoraproject.org/en-US/fedora/latest/system-administrators-guide/RPM/\n\n#### wayland\n- https://docs.fedoraproject.org/en-US/fedora/latest/system-administrators-guide/Wayland/\n- 先是系统语言设置为了英文，这种情况下的中文渲染不是简体字，切换为中文系统语言，保留之前英文的文件夹命名\n"},{"title":"XSS","url":"/2022/07/14/XSS/","content":"## baiscs\n- Cross_Site_Scripting\n- \n\n\n- 安全组建议 - 整站过滤\n```\n一些cases：\n- 过滤\"<\"、\">\"将用户输入放入引号间，基本实现数据与代码隔离\n- 过滤单引号和双引号防止用户跨越许可的标记，添加自定义标记\n- 过滤TAB和空格,防止关键字被拆分\n- 过滤script等关键字\n- 过滤&#,防止HTML属性绕过检查\n```\n- https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html#introduction\n\n### Vue\n- https://vuejs.org/guide/best-practices/security.html (里面有各种情况，及best practices)\n- https://github.com/LeSuisse/vue-dompurify-html\n- https://www.npmjs.com/package/xss\n- 以上，可以配合使用，核心规则是 - 不要用v-html 渲染不可信的内容\n```\nRule No.1: Never Use Non-trusted Templates#\nThe most fundamental security rule when using Vue is never use non-trusted content as your component template.\n```\n\n### 渗透测试\n- OWASP ZAP\n- "},{"title":"WSL-summary","url":"/2022/07/12/WSL-summary/","content":"- https://docs.microsoft.com/zh-cn/windows/dev-environment/javascript/nodejs-on-wsl\n\n\n### 微软有出一系列教程\n- https://learn.microsoft.com/zh-cn/windows/wsl/tutorials/wsl-containers\n\n### win11上键盘修改为和Mac一致\n- https://blog.csdn.net/weixin_44839047/article/details/126166602"},{"title":"file-system-routing","url":"/2022/07/07/file-system-routing/","content":"## nuxt\n- https://nuxtjs.org/docs/features/file-system-routing/\n\n## vue-plugin-pages\n- https://github.com/hannoeru/vite-plugin-pages"},{"title":"pandora-使用summary","url":"/2022/07/06/pandora-使用summary/"},{"title":"sentry-问题处理-summary","url":"/2022/07/05/sentry-问题处理-summary/","content":"#### 1\nResizeObserver loop limit exceeded\nhttps://github.com/ElemeFE/element/issues/11420#issuecomment-898992179\nel-scrollbar\n```\nmain.js\nmounted() {\n  if (this.native) return;\n  this.$nextTick(this.update);\n  !this.noresize && addResizeListener(this.$refs.resize, this.update);\n},\n\nexport const addResizeListener = function(element, fn) {\n  if (isServer) return;\n  if (!element.__resizeListeners__) {\n    element.__resizeListeners__ = [];\n    element.__ro__ = new ResizeObserver(resizeHandler);\n    element.__ro__.observe(element);\n  }\n  element.__resizeListeners__.push(fn);\n};\n```\n#### 2\nchrome - 102\nEvalError: Possible side-effect in debug-evaluate\n\nhttps://stackoverflow.com/questions/72396527/evalerror-possible-side-effect-in-debug-evaluate-in-google-chrome\n\nconsole => 设置 => eager evaluation\n\nhttps://chromium-review.googlesource.com/c/v8/v8/+/3557234/\nhttps://chromium-review.googlesource.com/c/v8/v8/+/3660253\n\n\n- SyntaxError ?(<unknown module>)\nUnhandled\nUnexpected end of input\n在EvalError: Possible side-effect in debug-evaluate 之后\n\n\n### sourcemap 上传问题\n- https://docs.sentry.io/platforms/javascript/guides/vue/sourcemaps/troubleshooting_js/\n- sentry-cli 上传的时候\n- 先排除本身map的问题，及上传的问题（可以通过本地看map的解析及上传log日志里面的信息，sentry管理端上面的文件确认）\n- 确保路径的匹配，按照上面的文档\n\n### 关注API的变化\n- https://github.com/getsentry/sentry-javascript/blob/7.47.0/MIGRATION.md/#remove-requirement-for-sentrytracing-package-since-7460\n\n### @sentry/vue\n相比于 `@sentry/browser`，`@sentry/vue` 专为 Vue.js 应用程序量身定制，提供了更好的 Vue.js 集成和错误跟踪。以下是 `@sentry/vue` 相对于 `@sentry/browser` 的一些优势：\n\n1. Vue 错误处理器\n\n`@sentry/vue` 提供了一个全局的 Vue 错误处理器，会自动捕获并报告 Vue.js 的渲染错误、生命周期错误和自定义方法中的错误。这意味着您无需手动在组件内部捕获和报告错误。\n\n2. Vue 插件集成\n\n`@sentry/vue` 作为一个插件可以轻松地集成到 Vue 应用程序中。在配置时，只需传入您的 Sentry DSN（数据来源名称），插件就会自动捕获和报告错误。\n\n示例配置:\n\n```javascript\nimport Vue from 'vue';\nimport * as Sentry from '@sentry/vue';\nimport { Integrations } from '@sentry/tracing';\n\nSentry.init({\n  Vue: Vue,\n  dsn: 'your_sentry_dsn',\n  integrations: [\n    new Integrations.BrowserTracing(),\n  ],\n  tracingOptions: {\n    trackComponents: true, // 追踪 Vue 组件性能\n  },\n});\n```\n\n3. Vue.js 上下文信息\n\n错误报告中的上下文信息对于调试非常重要。 `@sentry/vue` 会自动为每个错误报告附加与 Vue 组件相关的附加信息（例如，组件名称，组件层次结构等）。这使得错误报告更有上下文，方便您快速排查问题。\n\n4. Vue.js 性能追踪\n\n`@sentry/vue` 提供了 Vue.js 组件性能追踪功能。通过轻松配置，Sentry 可以追踪和测量组件性能，帮助您了解每个组件的渲染时间和性能瓶颈。\n\n简而言之，`@sentry/vue` 在 `@sentry/browser` 的基础上，提供了适用于 Vue.js 应用程序的专有功能，使得错误报告更加详细和有用。使用 `@sentry/vue`，您可以轻松地集成 Sentry 到 Vue 应用中，实现准确的错误追踪和性能分析。\n\n#### vendor/components.ts\n- https://github.com/vuejs/vue/blob/612fb89547711cacb030a3893a0065b785802860/src/core/util/debug.js\n- // Vendored from https://github.com/vuejs/vue/blob/612fb89547711cacb030a3893a0065b785802860/src/core/util/debug.js\n- // with types only changes.\n\n\n### @sentry/react\\\n在 `@sentry/browser` 的基础上，`@sentry/react` 提供了为 React 应用程序量身定制的附加错误处理和性能跟踪功能。以下是相比于 `@sentry/browser`，`@sentry/react` 中提供的一些重要增强功能：\n\n1. **错误边界（ErrorBoundary）**：用于捕获 React 组件树中未捕获的错误。通过使用 `withErrorBoundary` 高阶组件（HOC）或 `<ErrorBoundary>` 组件包装 React 组件，可以捕获组件发生的错误，并将它们自动地报告给 Sentry。\n\n2. **性能跟踪**： `@sentry/react` 为 React 应用提供了特定的性能跟踪工具，用于更细粒度地测量组件性能。在 React 应用程序中，`@sentry/react` 自动为普通的 React 组件测量渲染性能。你只需在应用程序中包含 `@sentry/react` 插件即可。此外，`@sentry/react` 还提供了用于手动测量性能的工具，例如：`withProfiler` 高阶组件（HOC）和 `<Profiler>` 组件。\n\n3. **集成**： `@sentry/react` 包含了一些与开发环境的 React 扩展的集成。例如，`@sentry/react` 自动与 `create-react-app` 进行了集成，以方便地构建和部署错误报告和性能跟踪功能。\n\n下面是一个简单的错误边界示例：\n\n```javascript\nimport React from 'react';\nimport { withErrorBoundary } from '@sentry/react';\n\nconst MyComponent = () => {\n  // Your component logic...\n};\n\nexport default withErrorBoundary(MyComponent, {\n  fallback: <div>Oops! An error occurred.</div>,\n  showDialog: true,\n});\n```\n\n这片代码在 React 组件中引入了错误边界，当组件发生错误时，会自动报告给 Sentry 并显示一个默认的降级 UI。\n\n### linux 下载\n- 切下源\nnpm set ENTRYCLI_CDNURL=https://cdn.npm.taobao.org/dist/sentry-cli\nnpm set sentrycli_cdnurl=https://cdn.npm.taobao.org/dist/sentry-cli"},{"title":"skywalking-cases","url":"/2022/07/05/skywalking-cases/","content":"\n## background\n- 从听云换到skywalking\n(服务trace探针)\n\n## nodejs\nhttps://github.com/apache/skywalking-nodejs\n\n## client-js\n- https://github.com/apache/skywalking-client-js/releases\n注意依赖版本\n\n## Skywalking之Java Agent基础\n- https://cloud.tencent.com/developer/article/1521715"},{"title":"服务发现框架","url":"/2022/07/01/服务发现框架/","content":"## 服务通信框架 ｜ 中间件的现状和选型\n\n### Eureka\n- https://github.com/Netflix/eureka/wiki\n\n### nacos\n- https://github.com/alibaba/nacos/wiki\n```\nEureka 2.0（已停止）。\n关于eureka 2.0的现有开源工作已经停止。作为2.x分支现有工作库的一部分而发布的代码库和artifacts，使用起来风险自负。\nEureka 1.x是Netflix的服务发现系统的核心部分，仍然是一个活跃的项目。\n```\n\nNacos Sync是一款开源的集群同步系统，可用于在不同类型的服务注册发现平台之间进行服务信息的同步，例如Nacos，Zookeeper，Eureka，Consul等。\n\n一些Nacos Sync的关键功能包括：\n\n服务同步：可以在不同类型的服务注册发现中间件间同步服务列表。\n\n集群同步：可用于在相同类型的服务注册发现中间件间同步服务列表，例如Nacos集群之间。\n\n服务数据映射：在同步服务数据过程中，通过映射函数可以改变或定义特定的同步数据。\n\n机器快照：Nacos Sync提供了快照机制，可以在出现问题时，进行数据恢复。\n\n系统健康指标：Nacos Sync提供监控指标，可以在出现问题时及时监控和报警。\n\n使用Nacos Sync，在分布式、微服务架构环境中可以实现平滑过渡，无需担心服务注册发现中间件的切换问题。使用Nacos Sync也可以保证在多个集群间服务数据的一致性。\n\nNacos Sync单点风险+添加服务自启动\n### consul\n- Prometheus采集metric对于consul的支持\n\n### 对比\n- CAP模型 ｜ 客户端更新服务信息 ｜ 伸缩性 ｜ 健康检查模式 ｜ 负载均衡 ｜ 手动上下线服务方式 ｜ 跨中心同步 ｜ K8s集成 ｜ 分组 ｜ 权重\n\n\n\n## conclusion\n### 比较维度\n- 功能 ｜ 部署 ｜ 长远支持和发展趋势 ｜ 伸缩性和扩展性 ｜ 支撑项目和环境 ｜ 性能\n### all \n- 技术框架的统一和建设\n- 中间件选型和稳定性由框架保障和解决，对上层业务开发透明\n\n## Others\n### Netflix家的\n- Hystrix是一个延迟和容错库，旨在隔离对远程系统、服务和第三方库的访问点，阻止级联故障，并在故障不可避免的复杂分布式系统中实现复原力。\n- Ribbon是一个进程间通信（远程过程调用）库，内置软件负载均衡器。主要的使用模式涉及REST调用和各种序列化方案的支持。"},{"title":"COS-OSS-云点播-使用经验","url":"/2022/06/30/COS-OSS-云点播-使用经验/","content":"\n```\nhttps://cloud.tencent.com/document/product/436/31315\n通过互联网测试的说明\n由于通过互联网访问 COS 会经过运营商网络，运营商网络可能禁止您使用 ICMP 协议的ping或traceroute等工具来测试连通性，因此建议使用 TCP 协议的工具来测试连通性。\n\n注意：\n通过互联网访问可能受到多种网络环境的影响，如有访问不畅的情况，请排查本地网络链路或联系当地运营商进行反馈。\n\n若您的运营商允许 ICMP 协议，您可以使用ping、traceroute或mtr工具来检视您的链路状况。运营商不允许使用 ICMP 协议，您可以使用psping（Windows 环境，请前往微软官网下载）或tcping （跨平台软件）等工具进行时延测试。\n\n通过内网测试的说明\n如果您通过同地域的腾讯云 VPC 网络来访问对象存储 COS，则可能无法使用 ICMP 协议的ping或traceroute等工具来测试连通性。建议您使用基本连通测试中的telnet命令进行测试。\n\n您亦可尝试使用psping或tcping等工具直接对访问域名的80端口进行时延测试，请在测试前确保已通过nslookup命令查询并确认访问域名已正确解析至内网地址。\n```"},{"title":"product-lib-notes-update","url":"/2022/06/28/product-lib-notes-update/","content":"## 产品\n#### 企业内部协同工具\n- Rewatch让你安全地保存、管理和搜索你的所有视频内容，以便团队更快协作，工作变得更好\n- https://rewatch.com/\n- SasS\n- We shape our tools, thereafter our tools shape us.\n\n#### 语雀\n- 首页设计 - 对外 - https://www.yuque.com/about\n\n## 库\n#### 思维导图\n- https://www.npmjs.com/package/@arvinxu/mindflow\n\n\n#### SQL 审核查询平台\n- https://github.com/bytebase/bytebase\n\n\n#### CSS\n- https://github.com/Dogfalo/materialize"},{"title":"typescript-and-graphql","url":"/2022/06/13/typescript-and-graphql/","content":"### 如果缺少类型校验，比较危险的场景\n```\n- fetch('/api/*')\n从客户端发送到API的payload\n从API返回给客户端的payload\n- sql.query('SELECT * from things') (或其他类似的东西)\n发送给数据库的query\n从数据库返回给API的result set\n```\n\n### 携程基于GraphQL的BFF实践\nhttps://mp.weixin.qq.com/s/q05JeUZ0mfjhhCshhhPNtw\n\n## GraphQL\n- Facebook\n- 自定义查询数据\n\n\n#### frameworks\n- koa-graphql\n- nestjs/graphql\n\n### npm\n- https://github.com/graphql\n\n### test-demo\n@apollo/server \n@apollo/client\n\n#### Queries\n#### Mutations\n\n## 思想～～\nhttps://graphql.org/learn/thinking-in-graphs/\n\nDSL\n\n### Javascript Server\nhttps://graphql.org/code/#javascript-server"},{"title":"TDesign-各端解决方案-reference","url":"/2022/05/12/TDesign-各端解决方案-reference/","content":"> For 归类 ｜ 参考 ｜ 设计指导\n\n## 小程序\n\n### 组件\n- https://tdesign.tencent.com/miniprogram/overview\n\n#### 归类\n- 基础 Button | Divider | Fab | Icon\n- 导航 Drawer | Indexed | Navbar | Steps | TabBar | Tabs\n- 输入 CheckBox | DateTimePicker | Input | Picker | Radio | Rate | Search | Slider | Stepper | Switch | Textarea | UpLoad\n- 数据展示 Avatar | Badge | Cell | Collapse | CountDown | DropdownMenu | Empty | Footer | Grid | Image | ImageViewer | Skeleton | Sticky | Swiper | Tag\n- 消息提醒 ActionSheet｜ BackTop | Dialog | Loading | Message | NoticeBar | Overlay | Popup | Progress | PullDownRefresh | SwipeCell | Toast\n\n\n### 中后台设计指南\n- 如何搭建整体框架\n- https://tdesign.tencent.com/design/offices\n- 如何设计高频任务\n- https://tdesign.tencent.com/design/offices-task"},{"title":"小程序-basic","url":"/2022/05/09/小程序-basic/","content":"\n#### 来源\n```\n​微信面临的问题是如何设计一个比较好的系统，使得所有开发者在微信中都能获得比较好的体验。这个问题是之前的 JS-SDK 所处理不了的，需要一个全新的系统来完成，它需要使得所有的开发者都能做到：\n\n- 快速的加载\n\n- 更强大的能力\n\n- 原生的体验\n\n- 易用且安全的微信数据开放\n\n- 高效和简单的开发\n\n这就是小程序的由来。\n```\n#### 运行环境\n```\n表1-1 小程序的运行环境\n\n运行环境\t逻辑层\t渲染层\niOS\tJavaScriptCore\tWKWebView\n安卓\tV8\tchromium定制内核\n小程序开发者工具\tNWJS\tChrome WebView\n```\n\n## 开发工具\n- 代码提示\n- 设置 - 编辑设置\n- 真机调试 - 发给第三方（用户）\n- 预览 - 自己用\n- 详情 - 本地设置 - 看基本库版本\n\n### 路由\n- https://developers.weixin.qq.com/miniprogram/dev/api/route/wx.switchTab.html\n\n### 组件｜接口\n- 设计的边界\n\n## 运行机制\n- 热启动｜冷启动 - 缓存｜getupdateManager \n- 主动销毁 - 内存警告｜进入后台一定时间\n- 前台状态｜后台状态\n\n### 双线程架构\n- why - 安全+管控\n- View - 视图线程 && App Service - 逻辑线程\n- View | App Service | Native\n- view - Page(WXML|WXSS)\n- App Sevice - Manager | API\n- Native - 微信能力｜离线存储｜网络请求｜JSBridge\n- Event | Data\n\n#### setData\n- evaluateJavaScript实现的(hybrid也是)\n- （安卓）可能页面卡顿（界面滑动中 - 视图线程 - 渲染中）是由evaluateJavaScript导致的\n-  逻辑层发来的请求阻塞了，阻塞超过200MS就会有卡顿的感觉\n#### ios\n- wkwebview - 内存紧张，wkwebview会被回收，所以一些历史页面我们回不去\n\n#### wxs\n- https://www.zhihu.com/question/64732764/answer/316980141\n- wxs不依赖于运行时的基础库版本 - 可以在所有小程序版本里面运行\n- 运行在View线程里\n- 提高View层运行效率\n- 运行环境和其他JS代码是隔离的\n- IOS上效率高，android上面和JS没啥差别\n- 应用场景 - 如何提高效率\n\n#### 视图线程\n- 编译原理\n- 小程序视图层是在polymer基础上，基于web component 标准实现的\n- 类似Vue的实现\n- 原生在vw上面\n- 生命周期\n\n#### 逻辑线程\n- 初始化｜等待激活｜激活｜后台运行 - 四个状态\n\n## wxss\n- 选择器，不断发展中\n- rpx\n- 字体配置跟着系统走\n- 小程序 app.wxss可以设置全局样式 - 字体等 - ```page { font-family: \"xxx\" }```\n- 全局样式表里面设置的样式 - 可以被组件继承的 - font|color (见官方文档)\n- 页面和组件的概念要分清楚\n- 文件间距可以用line-height消除空白\n\n## 事件\n### tap\n- bind:tap 一般不阻止点击事件的冒泡\n- catch:tap\n\n## 组件\n\n### icon组件\n\n\n### 自定义组件\n\n\n\n\n\n## notes\n- 支付框不会触发App的onHide\n- 转发和分享到朋友圈会执行App的onHide\n\n\n## 微信清除web缓存\n- Android\n```\n按提示来就行，如果不支持切换X5内核，此方法不通\n1.http://debugx5.qq.com\n2.http://debugtbs.qq.com/\n3.debugmm.qq.com/?forcex5=true \n\n我的 - 微信\n```\n\n## 小程序宿主环境 - 渲染层和逻辑层\n- https://developers.weixin.qq.com/miniprogram/dev/framework/quickstart/framework.html#%E6%B8%B2%E6%9F%93%E5%B1%82%E5%92%8C%E9%80%BB%E8%BE%91%E5%B1%82\n\n### 设计原理\n- https://juejin.cn/post/6844903669389852685"},{"title":"小程序-数据分析","url":"/2022/05/09/小程序-数据分析/","content":"> 不特指，默认为微信小程序-mini program\n\n## 数据分析\n### 基本概念\n- https://developers.weixin.qq.com/miniprogram/analysis/#%E5%B8%B8%E8%A7%84%E5%88%86%E6%9E%90\n#### 常规分析\n- \n\n#### 自定义分析\n\n### We分析\n\n\n#### 小程序测速\n\nhttps://developers.weixin.qq.com/miniprogram/dev/framework/performanceReport/\n\n\n## keys\n#### setData\n- 合理使用 setData\n- https://developers.weixin.qq.com/miniprogram/dev/framework/performance/tips/runtime_setData.htmlc\n- 开发者可以通过组件的 setUpdatePerformanceListener 接口获取更新性能统计信息，来分析产生性能瓶颈的组件 \n- https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/update-perf-stat.html\n\n\n## 基础库版本分布\n- https://developers.weixin.qq.com/miniprogram/dev/framework/client-lib/version.html\n- 判断一些低版本库导致的问题时候，做参考用\n\n## 告警群\n- 性能 We\n- Error 告警群\n\n以上两个，可以具体配置告警策略"},{"title":"悲观事务模型","url":"/2022/04/29/悲观事务模型/","content":"> 之前我们这边服务端老师问运维的老师，tidb 升了之后，默认是悲观事务，问有没有什么影响，和mysql的区别\n\n- “5.0以后我们默认提供悲观事务，性能在事务冲突严重的情况下优于乐观事务，无法冲突情况下跟乐观事务性能基本一样。也可以跟乐观事务开发规范一样，尽量从业务侧减少冲突的行为。”\n\n\n### TiDB 悲观事务模型 - 和 MySQL InnoDB 的差异\n\n- https://docs.pingcap.com/zh/tidb/v5.0/pessimistic-transaction#%E5%92%8C-mysql-innodb-%E7%9A%84%E5%B7%AE%E5%BC%82\n\n#### innodb\n- https://blog.jcole.us/innodb/\n- https://github.com/jeremycole/innodb_ruby\n\n\n### TiDB 性能压测\n- TiDB 5.0 GA 悲观事务的压测\n- Sysbench 性能对比测试报告\n- 点查场景 ｜ 只读场景 ｜ 只写场景 ｜ 读写场景 ｜ 非索引更新场景 ｜ 索引更新场景 "},{"title":"数据库范式","url":"/2022/04/29/数据库范式/","content":"> Database normalization was introduced as a procedure by Edgar Frank Codd, a computer scientist at IBM in his paper, A Relational Model of Data for Large Shared Data Banks in 1970. Database normalization is a process by which an existing schema is modified to bring its component tables into compliance through a series of progressive normal forms.\n\n### Basic\n- https://en.wikipedia.org/wiki/Database_normalization#Normal_forms\n- 数据库的表设计的基础（关系型数据库模型）\n- 范式 - normal form\n- 范式程度越高阶，冗余度越低\n- 小心过度解耦 - 拆出过多的表 - 认知负担｜I/O性能｜影响查询效率\n- trade-on\n\n### examples\n- https://en.wikipedia.org/wiki/Database_normalization#Normal_forms\n- 示例可以直接看wiki里面的\n- 尽量满足3 NF\n\n### 1 NF\n- 属性值不可再分\n- 原子性\n\n### 2 NF\n- 去除局部依赖\n- 如果不处理，会有什么问题（冗余 ｜ 插入/删除/更新异常）\n\n### 3 NF\n- 去除非主属性的传递依赖\n\n### 其他\nhttps://shardingsphere.apache.org/document/current/cn/overview/\n设计哲学\nShardingSphere 采用 Database Plus 设计哲学，该理念致力于构建数据库上层的标准和生态，在生态中补充数据库所缺失的能力。"},{"title":"微信网页开发-summary","url":"/2022/04/28/微信网页开发-summary/","content":"> 2015年初，微信发布了一整套网页开发工具包，称之为 JS-SDK，开放了拍摄、录音、语音识别、二维码、地图、支付、分享、卡券等几十个API.​JS-SDK是对之前的 WeixinJSBridge 的一个包装，以及新能力的释放，并且由对内开放转为了对所有开发者开放\n\n- https://developers.weixin.qq.com/miniprogram/dev/framework/quickstart/#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%8A%80%E6%9C%AF%E5%8F%91%E5%B1%95%E5%8F%B2\n- 上面是 - 小程序技术发展史\n\n- https://fjc0k.github.io/vtils/\n\n- https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/Wechat_Open_Tag.html#21\n- https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/url-scheme/urlscheme.generate.html\n\n#### webview ua\n- 和微信内打开网页一样，ua情况\n- https://developers.weixin.qq.com/doc/offiaccount/WiFi_via_WeChat/WiFi_Hardware_Authentication_Protocol_Interface_Description.html\n```\n2. 如何识别 http 请求是否来自微信客户端\n在 http 数据包的 header 结构中解析“User-Agent”即可，判断是否包含关键字“micromessenger”（这里请注意不要拦截其他微信 http 请求，所以关键词请匹配好），示例代码如下：\nString userAgent = request.getHeader(\"User-Agent\");\nif(userAgent.matches(\".*micromessenger.*\")){  response.sendRedirect(\"http://www.foo.com/portal/portal.html?authUrl=http%3A%2F%2Fwww.foo.com%2Fportal%2Fauth.html&extend=xxx \");\t\t\t\n}\n```\n微信客户端将解析Portal Server转跳地址中的 authUrl 和extend参数，继续完成连接流程。\n但是的确有用户反馈微信打开之后，没有对应微信跟进ua进行的提示，查了下pv日志，对应用户使用的是钉钉环境，待跟进这个\n\n#### 扫码或者分享的链接打开，触发SDK\n"},{"title":"热区和cursor","url":"/2022/04/26/热区和cursor/","content":"## 移动端\n### 微信小程序\n#### 热区细节\n- \n\n\n\n\n\n## web端\n- cursor"},{"title":"vue-testing-jest","url":"/2022/04/24/vue-testing-jest/","content":"## reference\n- https://github.com/alexjoverm/vue-testing-series\n## jest\nJeff Morrison\n减少测试一个项目所要花费的时间和认知负荷\nTDD - test-driven development - 构建稳定可靠的库\n\n#### 特点\n- Facebook\n- out of box\n- assertion mock\n- snap 测试\n- Istanbul - coverage report\n- 并行测试\n\n#### snapshot\n- https://github.com/facebook/jest/blob/main/packages/jest-core/src/lib/__tests__/logDebugMessages.test.ts\n\n\n#### log\n\n#### cross-env\nJest默认commonjs方式导入的\n`npm i cross-env -D`\n- 解决ESM不支持的问题，可以用这个，使用Jest最新的原生支持ESM的特性\n- `\"jtest\": \"cross-env NODE_OPTIONS=--experimental-vm-modules jest\",`\n- https://www.npmjs.com/package/cross-env\n\n#### eslintrc.js\nenv - jest:true\n- 让eslint识别jest框架定义的方法\n\n#### 异步测试\n- async/await\n- 回掉函数\n- 以上都支持\n\n\n#### 覆盖率\n- jest 默认执行项目目录下所有`.test.js`文件\n- `\"jtest\": \"cross-env NODE_OPTIONS=--experimental-vm-modules jest --coverage\",`\n- 第三方库方式载入的代码，不会被测试覆盖率检查，需要测试，就拉到本地测试（不走npm\n## others\n\n#### jasmine - 基于BDD\n- behavior-driven development\n- 行为驱动测试 - 通过用自然语言书写非程序员可读的测试用例\n- observable\n- reducer - 纯函数 - 好测试\n- 一个命令行就可以生成spec - angular\n\n## configuring Jest\n#### cra\n- create react app reject 之后，transform的option\n```\n\"transform\": {\n  \"^.+\\\\.(js|jsx|mjs|cjs|ts|tsx)$\": \"<rootDir>/config/jest/babelTransform.js\",\n  \"^.+\\\\.css$\": \"<rootDir>/config/jest/cssTransform.js\",\n  \"^(?!.*\\\\.(js|jsx|mjs|cjs|ts|tsx|css|json)$)\": \"<rootDir>/config/jest/fileTransform.js\"\n},\n```"},{"title":"JS实现Bash现有功能","url":"/2022/04/08/JS实现Bash现有功能/","content":"> 基于zx这个包，把线上和测试环境的bash脚本，用JS实现下\n\n## reference\nhttps://github.com/google/zx\n\n### shebang\nunix - # => sharp, hash or mesh\nunix - ! => bang\n```\n#!interpreter [optional-arg]\n#!/usr/bin/env zx\n```\n\n#### bash\n- https://zhuanlan.zhihu.com/p/353435902?utm_medium=social&utm_oi=1084230223444353024\n- vscode编辑器配置\n\n\n### bash\n1. `#!/usr/bin/env bash`：此行是脚本的魔术行，指定运行该脚本的解释器。在这个案例中，它定义了脚本应由Bash( Bourne Again SHell)运行。\n   \n2. `set -euxo pipefail`：这是bash脚本的一个常见配置，它可以让脚本在出现错误时立即停止，并提供一些有用的调试信息。\n   - `set -e`：一旦脚本中的命令返回非零退出状态，脚本就会退出。\n   - `set -u`：如果脚本试图使用未设置的变量，脚本会退出。\n   - `set -x`：这将在执行每个命令之前打印命令，有助于了解脚本在哪里失败。\n   - `set -o pipefail`：如果管道中的任何命令失败，整个管道将失败，即使最后一个命令成功，并返回其成功的状态（0）。\n\n3. `./scripts/download-fonts`：执行\"download-fonts\"脚本，该脚本可能是用于从特定位置下载一些字体文件。\n   \n4. `./scripts/prepare-env-vars`：执行\"prepare-env-vars\"脚本，该脚本可能是用于设置环境变量。\n\n5. `./scripts/setup-sentry-properties`：执行\"setup-sentry-properties\"脚本，该脚本可能是用于配置Sentry的属性，Sentry是一种用于实时监控和修复错误的应用程序。\n\n6. `./scripts/setup-android-files`：执行\"setup-android-files\"脚本，可能是用于准备一些Android项目需要的文件或配置。"},{"title":"beta-reactjs-play","url":"/2022/04/04/beta-reactjs-play/","content":"> https://beta.reactjs.org/\n\n- 官方的，非常有意思的react doc新网站，YTB上面看到Dan在自己的channel里面直播调这个里面的问题；\n- https://github.com/reactjs/reactjs.org/issues/3308 - 可以追踪进度\n- https://github.com/reactjs/reactjs.org/tree/main/beta - git\n\n## figure how ?\n- next.config.js - 入口配置\n- console - 查看变量意思\n- delete | comparison - 删除一部分代码，做猜测的验证 \n- input && output - 猜测输入输出的意义\n- build time 可以做的事，为什么要在runtime做？\n- 遇到报错，如果觉得这个没问题，就是想验证一些猜测，可以删除报错（local的代码）试试看\n- throw Error('we are here')\n\n## nextjs\n- https://nextjs.org/docs/advanced-features/react-18/server-components\n- xxx.server.tsx | next.config.js \n- https://www.nextjs.cn/docs/getting-started\n#### 应用场景\n- 比较适合宣传页等的mobile站的场景\n\n## mdxjs.com\n\n## prettier.io\n- 各种规则格式化\n\n## PR | issue\n- 里面可以用关键词搜索问题\n\n## unpkg.com\n"},{"title":"看一看opensumi","url":"/2022/03/25/看一看opensumi/","content":"## doc\nhttps://opensumi.com/zh/docs/integrate/overview\n\n- https://github.com/opensumi/ide-startup-lite.git\n\n## IDE"},{"title":"svg相关","url":"/2022/03/24/svg相关/","content":"## svg动画\n- http://airbnb.io/lottie - 好处是开发人员完全不需要花时间了，设计人员直接导出即可使用，但是包的确不小，而且需要对数据进行处理再渲染\n- svg.js\n- https://zhuanlan.zhihu.com/p/383245453\n- https://www.animejs.cn/\n- http://snapsvg.io/\n\n\n## 剖析 lottie-web 动画实现原理 - 网易云音乐\n- https://juejin.cn/post/6914835547588395022\n\n## svgpath\n- https://www.npmjs.com/package/svgpath\n- 对于path的各种处理的方法\n- 线性代数的思维\n- https://github.com/fontello/svgpath\n\n### 可视化软件\n- https://svg-path-visualizer.netlify.app/"},{"title":"Google-drive-开发总结","url":"/2022/03/24/Google-drive-开发总结/","content":">  Google Drive可以作为一些轻量级应用的存储系统，可以让用户登录Google Drive，用户数据就可以直接存Google Drive了\n\n## 问题解决\n### 避免用一个ip，短时间内，多个请求，我们可以看到官方文档的限制\n- 通过配置和代码本身的控制，在允许的范围内，达到用户端的诉求\n- https://stackoverflow.com/questions/29955680/raised-google-drive-api-per-user-limit-still-getting-userratelimitexceeded-erro\n- https://stackoverflow.com/questions/25744367/google-drive-api-request-limitations\n- https://www.reddit.com/r/PleX/comments/7oderc/google_drive_user_rate_limit_exceeded/"},{"title":"状态机-XState","url":"/2022/03/21/状态机-XState/","content":"> \n## Xstate\n### docs\n- https://xstate.js.org/docs/zh/ \n- https://stately.ai/viz\n- https://static.frontendmasters.com/resources/2020-05-14-state-machines-xstate/state-machine-xstate.pdf\n\n\n### cases\n- SCXML（State Chart XML）- xstate -"},{"title":"monorepo","url":"/2022/03/18/monorepo/","content":"\n> https://static.frontendmasters.com/resources/2020-10-15-js-typescript-monorepos/js-ts-monorepos.pdf\n> https://github.com/mike-north/js-ts-monorepos/\n- monorepo 在一个 git 仓库里管理多个项目\n## v3\n```\n## Project Structure\n\nThis repository employs a [monorepo](https://en.wikipedia.org/wiki/Monorepo) setup which hosts a number of associated packages under the `packages` directory:\n\n## Development Setup\n\nYou will need [Node.js](https://nodejs.org) **version 10+**, and [PNPM](https://pnpm.io).\n\nWe also recommend installing [ni](https://github.com/antfu/ni) to help switching between repos using different package managers. `ni` also provides the handy `nr` command which running npm scripts easier.\n\n```\n\n## element-plus\n\n\n\n## spectrum\n- Install yarn: We use yarn to handle our JavaScript dependencies. (plain npm doesn't work due to our monorepo setup) See the yarn documentation for instructions on installing it.\n\n\n## xstate\n- https://github.com/statelyai/xstate\n\n\n## notesnook 开源的笔记软件 - 对标evernote\n- https://github.com/streetwriters/notesnook\n\n\n### lerna\n- Lerna是一个快速、现代的构建系统，用于管理和发布来自同一资源库的多个JavaScript/TypeScript包。\n\n### pnpm\n- workspace\n- pnpm install --recursive\n\n### yarn workspace\n- 主流方案是lerna + yarn worksapce，lerna负责发布和版本升级，yarn workspace负责依赖管理\n\n### npm\n- 是的，npm 也支持 monorepo。随着 npm 7 发布，在 npm 自带的工具集中新增了名为 workspaces 的功能，它能够帮助用户更好地管理 monorepo。\n\n要在 npm 中设置 monorepo，您需要在项目的顶层创建一个包含 workspaces 属性的`package.json`文件。此属性应包含一个数组，指明所有工作空间的相对路径。例如：\n\n```json\n{\n  \"name\": \"my-monorepo\",\n  \"private\": true,\n  \"workspaces\": [\"packages/*\"]\n}\n```\n\n在这个例子中，项目的所有子包都存放在`packages/`目录下。\n\n为了更好地管理 monorepo，您可以选择使用像 Lerna 这样的第三方工具。Lerna 和 npm workspaces 结合使用，能够让用户在 monorepo 中更方便地管理依赖和发布包。如果您决定使用 Lerna，请确保将`lerna.json`文件放在项目的根目录下。在 Lerna 中，你还可以根据需要为 monorepo 中的每个模块建立符号链接，从而让这些模块可以直接引用其他模块的源代码，而不是已发布的 npm 包版本。\n\n### monorepo - nest\n微服务项目\n\n### nx\n\n\n### rushstack"},{"title":"谈谈SEO","url":"/2022/03/16/谈谈SEO/","content":"> 之前做的若干内部系统，不和搜索引擎打交道，尽量避免被收录，在nginx配置上面，可以增加避免的文件\n\n### robots.txt\n- https://developers.google.com/search/docs/advanced/robots/intro?hl=zh-cn\n```\nrobots.txt 文件规定了搜索引擎抓取工具可以访问您网站上的哪些网址。 此文件主要用于避免您的网站收到过多请求；它并不是一种阻止 Google 抓取某个网页的机制。若想阻止 Google 访问某个网页，请使用 noindex 禁止将其编入索引，或使用密码保护该网页。\n```\n```\n警告：如果您不想让自己的网页显示在 Google 搜索结果中，请不要将 robots.txt 文件用作隐藏网页的方法。\n\n如果其他网页通过使用说明性文字指向您的网页，Google 在不访问您网页的情况下仍能将其网址编入索引。如果您想从搜索结果中屏蔽自己的网页，请改用其他方法，例如使用密码保护或 noindex。\n```\n\n### noindex\n- https://developers.google.com/search/docs/advanced/crawling/block-indexing?hl=zh-cn\n```\n您可以通过在 HTTP 响应中包含 noindex 元标记或标头，阻止网页或其他资源显示在 Google 搜索中。当 Googlebot 下次抓取该网页并发现该标记或标头时，Google 就会完全阻止该网页出现在 Google 搜索结果中，不论是否有其他网站链接到该网页。\n```\n### Google\n- https://developers.google.com/search\n- https://seo.co/local-seo/\n- https://moz.com/products/local\n- https://www.google.com/business/\n- https://trends.google.com/trends/?geo=HK\n- https://ads.google.com/home/tools/keyword-planner/\n- https://www.semrush.com/\n- https://www.wordtracker.com/\n- https://www.spyfu.com/\n\n#### tips\n- 去掉不好的link - https://support.google.com/webmasters/answer/2648487?hl=en\n- `<rel='nofollow'>`\n- 花钱\n- metadata (title | description | keyword)\n- facebook opengraph | twitter cards | pinterest rich pins - 去developer都可以查到文档\n- 结构化的数据\n- https://developers.google.com/search/docs/advanced/structured-data\n- https://developers.google.com/search/docs/advanced/structured-data/breadcrumb\n- https://developers.google.com/search/docs/advanced/structured-data/course\n\n#### mobile\n- manifest.json\n- meta - viewport | fullscreen | balck status bar | home screen title\n- https://github.com/cubiq/add-to-homescreen\n- homescreen icons - add-to-homescreen\n\n\n#### amp\n- AMP is a web component framework to easily create user-first experiences for the web.\n- https://amp.dev/\n\n#### https\n当然\n\n#### "},{"title":"网关系统-Gateway-summary","url":"/2022/03/10/网关系统-Gateway-summary/","content":"## why\n- 应用稳定性: 如果没办法对单一的模块做熔断、升级、回滚等操作，线上不可控的概率极大 -> 微服务架构\n```\n通用性的认证、鉴权、限流 -> 微服务-造轮子\n业务复杂度上升 -> 域名分配问题\n服务使用的语言框架差异 - DevOps 系统\n```\n- 网关系统 - 通过网关的统一入口来调度各个微服务功能模块，使得每个微服务可以关注于自身的业务功能开发\n\n## what\n#### 请求类型\n- 静态资源网关 - CSR ｜ SSR\n- API网关 - MSA - 统一出入口 - 降低接入和使用成本\n\n#### 功能\n- 流量网关 - 安全（黑白名单），分流（负载均衡）\n- 业务网关 - 用户（认证，鉴权），服务稳定性（降级，容灾，分流），业务属性灰度（AB test），代理（资源代理，缓存 - 成本高），统一前置（日志，数据校验）\n\n#### 网关基础服务\n- 资源分发｜API分发\n- 资源缓存模块\n- AB TEST模块\n- 通用日志模块\n\n#### 统一用户中心系统\n- 用户登录，认证等\n- 权限系统（RBAC） - 优先级高\n\n#### 物料系统\n- DevOps相关\n\n### frameworks\n- Nginx+Lua：Open Resty、Abtesting Gateway\n- Java：Spring Cloud Gateway\n- Go：Janus、Grpc-Gateway\n- Node.js：Express Gateway、MicroGateway"},{"title":"v3-overall-design","url":"/2022/02/18/v3-overall-design/","content":"## trade-on\n> 框架设计层面\n- 范式 => 命令式-关注过程 ｜ 声明式-关注结果\n- 性能 -（理论上 - 命令式 > 声明式） ｜ 可维护性 == 心智负担\n- 运行时 - Render｜ 编译时 - Complier - svelte ｜ 运行时-编译时 - vue （v3通过编译手段提升性能）\n- 虚拟DOM - 让diff的性能消耗最小化\n- comparison - document.createEl | virtual Dom | innerHTML => 页面大小｜变更部分大小｜create？update？"},{"title":"webComponents","url":"/2022/02/11/webComponents/","content":"- https://developer.mozilla.org/zh-CN/docs/Web/Web_Components\n- github - https://github.com/WICG/webcomponents\n- https://github.com/webcomponents/polyfills/tree/master/packages/webcomponentsjs - polyfill相关\n- https://lit.dev/ - framework\n- https://zh-hans.reactjs.org/docs/web-components.html\n\n\n\n### Tips\n根据需要适配的浏览器，做好适配\n如果不处理，edge会直接抛错，阻塞渲染\n- As a workaround, if your project has been compiled to ES5, load custom-elements-es5-adapter.js before defining Custom Elements. This adapter will automatically wrap ES5.\n\n### omi - Web Components Framework - Web组件框架\n- https://github.com/Tencent/omi\n```\n📶 信号 Signal 驱动的响应式编程，reactive-signal强力驱动\n⚡ 微小的尺寸，极速的性能\n💗 目标 100+ 模板 & OMI 模板源码\n🐲 OMI Form & OMI Form 游乐场 & Lucide Omi 图标\n🌐 你要的一切都有: Web Components, JSX, Function Components, Router, Suspense, Directive, Tailwindcss...\n💯 面向对象编程(OOP) 和 数据驱动编程(DOP) 两种范式都支持\n💒 使用 Constructable Stylesheets 轻松管理和共享样式\n```"},{"title":"nodejs-why-and-how-and-what","url":"/2022/01/29/nodejs-why-and-how-and-what/","content":"\n- 性能，并发性，可用性，可靠性，可扩展性\n- 从开始设计，用于构建实时和并发系统\n- 发展，改进中\n\n## arch\n- the node.js system\n- application - v8 - javascript engine\n- node.js bindings - node api - os operation\n- libuv - asysnchronous I/O - event queue - event loop - worker threads - file system|network|process - blocking operation|execute callback\n- nodejs线程 | c++线程\n## nodejs内置模块\n\n### EventEmitter\n- 观察者模式\n    - addEventListener | removeEventListener\n    - 调用|抛事件\n    - 谁在听 | 听没听\n## 异步\n### 非阻塞I/O\n- Input/Output 系统的输入和输出\n- 阻塞？ 系统接收输入到再输出期间，能否接收其它输入\n（与阻塞 I/O系统相比，非阻塞 I/O系统提高了 CPU的利用率，可以执行更多的任务，使用更少的时间）\n\n### callback\n- func格式规范 - error-first！！！ | node-style callback\n- 异步流程控制 - 回调地狱 | 异步并发（A&&B => Do C）- 就要加计数器等一堆逻辑来达成\n- history - package-async.js | thunk-编程范式\n\n### throw Error\n- 全局的会导致程序崩溃\n- call stack 调用栈 | try catch 如果不在包裹内，则无法捕捉\n- 事件循环 - setTimeout | 注意捕捉范围\n### 事件循环\n- event loop\n- https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop\n- https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/#what-is-the-event-loop\n- 理解调用栈\n(理解好浏览器和node环境的差异，为什么需要eventloop，为什么node端的是更精细化的设计)\n- browser (https://github.com/luokuning/blogs/issues/1 - Object.observe为什么要被移除)\n### Promise\n#### What\n- 当前事件循环得不到的结果，未来的事件循环会给到结果\n- 状态机 - pending => fulfilled/resolved | rejected\n- .then | .catch\n- rejected状态后无.catch的Promise，会造成browser｜node环境的全局错误\n- 执行then，catch之后会返回一个新的Promise，该Promise的最终状态根据回调函数的执行结果决定\n- 回调函数：throw -> Promise状态是： rejected | return -> resolved\n- 如果回调函数return了一个Promise，这个Promise会和回调函数return的Promise状态保持一致\n- Promise.all  并发异步，catch拿第一个error的\n### async/await\n- async function 是 Promise的语法糖封装(console出来可以验证)\n- 以同步的方式写异步-异步编程终极方案\n- 以同步的写法获取Promise的执行结果            \n- try-catch可以获取await得到的错误\n- Event Loop -> 逻辑思维上的转变\n- 并行异步任务 -> +Promise.all\n\n### http\n- http服务 -> 解析请求报文 && 返回对应的返回报文\n- IncomingMessage - Class - doc\n#### Express\nExpress - http服务框架\n- 核心功能 && 解决的问题 -> what - 路由&&(req&&res简化)&&middleware | why\n- middleware - 组织流程代码 ｜ 异步会打破express的洋葱模型\n- https://www.npmjs.com/package/express\n#### Koa\n- (req&&res简化) - 更简单明了\n- async - 在异步情况下，也符合洋葱模型\n- 精简内核，额外功能都移到了middleware实现\n\n### RPC\n- Remote Procedure Call\n#### 和Ajax的比较-相同\n- 两端的网络通信\n- 需要约定数据格式\n\n#### 和Ajax的比较-差异\n- 不一定使用DNS作为寻址服务\n- 应用层协议一般不使用HTTP\n- 基于TCP或者UDP协议\n\n#### RPC调用\n- 寻址｜负载均衡\n - Ajax使用DNS进行寻址\n - RPC使用特有服务进行寻址\n- TCP通信方式\n - 单工通信\n - 半双工通信\n - 全双工通信\n- 二进制协议\n - 更小的数据包体积\n - 更快的编解码速率\n\n- https://github.com/tars-node \n- https://github.com/tars-node/rpc\n\n### Buffer编解码二进制数据包\n#### 大小端问题 \n- 几个Byte里，高位与低位的编排顺序不同\n#### 处理方法与String接近\n- 使用concat 而不是 + ，避免utf-8字符拼接问题\n#### Protocol Buffer\n- Google研发的二进制协议编解码库\n- 通过协议文件控制Buffer的格式 - 直观｜好维护｜方便协作\n\n### net 搭建多路复用的RPC通道\n- 单工｜半双工的通信通道搭建\n- 全双工的通信通道搭建\n - 应用层协议需要有标记包号的字段\n - 需要有标记包长的字段（粘包，不完整包）\n - 错误处理\n- netty - java的rpc通信\n## source code\n#### 内置模块\n- os.js - internalBinding - node_os.cc - libuv\n- v8\n- \n\n\n\n\n## basic\n### globals\n#### process\n-  A swiss army knife global. An Object that contains all the context you need about the current program being executed. Things from env vars, to what machine you're on.\n```\n当 Node.js 进程收到信号时，则将触发信号事件。 \nLinux supports the standard signals listed below.  The second\n       column of the table indicates which standard (if any) specified\n       the signal: \"P1990\" indicates that the signal is described in the\n       original POSIX.1-1990 standard; \"P2001\" indicates that the signal\n       was added in SUSv2 and POSIX.1-2001.\n       \nprocess.on('SIGINT', () => {\n  console.log('Received SIGINT. Press Control-D to exit.');\n});\n\n```\n- https://man7.org/linux/man-pages/man7/signal.7.html -   SIGINT-P1990-Term-Interrupt from keyboard\n\n```\nWindows 不支持信号，因此没有等价的使用信号来终止，但 Node.js 提供了一些对 process.kill() 和 subprocess.kill() 的模拟：\n\n发送 SIGINT、SIGTERM、和 SIGKILL 会导致目标进程无条件的终止，之后子进程会报告进程被信号终止。\n发送信号 0 可以作为独立于平台的方式来测试进程是否存在。\n```\n\n\n\n\n\n\n\n\n\n\n## 其他语言\n### golang\n- coroutines\n### erlang\n- 抢占式调度\n\n\n\n## performance\n#### http服务性能测试\n- 优化性能的前提 - 性能检查\n- 压测工具 - ab|webbench\n- 服务器性能指标 - QPS｜吞吐量\n- 找到性能瓶颈 - top|iostat\n\n#### nodejs性能分析工具\n- nodejs - profile\n- chrome devtool\n- npm - clinic\n\n#### js代码性能优化\n- 根据性能分析结果优化\n- 准则\n  - 减少不必要的计算 - 提前计算（启动阶段？服务阶段）\n  - 空间换时间？\n\n#### 内存优化管理\n- 垃圾回收\n```\n新生代 - 容量小，垃圾回收更快\n老生代 - 容量大，垃圾回收更慢\n减少内存使用，是提高服务性能的手段\n内存泄漏会导致服务性能问题\n```\n- nodejs buffer 的内存分配策略\n- 节省内存的最好方式是 - 使用池\n\n#### C++插件\n- 编译环境\n  - node-gyp(node-gyp本身，对应的node版本编译环境)\n  - python\n- 将计算量转移到C++进行\n  - 收益：C++运算比JS更快的部分｜成本：C++变量和V8变量的转换\n\n#### nodejs子进程与线程\n- 进程（操作系统挂载运行程序的单元｜拥有一些独立的资源，如内存等）\n- 线程（进行运算调度的单元｜进程内的线程共享进程内的资源）\n- nodejs的事件循环\n```\n- 主进程运行v8与Javascript\n- 多个子线程通过时间循环被调度\n```\n- 使用子进程或者线程利用更多的CPU资源\n\n#### cluster\n- 主进程启动多个子进程，由主进程轮流分发请求，子进程代为处理\n\n#### 进程守护\n- nodejs的稳定性\n- 防止僵尸进程（心跳）\n- 死亡重启\n- 数据监控\n\n### 动静分离\n- 静态内容-基本不会变动，也不会因为请求参数不同而变化 -> CDN分发，http缓存\n- 动态内容-各种因为请求参数不同而变动，且变种的数量几乎不可枚举 -> 加机器，结合反响代理进行负载均衡\n## Tools\n#### volta - The Hassle-Free JavaScript Tool Manager\n- https://volta.sh/\n- 在MacOS上使用Volta来安装Yarn的过程相对简单。首先，你需要确保你已经在你的机器上安装了Volta。如果你还没有安装Volta，你可以使用下面的命令来安装：\n```bash\ncurl https://get.volta.sh | bash\n```\n```bash\nvolta install yarn\n```\n\n\n## 框架设计和工程化 \n> 软件质量体系，https://juejin.cn/post/6990365231348187150 - 设计模式经典书籍\n- 架构设计 （底层更稳固->程序不容易崩溃，容易往上搭-扩展新功能更方便）\n- 工程工具（更加易于施工-学习上手成本低，保证施工安全-不会因为操作失误搞挂程序）\n\n- 给工程师使用的产品\n  - 开发体验（可维护性，可靠性，易用性）\n  - KISS（Vue渐进式）\n\n### 设计模式\n- 模式只是达到目的的手段\n- PD这本书-1995-基于Java语言本身的一些特性-elements of reusable object-oriented software\n#### 观察者模式\n- EventEmitter（node-process）\n- DOM addEventListener\n```\n在 Node.js 中，EventEmitter 是一个用于处理事件的模块。它提供了一种基于观察者模式的异步编程方式，可以在需要时触发事件和处理事件。以下是一些使用 EventEmitter 的常见场景：\n\n数据库连接：当使用 Node.js 连接到数据库时，可以使用 EventEmitter 来处理成功或失败的情况，并确保连接正确关闭。\n\n网络编程：在编写网络应用程序时，使用 EventEmitter 可以轻松地管理套接字和客户端连接，并处理相关的事件，例如数据传输、断开连接等。\n\n文件系统：Node.js 的文件系统模块也使用 EventEmitter 来通知进程有关文件操作的事件（如读取、写入、删除等）。\n\n自定义事件：通过继承 EventEmitter 类并添加自己的方法和属性，可以创建自己的类，并发出自定义事件来实现各种功能。\n\n总之，EventEmitter 在 Node.js 中非常常用，几乎在任何需要处理异步事件的场景中都可能会用到。无论是处理数据库连接、网络编程还是文件系统操作，使用 EventEmitter 都可以帮助我们轻松地管理异步事件，保持代码的模块化和可读性。\n\n观察者模式是一种设计模式，用于处理对象间的一对多依赖关系，并在对象状态发生变化时自动通知所有依赖项。在观察者模式中，被观察的对象称作主题（Subject），而观察它的对象称为观察者（Observer）。\n\n观察者模式的主要思想是，当主题对象状态发生变化时，它会通知所有已注册的观察者对象，并调用它们的更新方法来执行相应的操作。这使得主题和观察者可以解耦，避免了紧密耦合的代码结构，也提高了系统的可扩展性和可维护性。\n\n观察者模式通常包括以下角色：\n\n主题（Subject）：被观察的对象，它包含了观察者需要监视的状态以及注册和删除观察者的方法。\n\n观察者（Observer）：观察主题对象的状态，并在状态发生变化时执行相应的操作。\n\n具体主题（Concrete Subject）：具体的被观察对象，它维护了一个观察者列表，并且负责通知所有已注册的观察者。\n\n具体观察者（Concrete Observer）：具体的观察者对象，实现了更新方法，并定义了在主题状态发生变化时所执行的操作。\n\n观察者模式可以应用于许多场景，例如GUI事件处理、文档自动保存、股票市场监控等。它可以帮助我们实现松耦合的代码结构，并提高系统的可扩展性和可维护性。\n\nRxJS (Reactive Extensions for JavaScript) is a library for reactive programming using Observables to handle asynchronous and event-based workflows in JavaScript. It provides operators for transforming, filtering, combining, and querying data streams, as well as utilities for managing subscriptions and handling errors. RxJS is commonly used in front-end web development with frameworks such as Angular or React.\nRxJS 的使用场景主要是处理复杂的异步和事件驱动场景，例如：\n\n处理 HTTP 请求：RxJS 的 Observable 类型可以方便地处理 HTTP 请求和响应，并使用操作符进行数据转换、筛选和组合。\n\n处理用户界面输入：RxJS 可以处理用户界面上的各种事件（如点击、滚动、输入等），并将它们转换成 Observable 流，使得开发者可以方便地编写响应式代码。\n\n处理 WebSocket 数据流：RxJS 可以轻松处理 WebSocket 数据流，并基于数据流执行各种操作，例如过滤、聚合、映射等。\n\n处理复杂的状态管理：RxJS 可以用于处理复杂的状态管理场景，例如 Redux 和 NgRx 中的数据流管理和副作用管理。\n\n处理数据可视化：RxJS 可以用于实现数据可视化和动画效果，例如基于数据流控制图表的更新和动画过渡效果。\n\n总之，RxJS 主要适用于需要处理异步和事件驱动场景的项目，尤其是在需要对数据进行转换、组合和筛选时。\n\n```\n\n#### 外观模式\n- jQuery（解决兼容性问题）\n```\nelem.on('', func)\nif else - 各种浏览器\n```\n\n#### 6原则\n- 单一职责 (微服务) - 每一个模块都有明确的功能\n- 开闭原则 - 对扩展开放，对修改关闭 - css-loader ts-loader| webpack - 新增功能只需要增加模块，不需要修改原有部分\n。。。like lego\n\n"},{"title":"imove-study-分析","url":"/2022/01/20/imove-study-分析/","content":"- https://github.com/i5ting/imove\n- https://www.yuque.com/imove/blog/vgp6bb\n- https://juejin.cn/post/6919075978832510984\n- INACTIVE: Move your mouse, generate code from flow chart\n- 30 Jul 2021 - 最后一个release"},{"title":"Kotlin-Andriod现有项目引入","url":"/2022/01/18/Kotlin-Andriod现有项目引入/","content":"> 最近看android项目的提交，发现，诶，kt文件多了起来，梳理下；\n\n\n## 官方文档\n- https://developer.android.com/kotlin/first\n\n## 项目相关\n### 背景介绍\n现有的Android项目，用Java开发，有个老师之前用Kotlin，所以他负责的模块kotlin写的比较多\n\n\n\n## 其他\n### JS\n- https://www.kotlincn.net/docs/reference/js-overview.html\n\n### kotlin-android-extensions插件在较新的Kotlin版本中已被弃用，您现在需要使用viewBinding或dataBinding来替代。\n\n移除kotlin-android-extensions插件的步骤如下：\n\n1. 打开您项目根目录下的 `build.gradle`（或 `build.gradle.kts`）文件，找到该行并移除：\n   ```gradle\n   apply plugin: \"kotlin-android-extensions\"\n   ```\n   如果您使用的是 `build.gradle.kts`，移除：\n   ```kotlin\n   apply(plugin = \"kotlin-android-extensions\")\n   ```\n\n2. 找到 `dependencies` 下的 `implementation \"org.jetbrains.kotlinx:kotlinx-android-extensions:$version\"` 并移除。\n\n3. 使用View Binding或Data Binding来替代。\n\n例如，如果您要使用View Binding，需要在每个模块的 `build.gradle` 文件中启用它，如下所示：\n\n```gradle\nandroid {\n    ...\n    viewBinding {\n        enabled = true\n    }\n}\n```\n然后更新你的代码来使用View Binding。这通常包括使用 `binding` 对象代替 `findViewById` 或Kotlin Android Extensions 的synthetic properties。例如：\n\n```kotlin\nclass MyActivity : AppCompatActivity() {\n    private lateinit var binding: ActivityMyBinding\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        binding = ActivityMyBinding.inflate(layoutInflater)\n        val view = binding.root\n        setContentView(view)\n        \n        binding.myButton.setOnClickListener { /*...*/ }\n    }\n}\n```\n\n\"kotlin-android-extensions\" 和 \"kotlin-android\" 是Kotlin在Android中的两个不同插件，它们都为Android开发人员提供了一些便利的工具和功能。\n\n1. \"kotlin-android\" 插件： 这是在Android项目中使用Kotlin语言的必要插件。它包含了一些在Android Studio IDE中进行Kotlin开发必要的特性，比如Kotlin代码文件的处理，与安卓SDK的交互等。如果移除了这个插件，那么你将不能在你的Android应用项目中使用Kotlin。\n\n2. \"kotlin-android-extensions\" 插件： 这个插件扩展了当初\"Kotlin-android\"的功能，提供了额外的功能如视图绑定等。之前，开发人员经常利用这个插件通过ID直接访问视图，无需 `findViewById()`。然而，Google已经引入了更强大的View Binding和Data Binding，所以\"kotlin-android-extensions\"已经被弃用。如果你移除这个插件，也可以正常开发，你只需要替换原有的代码到新的视图绑定方式。\n\n总的来说，这两个插件的区别在于，\"kotlin-android\" 是使用Kotlin语言在Android项目中进行开发的基础插件，而 \"kotlin-android-extensions\" 插件则提供了一些方便的扩展功能。目前，在更新的Android开发实践中，\"kotlin-android-extensions\" 插件已不再需要。"},{"title":"ios-project","url":"/2022/01/14/ios-project/","content":"## files\n\n### project.pbxproj\n- The Xcode project file is an old-style plist (Next style) based on braces大括号 to delimit the hierarchy. The file begins with an explicit encoding information, usually the UTF-8 one. \n- plist\n- http://www.monobjc.net/xcode-project-file-format.html\n```\nRoot Element\nThe root section contains the general informations.\n\nAttribute\tType\tValue\tComment\narchiveVersion\tNumber\t1\tDefault value.\nclasses\tList\tEmpty\t\nobjectVersion\tNumber\t\tSee XcodeCompatibilityVersion enumeration.\nobjects\tMap\tA map of element\tThe map is indexed by the elements identifier.\nrootObject\tReference\tAn element reference\tThe object is a reference to a PBXProject element.\n```\n\n### setup\n- pod install\n- 安装完成后，打开生成的 .xcworkspace 文件，并使用此文件打开您的项目。不要使用原始的 .xcodeproj 文件打开项目，否则项目将无法使用新安装的依赖项\n- 保证网络 or 切换稳定源（pod repo）\n- 等待Indexing(Indexing 是 Xcode 中必要的过程，可以提高编码效率和编译速度。如果 Indexing 过程耗时较长或出现问题，可以尝试暂停 Indexing、清理 DerivedData 和优化代码结构等方法来解决问题)\n\n### https://cocoapods.org/\n- CocoaPods.org 是 CocoaPods 官方网站，提供了 CocoaPods 的搜索引擎、文档、指南、社区等资源。在该网站上，你可以搜索并找到符合需求的 Pods，并查看其用法、版本历史、许可证等信息。此外，CocoaPods.org 还提供了 Pod 创建、发布和管理等功能，是 CocoaPods 开发和使用的重要平台。\n\n- CocoaControls 则是一个第三方网站，主要提供了 iOS 和 macOS 开发中常用的 UI 控件和库。在该网站上，你可以浏览并下载各种开源 UI 组件，如按钮、标签、表格、图表、动画等。这些组件大多数都是基于 CocoaPods 库构建的，因此你可以在 CocoaControls 网站上直接查看并复制 Podfile 中的代码，以便更轻松地集成到项目中。\n\n- podfile - ruby\n- do|end\n\n### SwiftPM\n\n\n### spec repo trunk\n- pod trunk\n- pod trunk register EMAIL 'NAME' --description='DESCRIPTION'\n- pod trunk push PODSPEC_FILE\n\n### podfile\n- \"use_frameworks!\" 是一个在使用 CocoaPods 管理 iOS 项目依赖库时，用于指定是否使用动态框架的命令。\n\n- 当在 Podfile 中添加 \"use_frameworks!\" 后，在安装依赖库时，CocoaPods 将会通过生成并链接动态框架的方式来管理项目中的第三方库。这种方式相对于静态库链接的方式可以减小最终 App 的大小，并且能够更好地管理依赖性。\n- 需要注意的是，如果项目依赖库中有一些只提供了静态库而没有提供动态库的话，使用 \"use_frameworks!\" 可能会导致编译错误。此时可以考虑手动将这些库作为静态库集成到项目中，或者使用其他的依赖管理工具来处理这种情况。\n```\npost_install do |installer|\n    installer.pods_project.targets.each do |target|\n        target.build_configurations.each do |config|\n            config.build_settings['EXPANDED_CODE_SIGN_IDENTITY'] = ''\n            config.build_settings['CODE_SIGNING_REQUIRED'] = 'NO'\n            config.build_settings['CODE_SIGNING_ALLOWED'] = 'NO'\n        end\n    end\nend\n```\n- 在使用 CocoaPods 管理 iOS 项目依赖库时，为所有的 Pod 库设置编译选项以关闭代码签名功能。代码签名是一种苹果公司用于保护 App 安全性和防止恶意软件入侵的机制，但有时在开发过程中可能会因为证书问题或其他原因导致编译失败。\n- 该代码将 EXPANDED_CODE_SIGN_IDENTITY、CODE_SIGNING_REQUIRED 和 CODE_SIGNING_ALLOWED 这三个选项都设置为 NO，这样就可以禁用代码签名功能了。需要注意的是，这种做法通常只适用于开发和测试环境，发布到 App Store 前仍然需要进行正式的代码签名和验证。\n```\n  pod 'DoraemonKit/Core', '~> 3.0.4', :configurations => ['Release_Test']\n```\n- 引用的是 DoraemonKit/Core 库的 3.0.4 版本，并且只有当当前项目的配置为 Release_Test 时才会包含该库。这意味着该库仅在 Release_Test 配置下才会被引入，并且在其他配置下不会被包含在项目中。\n- DoraemonKit 是一款 iOS 开发者调试工具集合，包含了多个实用工具，如性能检测、UI 展示、网络拦截等。Core 模块是 DoraemonKit 的核心库之一，包含了基础的工具和框架，可以帮助开发者快速构建和扩展更加强大的调试工具。\n### https://bugly.qq.com/\n- https://bugly.qq.com/docs/user-guide/instruction-manual-ios/?v=1.0.0\n\n### bonree\n\n\n### 卡顿分析\n- \"NotSmoothFrameException\" 这个问题在 iOS 应用程序中通常被称为卡顿（Jank），它可能会导致应用程序响应变慢，用户体验下降。\n\n### 错误分析\n- # SIGKILL The application did not terminate cleanly but no crash occured.\n- 这个消息提示，意味着应用程序在运行过程中被强制终止了。SIGKILL 是一种 Unix 信号，用于强制终止进程，因此这种情况可能是由系统或用户手动杀死了进程导致的。\n- 与 SIGKILL 不同的是，如果应用程序崩溃了，会触发 SIGSEGV 或 SIGBUS 信号，Crash 报告工具（如 Crashlytics 或 Bugly）通常可以捕获这些信号并生成相应的报告。但是，在没有崩溃的情况下，一些监控工具可能会记录 SIGKILL 信号以帮助开发人员进行故障排除，获取更多关于应用程序运行时的上下文信息。\n\n\n### 崩溃分析\n- \n\n\n#### exportoptions.plist \n是 Xcode 中用于导出 iOS 应用程序的配置文件，它包含了一些指定导出选项和目标设备信息的属性。\n\n当开发者需要将自己的应用程序发布到 App Store 或者分发到其他用户时，可以使用 Xcode 的 Export 功能来生成一个可安装的 IPA 文件。在执行 Export 操作之前，需要先选择一些导出选项，如导出方式（Ad Hoc、App Store 等）、目标设备、证书等，并将这些选项保存为 exportoptions.plist 配置文件。\n\nexportoptions.plist 文件是一个 XML 格式的文本文件，其中包含了多个键值对，每个键表示一个导出选项，对应的值表示该选项的设置。例如，\"method\" 键表示导出方式，可以设置为 \"app-store\"、\"ad-hoc\" 等；\"teamID\" 键表示开发者团队的唯一标识符，用于验证证书等信息。\n\n#### release_achive_pre_action.sh\n是指在 Xcode 中进行 Archive（归档）操作前自定义执行的脚本或命令。\n\n在 Xcode 中，Archive 操作是将项目打包成一个可发布的 IPA 文件的过程。在执行该操作之前，有时需要执行一些额外的操作，例如版本号更新、代码检查等。这时就可以使用 \"release_achive_pre_action\" 这个钩子来实现这些自定义任务。\n\n要配置 \"release_achive_pre_action\"，可以在项目的 Build Phases 设置中选择 \"Editor\" > \"Add Build Phase\" > \"Add Run Script Build Phase\"，然后在脚本编辑器中编写需要执行的脚本或命令即可。在执行 Archive 操作时，Xcode 将会先执行设置的所有 pre-action 内容，再执行 Archive 操作本身。\n\n#### \"build_test.sh\" 是一个 shell 脚本，用于在 Xcode 中自定义构建测试的过程。\n\n在 iOS 应用程序开发中，我们通常需要编写一些单元测试和集成测试来保障代码的质量和稳定性。Xcode 提供了对 XCTest 框架的支持，可以很方便地进行测试。但是，有时开发者可能需要执行一些额外的操作或者使用其他的测试框架来进行测试，这时就可以使用 \"build_test.sh\" 这个脚本来自定义测试构建流程。\n\n\"build_test.sh\" 脚本可以包含一些特殊的命令，例如 xcodebuild 和 xctool 等，用于编译测试包、运行测试并将测试结果输出到指定位置。通过编写自定义的 \"build_test.sh\" 脚本，开发者可以更灵活地管理项目的测试流程，并满足不同的测试需求。\n\n#### info.plist 是 iOS 应用程序中的一个属性列表文件，包含了应用程序的基本信息和配置参数。\n\n在 info.plist 文件中，可以定义一些键值对来指定应用程序的名称、版本号、图标、权限、URL schemes 等信息。这些信息将被系统用于显示应用程序的基本信息以及确定应用程序在设备上的行为。\n\n例如，\"CFBundleDisplayName\" 键用于指定应用程序在设备上显示的名称；\"CFBundleVersion\" 键用于指定应用程序的版本号；\"NSCameraUsageDescription\" 键用于指定应用程序访问相机权限时的提示文案等。通过修改 info.plist 文件，开发者可以轻松地修改应用程序的基本信息，并调整其行为和功能。\n\n需要注意的是，info.plist 文件是必须存在的，并且必须包含一些必要的键值对，否则应用程序将无法正常运行。\n\n#### bridging-header.h\nUse this file to import your target's public headers that you would like to expose to Swift.\n\"bridging-header.h\" 是在使用 Swift 语言开发 iOS 应用程序时，将 Objective-C 代码引入到 Swift 项目中的一种方式。\n\n由于 Swift 和 Objective-C 是两种不同的编程语言，它们之间并不完全兼容，因此在进行混合编程时需要进行桥接。在 Xcode 中，可以创建一个名为 \"bridging-header.h\" 的文件，并在其中包含需要引入的 Objective-C 头文件。这样，Swift 代码就可以访问并使用 Objective-C 类和方法了。\n\n要使用 bridging-header.h 文件，需要先在 Build Settings 中设置 \"Objective-C Bridging Header\" 选项，将其设置为 bridging-header.h 文件的路径。然后，在 Swift 代码中就可以通过 import 关键字来引入 Objective-C 类和方法，从而实现混合编程的目的。\n\n需要注意的是，虽然可以通过 bridging-header.h 文件将 Objective-C 代码引入到 Swift 项目中，但是反过来却不行。也就是说，Objective-C 项目无法直接引入 Swift 代码，需要通过其他方式实现混合编程。\n\n\n#### \"AppDelegate.swift\" 是在使用 Swift 语言开发 iOS 应用程序时，应用程序的入口文件和主要配置文件。\n\n在 AppDelegate.swift 文件中，包含了应用程序启动时需要执行的代码和各种配置选项。例如，在该文件中可以定义应用程序的窗口、根视图控制器、推送通知设置、URL schemes 处理等功能。同时，AppDelegate.swift 还提供了多个生命周期方法，如 application(:didFinishLaunchingWithOptions:)、applicationDidBecomeActive(:) 等，用于处理应用程序在不同状态下的行为和逻辑。\n\n需要注意的是，虽然 AppDelegate.swift 是应用程序的主要入口文件，但它并不是唯一的入口点。在应用程序中，还可以通过 SceneDelegate.swift 文件（仅适用于 iOS 13 及以上版本）和 SwiftUI 的 @main 注解来定义应用程序的入口点。\nNS的全称是NextStep，它是苹果公司早期开发的一种面向对象编程框架，现在被整合到了Cocoa和Cocoa Touch中。NSLocalizedString函数是一个用于本地化字符串的Objective-C语言中的宏，它可以帮助开发者根据用户的语言环境来获取相应的翻译字符串。\n\n\"zh-hans.lproj\"是一个语言环境标识符，表示简体中文。在iOS和macOS开发中，开发者可以通过在工程项目中添加不同语言环境的本地化文件夹，并在其中放置对应语言的本地化字符串文件来实现多语言支持。其中，\".lproj\"是\"language project\"（语言项目）的缩写。\n\n\"launchScreen.strings\"是一个字符串文件的文件名，它通常用于应用程序启动画面的本地化。这个文件包含了用于展示启动画面的字符串，可以根据用户的语言环境进行本地化翻译。在该文件中，开发者可以使用NSLocalizedString函数来获取本地化字符串。\n\n#### \"Base.lproj\"是一个语言环境标识符，表示基础语言环境。在iOS和macOS开发中，开发者可以通过在工程项目中添加不同语言环境的本地化文件夹，并在其中放置对应语言的本地化字符串文件来实现多语言支持。\n\n\"Base.lproj\"文件夹通常包含项目中默认的本地化字符串文件，这些字符串将作为其他语言版本的备选项。如果应用程序在运行时无法找到特定语言的本地化字符串，系统将会回退并使用\"Base.lproj\"文件夹中的字符串作为默认值。因此，开发者需要确保\"Base.lproj\"文件夹中包含了所有必要的本地化字符串，并且这些字符串能够清晰、准确地表达应用程序的功能和信息。\n\n\"launchScreen.storyboard\"是一个故事板文件的文件名，它通常用于应用程序启动画面的设计。在iOS和macOS开发中，启动画面是应用程序第一次启动时显示给用户的界面，通常用来展示应用程序的品牌、公司或者产品信息。\n\n与传统的XIB文件不同，故事板（Storyboard）是一种更加高级的用户界面设计工具，可以在其中同时包含多个页面的设计，以及这些页面之间的流程和跳转关系。在故事板中设计完成后，可以使用代码来加载和控制这些页面，并将其作为应用程序的一部分进行发布。\n\n#### assets.xcassets\n在iOS和macOS开发中，图像资源是应用程序界面设计的重要组成部分。为了方便管理这些资源，开发者可以将它们放置在\"assets.xcassets\"文件夹中，并使用Xcode的图形化界面来进行预览、编辑和设置属性。其中，\".xcassets\"是“Xcode Assets”的缩写，表示这个文件夹是由Xcode管理的资源库。同时，该文件夹还支持不同屏幕尺寸和设备类型之间的自动适配，使得应用程序更加灵活和易于维护。"},{"title":"swift-feature-CR总结","url":"/2022/01/13/swift-feature-CR总结/","content":"### lazy\n#### Swift - lazy\n- Swift 中，lazy 属性的特点是：仅在“需要”时加载，并且仅加载一次\n- lazy 属性只在被调用的时候初始化，所以在 lazy 属性的初始化器中是可以访问当前实例的存储属性的\n- 如果是lazy变量，这意味着只有在用到该变量的时候，程序才会为我们创建它的实例\n```\nprivate lazy var imagePicker: SSImagePickerController = {\n        let picker = SSImagePickerController()\n        return picker\n    }()\n\n```\n#### Scala - lazy\n- Scala -  ```lazy val```\n\n\n#### Kotlin - lazy 委托\n- 几十年前，John McCarthy引入了短路求值来消除布尔逻辑中的冗余计算——如果在表达式之前对表达式的求值足以产生结果，则跳过表达式的执行。大多数编程语言都支持这个特性，程序员很快就会了解到这种方法的效率。Lazy（惰性）委托扩展了这种方法的范围\n```\nprivate val mIvTitle: ImageView by lazy {\n            view.findViewById(R.id.interactive_iv_name)\n        }\n\n```"},{"title":"egret-and-游戏设计","url":"/2022/01/04/egret-and-游戏设计/","content":"> 少儿的学习小游戏，内容团队之前基于白鹭引擎和自研的课件编辑平台进行创作；内容具体设计，制作者按学科划分，每个学科有具体的一套从设计到实现的人员链; \n\n## Basics\n### 官方说明\n```\n白鹭科技专注技术创新，攻克底层技术制约，为开发者带来一整套游戏研发解决方案，自主研发了白鹭引擎（Egret Engine）、Egret Pro、白鹭加速器（Egret Runtime）、骨骼动画工具(Dragon Bones)、可视化编辑器（EUI Editor）等多款产品，让开发者简单、高效的开发出移动游戏。\n- https://www.egret.com/about\n- Egret Engine 是一款使用 TypeScript 编写的 HTML5 游戏引擎，包含渲染、声音、用户交互、资源管理等诸多功能，解决了 HTML5 性能、碎片化问题，应用于 2D 游戏、3D 游戏开发，及移动端交互式应用构建，拥有完善的跨平台运行能力。 现在 Egret Engine 及其它工具已全部整合到 Egret Launcher，请大家直接下载安装开启您的游戏项目创作。\n```\n\n\n### 教学游戏\n- http://gk.link/a/1195n\n\n\n\n\n\n## others\n### oasis\n- https://github.com/oasis-engine/engine\n### 2048\n- 游戏：逻辑，技术，架构，创意，美术\n- UI（V） 动画效果逻辑 游戏主逻辑（C） 支撑逻辑 游戏数据（M）\n- 1.加载各项资源（board（Array）， score） \n```\ngrid-container position：relative grid-cell position:absolute\n在main.js里面：\n $().ready(){} ——加载 \nfunction newgame() { \n  //初始化棋盘格 init()——两个for循环，创建grid-cell-x-y \n  .css()控制位置,具体的实现可以调用support.js里面的函数。 //在随机两个格子生成数字 number-cell —— var board 遍历数组 updateBoardView（）\n  number-cell是动态定位，pos:absolute\n  数字的生成也可以带一点动画，这个可以将方法写在动画的控制逻辑\n}\n```\n- 2.游戏循环 基于时间的游戏循环 基于玩家响应的循环（JS事件响应机制）\n- 3.交互细节 canMoveLeft() 左边是否没有数字 左边数字是否和自己相等 遍历\n- 交互逻辑调试\n\n#### webAssembly在白鹭引擎中的实践\n- 需要提高JS运行效率\n- https://zhuanlan.zhihu.com/p/30513129"},{"title":"生命周期","url":"/2021/12/28/生命周期/","content":"\nIOS - ViewController\nAndroid - Activity\nFlutter - Widget - State"},{"title":"RFCs","url":"/2021/12/24/RFCs/","content":"## Vuejs\n- https://github.com/vuejs/rfcs\n\n## Reactjs\n- https://github.com/reactjs/rfcs\n\n## Rust\n- https://github.com/rust-lang/rfcs\n\n## Basic\n### What is an RFC?\n```\nThe \"RFC\" (request for comments) process is intended to provide a consistent and controlled path for new features to enter the framework.\n\nMany changes, including bug fixes and documentation improvements can be implemented and reviewed via the normal GitHub pull request workflow.\n\nSome changes though are \"substantial\", and we ask that these be put through a bit of a design process and produce a consensus among the Vue core team and the community.\n```\n- Request for comments\n- 目的是为新feature进入框架提供一个一致，可控的路径\n- pull request 能搞定很多changes，bug fixes等，但是一些 “substantial” - 实质性的改变，这些是需要经过一定的设计过程，并能在Vue的核心团队和社区中达成共识的\n- Substantial的判断标准\n```\nA new feature that creates new API surface area\nChanging the semantics or behavior of an existing API\nThe removal of features that are already shipped as part of the release channel.\nThe introduction of new idiomatic usage or conventions, even if they do not include code changes to Vue itself.\n创造新的API surface area 的feature\n改变现有API的语义或行为\n移除已经作为发布的一部分的功能\n引入新的习惯用法或惯例，即使它们不包括对Vue本身的代码修改\n```\n\n### The RFC life-cycle\n```\nAn RFC goes through the following stages:\n\nPending: when the RFC is submitted as a PR.\nActive: when an RFC PR is merged and undergoing implementation.\nLanded: when an RFC's proposed changes are shipped in an actual release.\nRejected: when an RFC PR is closed without being merged.\n```\n- 四个阶段\n- Pending ｜ Active ｜ Landed ｜ Rejected\n\n\n### and ...\n- 具体的流程，工作方式，项目清单，都可见具体对应项目的readme文档"},{"title":"UI编程范式","url":"/2021/12/23/UI编程范式/","content":"## Concept\n\n### 范式\n推荐下科学哲学这本书\n\n### 声明式 ｜ 命令式\n\n### 问题\n\n> 本质上一个效率问题，解决开发效率问题的探索\n\n\n## 声明式\n### Vue|React\n不多聊，见博文\n\n### Flutter\n\n\n## 最近看的代码\n\n### Android\n\n\n### IOS"},{"title":"线程和事件","url":"/2021/12/20/线程和事件/","content":"> http://berb.github.io/diploma-thesis/original/043_threadsevents.html\n\n### A mapping of thread-based and event-driven concepts based on Lauer and Needham - 基于Lauer和Needham的基于线程和事件驱动的概念的映射\n#### thread-based\n> 由监视线程\n- monitor \n- scheduling\n- exported functions\n- returning from a procedure\n- executing a blocking procedure call\n- waiting on condition variables\n#### event-driven\n> 异步回调\n- event handler\n- event loop\n- event types accepted by event handler\n- dispatching a reply\n- dispatching a message, awaiting a reply\n- awaiting messages\n\n#### conclusion\n- for large-scale connection concurrency, event-driven server architectures using asynchronous/non-blocking I/O operations seem to be more popular, as they provide a slightly better scalability under heavy concurrency.\n- 对于大规模的连接并发，使用异步/非阻塞I/O操作的事件驱动服务器架构似乎更受欢迎，因为它们在重度并发下提供了略好的可扩展性。\n\n- threads 基于顺序结构\n- 事件驱动 - 函数式语言和多范式语音通过闭包等特性，缓解了堆栈ripping的问题\n\n- 当然，这两种模型，谈论的话，离不开实际执行的环境和需要应用的场景！！！\n\n#### 进程 VS 线程\nCPU-工厂\n进程-车间\n线程-工人\n\n#### 浏览器多进程架构\n- chrome使用多个进程来隔离不同网页（tab）\n- js引擎线程｜UI渲染线程｜浏览器事件触发线程｜HTTP请求线程｜定时器触发线程｜事件轮询处理线程\n- 多线程worker\n- JS单线程（run in 浏览器）\n- web worker 允许JS脚本创建多个线程，但子线程完全受主线程控制，且不能操作DOM => 同步任务，异步任务\n- ajax可以加async：false -> 同步"},{"title":"MVC","url":"/2021/12/18/MVC/","content":"### concept\n#### model\n模型，对实际事物的抽象和简化\n#### domain model\n领域模型，领域范围内各个模型实体之间的关系\n#### MVC - Model\n- 领域模型\n- 数据本身\n#### 贫血模型 ｜｜ 充血模型\n- 对象是数据和逻辑的结合\n- Martin Fowler\n- Anemic Domain Model - 模型实体在设计和实现上，包含状态，不包含或者包含很少的逻辑，逻辑被解耦到了无状态service中 - 模型实体是遵循了一定封装规则的容器 - 不完全面向对象\n- Rich Domain Model - 领域模型实体，既包含数据也包含逻辑，完备且自洽 - 面向对象\n- 贫血or充血模型，和Model层的解耦程度无关\n\n#### 分层解决问题\n- 划分力度\n\n"},{"title":"swiper的n种用法","url":"/2021/12/16/swiper的n种用法/","content":"## Vue\nhttps://mp.weixin.qq.com/s/7maQP3LbIj_XZoHogfUIpA"},{"title":"force-graph-力导图","url":"/2021/12/16/force-graph-力导图/","content":"## basics\n- http://d3js.org/\n- https://github.com/d3/d3\n- 有边相连的节点之间通过基于胡克定律的弹簧式引力彼此吸引（Edge attraction），而基于库仑定律的带电粒子的斥力用于分离所有节点对（Vertex repulsion）。\n> Force-directed graph drawing algorithms are a class of algorithms for drawing graphs in an aesthetically-pleasing way. Their purpose is to position the nodes of a graph in two-dimensional or three-dimensional space so that all the edges are of more or less equal length and there are as few crossing edges as possible, by assigning forces among the set of edges and the set of nodes, based on their relative positions, and then using these forces either to simulate the motion of the edges and nodes or to minimize their energy.\n> 力导向图（Force-Directed Graph），是绘图的一种算法。在二维或三维空间里配置节点，节点之间用线连接，称为连线。各连线的长度几乎相等，且尽可能不相交。节点和连线都被施加了力的作用，力是根据节点和连线的相对位置计算的。根据力的作用，来计算节点和连线的运动轨迹，并不断降低它们的能量，最终达到一种能量很低的安定状态。\n> d3-force,This module implements a velocity Verlet numerical integrator for simulating physical forces on particles. The simulation is simplified: it assumes a constant unit step [公式] for each step, and a constant unit mass [公式] for all particles. As a result, a force [公式] acting on a particle is equivalent to a constant acceleration [公式] over the time interval [公式] , and can be simulated simply by adding to the particle's velocity, which is then added to the particle's position.\n\n## API\nhttps://www.npmjs.com/package/d3-force-3d\n\n## 应用封装\n### force-graph\n- https://github.com/vasturiano/force-graph/blob/master/src/canvas-force-graph.js\n```\nimport {\n  forceSimulation as d3ForceSimulation,\n  forceLink as d3ForceLink,\n  forceManyBody as d3ForceManyBody,\n  forceCenter as d3ForceCenter,\n  forceRadial as d3ForceRadial\n} from 'd3-force-3d';\n```\n\n### d3-force\n- https://github.com/d3/d3-force\n\n"},{"title":"热重载","url":"/2021/12/16/热重载/","content":"### Vue\n- https://vue-loader-v14.vuejs.org/zh-cn/features/hot-reload.html\n```\n状态保留规则\n当编辑一个组件的 <template> 时，这个组件实例将就地重新渲染，并保留当前所有的私有状态。能够做到这一点是因为模板被编译成了新的无副作用的渲染函数。\n\n当编辑一个组件的 <script> 时，这个组件实例将就地销毁并重新创建。(应用中其它组件的状态将会被保留) 是因为 <script> 可能包含带有副作用的生命周期钩子，所以将重新渲染替换为重新加载是必须的，这样做可以确保组件行为的一致性。这也意味着，如果你的组件带有全局副作用，则整个页面将会被重新加载。\n\n<style> 会通过 vue-style-loader 自行热重载，所以它不会影响应用的状态。\n\n用法\n当使用脚手架工具 vue-cli 时，热重载是开箱即用的。\n\n当手动设置你的工程时，热重载会在你启动 webpack-dev-server --hot 服务时自动开启。\n\n高阶用户可能希望移步 vue-loader 内部使用的 vue-hot-reload-api 继续查阅。\n- https://github.com/vuejs/vue-hot-reload-api/blob/master/src/index.js\n\n关闭热重载\n热重载默认是开启的，除非遇到以下情况：\n\nwebpack 的 target 的值是 node (服务端渲染)\nwebpack 会压缩代码\nprocess.env.NODE_ENV === 'production'\n你可以设置 hotReload: false 选项来显式关闭热重载：\n\nmodule: {\n  rules: [\n    {\n      test: /\\.vue$/,\n      loader: 'vue-loader',\n      options: {\n        hotReload: false // 关闭热重载\n      }\n    }\n  ]\n}\n```\nwebpack-dev-server\n\n- https://webpack.js.org/concepts/hot-module-replacement/#root\n- https://webpack.docschina.org/concepts/hot-module-replacement/\n- https://webpack.docschina.org/guides/hot-module-replacement/\n```\n模块热替换(hot module replacement)\n这一切是如何运行的？How It Works\n在应用程序中In the Application\n在 compiler 中In the Compiler\n在模块中In a Module\n在 runtime 中In the Runtime\n```\n```\n从 webpack-dev-server v4.0.0 开始，热模块替换是默认开启的。\n\ndevServer: {\n      static: './dist',\n     hot: true,\n    },\n```\n```\nvue-cli-service serve\n用法：vue-cli-service serve [options] [entry]\n\n选项：\n\n  --open    在服务器启动时打开浏览器\n  --copy    在服务器启动时将 URL 复制到剪切版\n  --mode    指定环境模式 (默认值：development)\n  --host    指定 host (默认值：0.0.0.0)\n  --port    指定 port (默认值：8080)\n  --https   使用 https (默认值：false)\nvue-cli-service serve 命令会启动一个开发服务器 (基于 webpack-dev-server) 并附带开箱即用的模块热重载 (Hot-Module-Replacement)。\n除了通过命令行参数，你也可以使用 vue.config.js 里的 devServer 字段配置开发服务器。\n命令行参数 [entry] 将被指定为唯一入口，而非额外的追加入口。尝试使用 [entry] 覆盖 config.pages 中的 entry 将可能引发错误。\nconst server = new WebpackDevServer(Object.assign({\n      historyApiFallback: {\n        disableDotRule: true,\n        htmlAcceptHeaders: [\n          'text/html',\n          'application/xhtml+xml'\n        ],\n        rewrites: genHistoryApiFallbackRewrites(options.publicPath, options.pages)\n      },\n      hot: !isProduction\n    }, \n```\n\n- https://webpack.docschina.org/guides/hot-module-replacement/#other-code-and-frameworks\n## hot reload - flutter"},{"title":"React-PureComponent","url":"/2021/12/15/React-PureComponent/","content":"> 当我们在React中，搜React.pureComponent时，\nhttps://github.com/facebook/react/pull/7195\n\n### changelog\n以下两处\n```\n## 15.3.0 (July 29, 2016)\n\n### React\n- Add `React.PureComponent` - a new base class to extend, replacing `react-addons-pure-render-mixin` now that mixins don't work with ES2015 classes. ([@sophiebits](https://github.com/sophiebits) in [#7195](https://github.com/facebook/react/pull/7195))\n\n## 16.1.0 (November 9, 2017)\n### React Test Renderer and Test Utils\n\n* Handle `forceUpdate()` and `React.PureComponent` correctly. ([@koba04](https://github.com/koba04) in [#11440](https://github.com/facebook/react/pull/11440))\n\n```\n\n### 为什么提供这个\n- https://github.com/facebook/react/pull/7195\n\n#### sophiebits commented on 6 Jul 2016\nThis provides an easy way to indicate that components should only rerender when given new props, like PureRenderMixin. If you rely on mutation in your React components, you can continue to use React.Component.\n\nInheriting from React.PureComponent indicates to React that your component doesn't need to rerender when the props are unchanged. We'll compare the old and new props before each render and short-circuit if they're unchanged. It's like an automatic shouldComponentUpdate.\n\n## doc\n```\nReact.PureComponent\nReact.PureComponent 与 React.Component 很相似。两者的区别在于 React.Component 并未实现 shouldComponentUpdate()，而 React.PureComponent 中以浅层对比 prop 和 state 的方式来实现了该函数。\n\n如果赋予 React 组件相同的 props 和 state，render() 函数会渲染相同的内容，那么在某些情况下使用 React.PureComponent 可提高性能。\n\n注意\n\nReact.PureComponent 中的 shouldComponentUpdate() 仅作对象的浅层比较。如果对象中包含复杂的数据结构，则有可能因为无法检查深层的差别，产生错误的比对结果。仅在你的 props 和 state 较为简单时，才使用 React.PureComponent，或者在深层数据结构发生变化时调用 forceUpdate() 来确保组件被正确地更新。你也可以考虑使用 immutable 对象加速嵌套数据的比较。\n\n此外，React.PureComponent 中的 shouldComponentUpdate() 将跳过所有子组件树的 prop 更新。因此，请确保所有子组件也都是“纯”的组件。\n```\n\n## 参考阅读\n- https://reactjs.org/blog/2016/07/13/mixins-considered-harmful.html"},{"title":"聊聊类","url":"/2021/12/08/聊聊类/","content":"> 是特定类型的数据和方法的集合，也是创建对象的模板\n\n## 定义和初始化\nEs6\nTypescript\nDart\n\n## 解决复用问题\n接口\n继承\n混入\n"},{"title":"函数参数","url":"/2021/12/08/函数参数/","content":"\n## 命名参数 - 可读性\n- Dart｜Python都有，可以解决查文档记位置的问题（虽然写的时候吧，IDE的doc提示也很便捷，但是有的话代码可读性好了很多）—— 让函数 声明\n```\n# Dart\n在声明函数时：\n{paramName: value, paramName: value} 命名参数\n[] - 可选参数\n```\n- JS 早期配置对象参数来解决这个问题 —— 但是可读性还是不行\n\n- ES6（解构赋值 ｜ 函数默认值 ）—— 可读性好了，约束还是没有\n\n- TS 写法加入TS本身类型，同ES6的表示方式（```{}: {}={}```），本质上还是对象参数，https://github.com/Microsoft/TypeScript/issues/467\n\n## 可选参数 - 约束性\n- Dart\n\n- TS - ?: 设置可选参数\n\n## 说一句\nC++ 与 Java ，提供函数的重载，即提供同名但参数不同的函数，来解决命名参数+可选参数解决的问题；"},{"title":"微服务-notes-公司微服务遇到的问题和解决方案","url":"/2021/12/08/微服务-notes-公司微服务遇到的问题和解决方案/"},{"title":"flat-聊聊","url":"/2021/12/08/flat-聊聊/","content":"## MDN\n- http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/flat\n\n- MDN的文档里面，有alternatives，可以看下实现此功能的方式"},{"title":"python-flask-聊聊设计思想","url":"/2021/12/01/python-flask-聊聊设计思想/","content":"> https://dormousehole.readthedocs.io/en/latest/\n\n### doc\n- https://github.com/pallets/flask\n\n## notes\n\n### Jinjia2 \n\nTime 问题\n\n### py 2->3\n其中提到如下:在py3之后，引入方式已经发生了改变\nfrom flask.ext.wtf import Form\n\n解决办法: 改变引入方式为:\nfrom flask_wtf import Form\n\n### http\n重定向 经常 使用 302 状态 码表 示， 指向 的 地址 由 Location 首部 提供。 重定向 响应 可以 使用 3 个 值 形式 的 返回 值 生成， 也可 在 Response 对象 中 设定。 不过， 由于 使用 频繁， Flask 提供 了 redirect() 辅助 函数，\n\n格林布戈(Miguel Grinberg). Flask Web开发 基于Python的Web应用开发实战 (图灵程序设计丛书) (p. 14). 人民邮电出版社. Kindle 版本.\n定义如下：\n301 Moved Permanently 被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个URI之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。\n\n302 Found 请求的资源现在临时从不同的URI响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。\n字面上的区别就是301是永久重定向，而302是临时重定向。 当然，他们之间也是有共同点的，就是用户都可以看到url替换为了一个新的，然后发出请求。\n \n \n301适合永久重定向\n　　301比较常用的场景是使用域名跳转。\n　　比如，我们访问 http://www.baidu.com 会跳转到 https://www.baidu.com，发送请求之后，就会返回301状态码，然后返回一个location，提示新的地址，浏览器就会拿着这个新的地址去访问。 \n　　注意： 301请求是可以缓存的， 即通过看status code，可以发现后面写着from cache。\n　    或者你把你的网页的名称从php修改为了html，这个过程中，也会发生永久重定向。\n \n \n302用来做临时跳转\n　　比如未登陆的用户访问用户中心重定向到登录页面。\n　　访问404页面会重新定向到首页。 \n##niginx 301/302配置\nrewrite后面接上permenent就代表301跳\n//把来自veryyoung.me的请求301跳到 www.veryyoung.me\nif ($host != 'veryyoung.me') {\n    rewrite ^/(.*)$ http://www.veryyoung.me/$1 permanent;\n}\n \n接上redirect就代表302跳\n//把来自veryyoung.me的请求302跳到 www.veryyoung.me\nif ($host != 'veryyoung.me') {\n    rewrite ^/(.*)$ http://www.veryyoung.me/$1 redirect;\n}\n \n \n301重定向和302重定向的区别\n　　302重定向只是暂时的重定向，搜索引擎会抓取新的内容而保留旧的地址，因为服务器返回302，所以，搜索搜索引擎认为新的网址是暂时的。\n　　而301重定向是永久的重定向，搜索引擎在抓取新的内容的同时也将旧的网址替换为了重定向之后的网址。\n\n### 枚举\n可读性比数字强\n\n\n### 如果要注册视图函数，要实例化一个函数红图对象\n\n\n### 关于用户的思考\n- 不仅仅人\n- API ，开放性，通用性\n- 装饰器\n\n\n### REST\n\n### wtforms\nhttp://wtforms.simplecodes.com/docs/0.6/index.html"},{"title":"3d数据可视化","url":"/2021/12/01/3d数据可视化/","content":"> 学习机里面的互动机器人\n\n## 工具篇\n- D3\n- 图表库\n- GIS\n\n## webgl（图形系统）\n- web graphics library\n- opengl es 2.0\n（还有HTML+CSS ｜ SVG ｜ Canvas）\n## lib - 图形库\n- threejs,babylonjs scenejs,cesiumjs\n\n## 各种手机官方网站\n- like apple\n- vivo\n\n## 3d model\n- obj - 纯文本 - 动画支持较弱\n- fbx - 二进制 - 不同引擎解析差异\n- gltf - json - 扩展性好\n- 模型文件\n\n\n## basics\n- 相机 - 投影\n- 光照\n- 旋转模型\n- 全景\n- 性能（模型压缩）\n\n## gltf vs fbx\n- https://www.threekit.com/blog/gltf-vs-fbx-which-format-should-i-use\n- 不同引擎提供的导入工具，也会要求不同的fbx导出处理方式，从而达到最好的效果\n\n\n## vizceral\n- https://github.com/Netflix/vizceral\n- vizceral is a component for displaying traffic data on a webgl canvas. If a graph of nodes and edges with data about traffic volume is provided, it will render a traffic graph animating the connection volume between nodes.\n\n\n## 可视化 - Basic\n### Basics\n- CPU 运算单位\n- GPU 图形处理单元\n- 可视化更重要的是利用WebGL这样的图形系统，来更高效的去实现更多有趣的图形\n\n- 数据 => 视觉\n- 数据（设计语言 - 数据建模 - 数据分析）\n- 视觉（工具｜图形库｜图形系统｜理论basic）\n- 可视化 - 性能\n\n\n#### others\n#### spritejs\n- 跨平台的开源图形系统\n\n\n#### 绘制一个三角形\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>test</title>\n</head>\n\n<body>\n    <canvas width=\"300\" height=\"300\"></canvas>\n    <script>\n        // 创建webgl上下文\n        const canvas = document.querySelector('canvas')\n        const gl = canvas.getContext('webgl')\n\n\n        // 创建WebGL程序\n        // glsl - 顶点着色器 - 处理顶点的CPU程序代码\n        const vertex = `\n            attribute vec2 position;\n            varying vec3 color;\n            void main() {\n                gl_PointSize = 1.0;\n                color = vec3(0.5 + position * 0.5, 0.0);\n                gl_Position = vec4(position * 0.5, 1.0, 1.0);\n            }\n            `;\n        // 片元着色器 - 处理光栅化后的像素信息\n        const fragment = `\n            precision mediump float;\n            varying vec3 color;\n            void main() \n            {\n                gl_FragColor = vec4(color, 1.0);\n            }\n            `;\n\n        // shader 对象创建\n        const vertexShader = gl.createShader(gl.VERTEX_SHADER)\n        gl.shaderSource(vertexShader, vertex)\n        gl.compileShader(vertexShader)\n\n        const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER)\n        gl.shaderSource(fragmentShader, fragment)\n        gl.compileShader(fragmentShader)\n\n\n        // webglprogram obj create\n        const program = gl.createProgram()\n        gl.attachShader(program, vertexShader)\n        gl.attachShader(program, fragmentShader)\n        gl.linkProgram(program)\n        // use webglprogram obj\n        gl.useProgram(program)\n\n        // 数据存入缓冲区\n        const points = new Float32Array([-1, -1, 0, 1, 1, -1])\n        // create buffer obj\n        const bufferId = gl.createBuffer()\n        // bind as current\n        gl.bindBuffer(gl.ARRAY_BUFFER, bufferId)\n        // write\n        gl.bufferData(gl.ARRAY_BUFFER, points, gl.STATIC_DRAW)\n\n        // gpu 加载缓存中的数据\n        // get vertex position\n        const vPosition = gl.getAttribLocation(program, 'position')\n        // set length and type\n        gl.vertexAttribPointer(vPosition, 2, gl.FLOAT, false, 0, 0)\n        // activate\n        gl.enableVertexAttribArray(vPosition)\n\n        // 绘制图形\n        gl.clear(gl.COLOR_BUFFER_BIT)\n        gl.drawArrays(gl.TRIANGLES, 0, points.length / 2)\n    </script>\n</body>\n\n</html>\n```"},{"title":"phaser-games","url":"/2021/12/01/phaser-games/","content":"## doc\n- Phaser is a fun, free and fast 2D game framework for making HTML5 games for desktop and mobile web browsers, supporting Canvas and WebGL rendering.\n\n- phaser.io\n\n\n## example\n- https://github.com/eijil/hexigua\n- https://github.com/photonstorm/phaser3-project-template"},{"title":"AI相关","url":"/2021/12/01/AI相关/","content":"## 工作相关\n### 智能批改作业\n\n\n## 阅读相关\n\n\n\n## 手淘端上AI大规模应用与实践 - QConf\n- https://qcon.infoq.cn/2019/shanghai/track/635\n- https://developer.aliyun.com/article/782665\n"},{"title":"tech-commercial-cases","url":"/2021/12/01/tech-commercial-cases/","content":"### Ashton-Tate - dBase\n- https://zh.wikipedia.org/wiki/DBase\n- http://www.dbase.com/dbasesql/\n- 问题：向后兼容，编译器"},{"title":"CSSModules-React-Vue","url":"/2021/11/29/CSSModules-React-Vue/","content":"> 最近做新项目，涉及多个团队，查问题的时候用上了我的样式搜索定位大法，诶，搜不到，哦，原来搜的关键词不准确，拉了代码瞅瞅，React组用了 CSS Modules\n\n## React - Usages\n- https://github.com/camsong/blog/issues/5\n\n- react-app-rewired 插件支持\n- creat-react-app , webpack css-loader 里面 modules 进行设置\n\n## Vue - Usages\n- https://vue-loader.vuejs.org/zh/guide/css-modules.html#%E7%94%A8%E6%B3%95\n- 看上面文档来就行\n- 现在项目脚手架默认生成配置用的是scoped CSS\n\n## CSS moudles\n- 原理：class名 hash值\n- https://github.com/css-modules/css-modules\n```\nWebpack's css-loader in module mode replaces every local-scoped identifier with a global unique name (hashed from module name and local identifier by default) and exports the used identifier.\n```\ncomposition 组合 compose 嵌套\n- BEM\nBlock  Element  Modifier => 模块名 节点名 节点状态 => name local hash:base64\n- 公用样式｜局部化\n\n### styled-components\n- Visual primitives for the component age.\nUse the best bits of ES6 and CSS to style your apps without stress\n- 适合React - all in js\n- https://github.com/styled-components/awesome-styled-components\n- 如果要用iconfont的话，需要处理iconfont对应的文件\n\n## CSS模块化\n- 防止全局污染，样式覆盖\n- 命名混乱\n- CSSS代码冗余\n### React CSS模块化\n- CSS module\n- css in js\n\n#### CSS module\n- css-loader配置\n- 自定义命名规则\n- 全局变量\n- 组合样式\n- 配置less和sass\n- 全局或者公共组件样式，用.css文件\n- 页面和业务组件，用scss｜less\n- 配合classNames库，实现更灵活的动态添加类名\n\n#### CSS module使用tips\n- 仅用 class 类名定义 css ，不使用其他选择器\n- 不要嵌套 css .a{ .b{} } 或者重叠 css .a .b {} \n\n#### CSS in JS\n- CSS IN JS 本质上 - 用 js 中对象形式保存样式\n- 拓展运算符实现样式继承\n- style-components - 基于 props 动态添加样式 - https://styled-components.com/docs/"},{"title":"互动题播放器","url":"/2021/11/29/互动题播放器/","content":"\n\n# 互动视频播放器\n### 视频自动播放  \n- https://video-dev.github.io/can-autoplay/\n\n处理play()是个异步方法的问题\n```\nSentry报错\n1.\nChrome\nError: AbortError: The play() request was interrupted by a call to pause(). https://goo.gl/LdLk22\n2.\nSafari\nError: AbortError: The operation was aborted.\nAbortError: The operation was aborted.\n\n```\n解决方案：就是把play()按照API说明当成异步的去用即可\n- https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/play\n- https://developer.chrome.com/blog/play-request-was-interrupted/\n\n\n- https://developer.mozilla.org/en-US/docs/Web/Media/Autoplay_guide\n\n### Sentry Errors\n- Error: ResizeObserver loop limit exceeded\n- https://stackoverflow.com/questions/49384120/resizeobserver-loop-limit-exceeded%E3%80%82\n- https://github.com/WICG/resize-observer/issues/38\nThis error means that ResizeObserver was not able to deliver all observations within a single animation frame. It is benign (your site will not break). – Aleksandar Totic"},{"title":"编辑器搜罗分析","url":"/2021/11/29/编辑器搜罗分析/","content":"> 教育行业离不开编辑器，公式的，课程教学大纲录入的，题目录入的，互动课程录入的，学生作答使用的；这篇持续更新，瞅着的，自己用的，编辑器相关的嘿；\n\n## Notion\n- https://zhuanlan.zhihu.com/p/359122473?utm_source=wechat_timeline&utm_medium=social&utm_oi=29878166487040&s_r=0\n\n\n## 语雀\n\n- https://www.yuque.com/yuque/blog/ec97tf\n\n在线时代先进文档编辑器设计探索-Suki\n\n- https://www.yuque.com/yuque/blog/uq7e2f#bk9KK\n\n三甲：在线富文本编辑器的架构设计及实践\n\n## basics\n### draft-js\n- https://draftjs.org/docs/getting-started/\n\n### https://github.com/facebook/lexical\n\n\n## essays\n- https://www.yuque.com/antfe/featured/sklw78575iy3gh1z - 里面总结了编辑器技术的发展\n\n#### monaco-editor\n- https://github.com/wobsoriano/codeplayground\n\n#### tinymce\n- Web based JavaScript HTML WYSIWYG editor control.\n\n### pptist\n- https://github.com/pipipi-pikachu/PPTist.git\n\n### slidev\n- https://github.com/slidevjs/slidev\n\n#### wangEditor\n- https://www.wangeditor.com/\n\n#### quill\n- https://github.com/quilljs/quill"},{"title":"Electron实战入门进阶与性能优化-精读","url":"/2021/11/29/Electron实战入门进阶与性能优化-精读/","content":"> 刘晓伦. Electron实战：入门、进阶与性能优化(本书以Electron为主线，还介绍了大量的JavaScript、HTML、CSS、Node.js、桌面软件开发、多进程控制、安全、社区资源及背景故事等知识，是一本兼具广度和深度的图书。) (Chinese Edition) (Kindle 位置 3942-3944). Kindle 版本. \n\n> 还行，单位做了几个项目之后，Kindle买了随便看看，跟着顺了一遍\n\n## history\n### compare\n- 比较了下NW.js\n- https://github.com/nwjs/nw.js (钉钉早期桌面端使用过)\n- 瞅着还一直有tags打，现在是v0.58.0\n\n### "},{"title":"松本行弘的程序世界-函数式编程-阅读笔记","url":"/2021/11/29/松本行弘的程序世界-函数式编程-阅读笔记/","content":"## 新范型-函数式编程\n\n## 自动生成代码\n\n## 内存管理与垃圾收集\n\n## 用C语言来扩展\n\n## 为什么要开源"},{"title":"松本行弘的程序世界-高速和并行-安全-时间-数据持久化-阅读笔记","url":"/2021/11/29/松本行弘的程序世界-高速执行和并行处理-阅读笔记/","content":"## 高速执行和并行处理\n### 让程序高速执行\n### 并行编程\n### Actor\n\n\n## 程序安全性\n### 程序的漏洞与攻击方法\n### 用异常进行错误处理\n\n\n## 关于时间的处理\n### 用程序处理时刻与时间\n\n## 关于数据的持久化\n### 持久化数据的方法\n### 对象的保持\n### 关于XML的考察\n\n### 锁模型与队列模型的比较\n- 与线程相关的程序-debug难\n- 因为时机不同，有时发生，有时不发生\n- 资源访问-方法调用，变量引用等处理\n#### 防止资源竞争的手段\n- 使用锁的锁模型\n- 使用队列的队列模型\n\n#### 锁模型\n- 竞争足够少-较高性能\n\n#### 队列模型\n- 比锁模型更容易贯彻\n- 很少会因为线程增多而带来性能低下的恶果\n- Erlang-采用了与队列模型本质上等价的消息存储\n- 今后，多核或具有扩展性的队列模型获取会成为主流"},{"title":"松本行弘的程序世界-文字编码-正则-整数小数-阅读笔记","url":"/2021/11/29/松本行弘的程序世界-文字编码-正则-整数小数-阅读笔记/","content":"## 文字编码\n### 文字编码的种类\n### 程序中的文字处理\n\n## 正则表达式\n### 正则表达式基础\n### 正则表达式的应用实例与鬼车\n\n\n\n## 整数和浮点小数\n- Floating Point Numbers\n- https://floating-point-gui.de/formats/fp/\n- https://softwareengineering.stackexchange.com/questions/280648/why-is-negative-zero-important/\n\n### 深奥的整数世界\n### 扑朔迷离的浮点小数时间\n\n\n## others\n### 正则notes\n```\n正则表达式——是一个特殊的字符序列，一个字符串是否与我们所设定的字符序列相匹配\n（爬虫）\n快速检索文本，实现一些替换文本的操作\n\n1.检查一串数字是否是电话号码\n2.检测一个字符串是否符合email\n3.把一个文本里指定的单词替换为另外一个单词】】】\n\nJSON（XML）数据交互格式\n\n\na.index('Python') > -1\n'python' in a\n\n\nImport re\n\nre.findall('Python',a)\n\n所有字符串的问题都能用for in 循环解决\n\n00:15:57\n\n普通字符 'python'\n元字符 '\\d'\n\n\n普通字符可以帮助定界\n字符集\n[]或\n[ ] 里面是或关系\n\n\n[^]\n\n[a-d]\n\n00:31:32\n\n\n\n概括字符集\n\\d \\D \n\\w 单词字符 [A-Za-z0-9_] \\W\n\\s 空白字符 \\S\n. 匹配除换行符\\n之外其他所有字符\n\n匹配单一的字符\n\n\n数量词：\n\n[a-z]{3,6\u0010}\n贪婪，非贪婪\n默认倾向于贪婪的匹配方式\n\n[a-z]{3,6\u0010}? 非贪婪\n\n匹配*前的字符0次或者无限多次\n匹配+前的字符1次或者无限多次\n匹配？前的字符0次或者1次\n\n边界匹配！！！\n^ $\n\n组\n() 里面是且的关系\n\n\n\n模式\n模式参数\nre.I | re.S\n\nre.sub('a', 'b', language, 1)\n\n第二个参数可以是函数(设计方式，开放逻辑编写给用户)\n\n可以根据匹配内容的不同，做判断，做字符的重新组合\n\nValue.group()\n\n\nre.match\nre.search \n\n.group()\n.span()\n\n.group(0) 完整匹配结果\n\n.groups()\n\n很好用的工具\n\n解决字符串相关的问题\n\n爬虫，校验\n\n```"},{"title":"松本行弘的程序世界-我为什么开发Ruby-面向对象-程序块-设计模式-Ajax-RoRs-阅读笔记","url":"/2021/11/29/松本行弘的程序世界-我为什么开发Ruby-面向对象-程序块-设计模式-Ajax-RoRs-阅读笔记/","content":"## 我为什么开发Ruby\n> 因为它给我带来了快乐\n> 松本行弘. 松本行弘的程序世界 (图灵程序设计丛书) (Chinese Edition) (Kindle位置116). 人民邮电出版社. Kindle 版本. \n\n### Lines\n- 语言体现了人类思考的本质\n- 程序员由于使用的编程语言不同，他的思考方法和编写出来的代码都会受到编程语言的很大影响。\n- Ruby编程语言的设计目标是，让作为语言设计者的我能够轻松编程，进而提高开发效率。\n#### 设计原则\n- 简洁性\n - Lisp(Paul Graham - 简洁就是力量)\n - Ruby不进行明确的数据类型定义，不必要的声明都可以省略\n - 如果可以把伪码中非实质的东西去掉，只保留描述算法的部分就直接运行，那么这种编程语言不就是最好的吗？Ruby的目标就是成为开发效率高、“能直接运行的伪码式编程语言”\n- 扩展性\n - 实现扩展性的一个重要方法是抽象化\n - 很多面向对象或者函数式的现代编程语言，都在抽象化方面做得很好\n - 关于扩展性，有一点是不能忽视的，即“不要因为想当然而加入无谓的限制”。比如说，刚开始开发Unicode时，开发者想当然地认为16位（65535个字符）就足够容纳世界上所有的文字了；同样，Y2K问题也是因为想当然地认为用2位数表示日期就够了才导致的。从某种角度说，编程的历史就是因为想当然而失败的历史。而Ruby对整数范围不做任何限定，尽最大努力排除“想当然”。\n- 稳定性\n - 拒绝了宏\n - 稳定的语法\n\n## 面向对象\n### 编程和面向对象的关系\n### 数据抽象和继承\n### 多重继承的缺点\n### 两个误解\n### duck Typing诞生之前\n### 元编程\n\n\n## 程序块\n### 程序块的威力\n### 用块做循环\n### 精通集合的使用\n\n\n## 设计模式\n\n\n\n## Ajax\n- https://developer.mozilla.org/zh-CN/docs/Web/Guide/AJAX\n- https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest\n- 90年代末 - MS Outlook =>IE (XMLHttp) | 其他浏览器XMLHttpRequest => 使浏览器能从JavaScript中发出Http请求\n- 2005 => Jesse James Garrentt => https://courses.cs.washington.edu/courses/cse490h/07sp/readings/ajax_adaptive_path.pdf => 本质：用XHR获取数据，然后修改当前页面\n- 创建XHR对象 - 告诉该对象要请求什么信息，设置成功或错误处理程序，然后实际地发送请求（new | open | onload | onerror | send）\n#### fetch - 新的API\n- 基于promise\n- https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API\n\n## Ruby on Rails\n### MVC 和 Ruby on Rails\n### 开放类和猴子补丁\n\n###\netching bundler-2.3.26.gem\nERROR: While executing gem ... (Gem::FilePermissionError)\nYou don't have write permissions for the /Library/Ruby/Gems/2.6.0 directory.\n这个错误意味着你没有足够的权限来向这个目录写入文件。这在OS X上是常见的问题，因为这个目录是由系统拥有的。\n\n要解决这个问题，你有两个选择。\n\n第一个选择是使用sudo命令来运行gem install：\n\n```bash\nsudo gem install bundler -v 2.3.26\n```\n\n这将给你足够的权限来安装gem，但是这可能会让你的系统环境被修改，这是一种不推荐的做法。\n\n第二个更好的选择是安装一个版本管理器，例如RVM或RBENV。这些版本管理器为你的Ruby版本和Gem创建了一个单独的环境，这样你就可以在不修改系统环境的情况下安装它们。\n\n例如，你可以通过下面的步骤安装RVM和新版本的Ruby：\n\n```bash\n\\curl -sSL https://get.rvm.io | bash -s stable\nrvm install 2.7.0\nrvm use 2.7.0\ngem install bundler -v 2.3.26\n```\n\n这将安装RVM，然后使用RVM安装Ruby 2.7.0，然后切换到这个新版本的Ruby，最后安装所需版本的bundler。"},{"title":"编程语言的设计与实现-强化流编程-阅读笔记","url":"/2021/11/29/编程语言的设计与实现-强化流编程-阅读笔记/"},{"title":"编程语言的设计与实现-设计面向对象功能-实现Streem的对象-阅读笔记","url":"/2021/11/29/编程语言的设计与实现-设计面向对象功能-实现Streem的对象-阅读笔记/"},{"title":"代码的未来-云计算时代的编程-支撑大数据的存储技术-阅读笔记","url":"/2021/11/29/代码的未来-云计算时代的编程-支撑大数据的存储技术-阅读笔记/","content":"> 云计算时代的编程\n## 可扩展性\n\n\n## C10K问题\n\n\n## HashFold\n\n\n## 进程间通信\n\n\n## Rack与Unicorn\n\n\n> 支撑大数据的数据存储技术\n## 键-值存储\n\n## NoSQL\n\n## 用Ruby操作MongoDB\n\n\n## SQL数据库的反击\n\n\n## memcached和它的伙伴们\n\n## 布隆过滤器\n布隆过滤器（Bloom Filter）是一种空间效率极高的概率型数据结构，用于检测一个元素是不是集合的成员。布隆过滤器可以判断元素绝对不在集合中或可能在集合中，也就是说，它存在一定的误判概率。但是，布隆过滤器的这种“猜测”错误只会是在声明元素存在时，而如果布隆过滤器说元素不存在，那就肯定不存在。\n\n布隆过滤器主要应用于大数据和分布式系统，例如Google的大表和Hadoop的Hbase，以减小误判造成的I/O操作，也可以用于网络爬虫中对URL的重复过滤，防止爬虫陷入死循环等。\n\n这种数据结构最早是由Burton Howard Bloom在1970年提出的，之所以命名为“布隆过滤器”，就是以他的名字命名的。\n\n如需深入学习，以下是我为您推荐的一些论文：\n\n\"Space/time trade-offs in hash coding with allowable errors\" by Bloom, Burton H. 1970.\n\"Bloom Filters in Probabilistic Verification\" by Peter C. Dillinger and Panagiotis Manolios, 2004.\n\"Network Applications of Bloom Filters: A Survey\" by Broder and Mitzenmacher, 2002."},{"title":"代码的未来-编程语言的新潮流-多核时代的编程-阅读笔记","url":"/2021/11/29/代码的未来-编程语言的新潮流-多核时代的编程-阅读笔记/","content":"> 编程语言的新潮流\n## 语言的设计\n\n## Go\n\n## Dart\n\n\n## CoffeScript\n\n## Lua\n> 多核(“运行一个软件系统可以利用多个CPU核心”)时代的编程\n“多核环境中编程的共同点在于，在传统的编程风格中，程序是顺序执行的，因此只能用到单独一个核心。而要充分发挥多核的优势，就必须通过某些方法，积极运用多个CPU的处理能力。” --cite\n\n## 摩尔定律\n\n## UNIX管道\n\n\n## 非阻塞I/O\n\n## node.js\n- 通过node.js这一彻底杜绝等待的非阻塞框架，对拖延策略进行了具体的实践\n\n## ZeroMQ\n- https://github.com/zeromq/libzmq\n- https://zeromq.org/"},{"title":"代码的未来-编程的时间和空间-语言的过去现在和未来-阅读笔记","url":"/2021/11/29/代码的未来-编程的时间和空间-语言的过去现在和未来-阅读笔记/","content":"## 编程的时间和空间\n### 编程的本质\n### 未来预测\n\n\n## 编程语言的过去，现在和未来\n### 编程语言的世界\n### DSL - 特定领域语言\n### 元编程\n### 内存管理\n### 异常处理\n### 闭包\n\n"},{"title":"easy-monitor-3-接入","url":"/2021/11/23/easy-monitor-3-接入/","content":"### Doc\n- https://www.yuque.com/hyj1991/easy-monitor/deployment\n\n\n\n### pre\n- https://stackoverflow.com/questions/50093144/mysql-8-0-client-does-not-support-authentication-protocol-requested-by-server\n```\nALTER USER 'root' IDENTIFIED WITH mysql_native_password BY 'password';\n```\n\n\n## 服务部署\n```\nwget https://repo.mysql.com//mysql80-community-release-el8-1.noarch.rpm\n\n\nmysql:\n\nyum -y install nodejs\nnpm install -g n\nyum install git -y\n\n# 项目可以fork一下，把config.prod.js加一下，推上去\ngit clone https://github.com/X-Profiler/xprofiler-console\ngit clone https://github.com/X-Profiler/xtransit-manager\ngit clone https://github.com/X-Profiler/xtransit-server\n\nwget https://repo.mysql.com//mysql80-community-release-el8-1.noarch.rpm\nrpm -ivh mysql80-community-release-el8-1.noarch.rpm\nyum install mysql-server\n\nhttps://dev.mysql.com/doc/refman/8.0/en/linux-installation-yum-repo.html\n\nservice mysqld restart\n\ngrep 'temporary password' /var/log/mysqld.log\nmysql -uroot -p\nalter user 'root'@'localhost' identified by 'xxxxxxxxx';\n\n根据centos是7还是8安装对应的mysql,如80的安装在centos7上面就会出现问题\n\n# /usr/bin/mysqladmin -u root password 'xxxx'\nmysql -h localhost -u root -p\n> create database xprofiler_logs;\n> create database xprofiler_console;\n\ncd xtrainsit-console/db\nmysql -uroot -pxxxxxxxxx; -h127.0.0.1 -D 'xprofiler_console' < ./init.sql\n\ncd xtrainsit-manager/db\nmysql -uroot -pxxxxxxxxx -h127.0.0.1 -D 'xprofiler_logs' < ./init.sql\nmysql -uroot -pxxxxxxxxx -h127.0.0.1 -D 'xprofiler_logs' < ./date.sql\n\n\n\nredis\n\nwget http://download.redis.io/releases/redis-5.0.8.tar.gz\ntar -xvf redis-5.0.8.tar.gz\nmv redis-5.0.8 /usr/local\ncd /usr/local/redis-5.0.8/\nyum list gcc\nyum list tcl\nyum install gcc # 版本\nyum install tcl # 版本\nmake MALLOC=libc\nmake test\ncd src && make install\nvim redis.conf # daemon yes\n./src/redis-server ./redis.conf\n\n\nnginx 增加域名\nemconsole.xxx.cn\n172.111.111.111 emconsole.xxx.cn\n\n/usr/local/tengine/sbin/nginx -s reload\n/usr/local/tengine/sbin/nginx -t \n\n\n进入到gitlab各个项目下面，npm start\n\n```\n\n## prometheus\n- 我们这边机器的监控是运维团队基于prometheus做的\n- 目前Prometheus是按照k8s集群部署的, 每一个K8s集群都由独立的Prometheus来监控, (Prometheus部署在当前集群中)\n- https://prometheus.io/docs/introduction/overview/\n- 各个node运行node_exporter供prometheus采集数据，运行consul客户端注册节点信息向consul服务端，prometheus server从consul服务端获取所有的node节点，通过prometheus-es-adapter将数据持久化到es。配置alertmanager告警规则触发告警，监控指标图表通过grafana来查看\n- jdk\t｜ go ｜node-exporter ｜ prometheus-es-adapter\t｜prometheus ｜ alertmanager｜ consul ｜elasticsearch ｜ kibana ｜grafana\t\n- 基于Prometheus 和 thanos 进一步增加了异常检测机制.  基于机器学习对阈值进行动态检测\n\n\n### 转储\n```\nconnect ECONNREFUSED 127.0.0.1:8443, POST http://127.0.0.1:8443/xapi/upload_from_xtransit?fileId=4&fileType=heapsnapshot&nonce=74904800742&timestamp=1646389590491&signature=a331a7a4fe28cdd275bfa0df3d937d9e4ca40c6a -1 (connected: false, keepalive socket: false, socketHandledRequests: 1, socketHandledResponses: 0) headers: {}\n```\n\n- config.xprofilerConsole = 'xxx';\n- 这部分会提供给应用端，在调用转储的时候，应用端上传文件时候会请求 \n```\n  const url = `${server}/xapi/upload_from_xtransit?${qs.stringify({ fileId, fileType, nonce, timestamp, signature })}`;\n```\n- 这个里面的server，就从xprofilerConsole来，所以正式环境部署的时候，要给到能连通的url\n- 分析策略，看给的各个应用服务的流程图，分析原因\n\n### log_dir\n性能分析文件会比较大，尽量不要放在会太影响memory的位置\n\n\n### 一次内存泄漏问题排查\n\n- 基于puppeteer的一个转svg的node服务\n- 做压力测的时候，间隔时间gc,gc之后内存会往上涨\n- 借助easy-monitor3, 堆快照，发现TCP -> Socket -> WebSocket 是泄漏点\n- Search具体的，发现是WS\n- 在package-lock里面搜ws ,发现被puppeteer依赖\n- 这个时候查处理puppeteer部分的代码，发现有代码处理逻辑上，会错误的建立connect（对API使用有问题）\n- 让处理了下这部分代码，解决问题\n\n\n### docker + k8s\n- https://www.yuque.com/hyj1991/easy-monitor/advance_docker\n\n### 同类产品\nNearForm 是一家总部位于爱尔兰的软件开发公司，他们专注于构建高性能、可扩展的 Node.js 和 JavaScript 应用程序。Clinic 是 NearForm 提供的一套开源工具，从多个角度帮助开发者识别和解决 Node.js 应用程序中的性能问题。该工具包括以下三个主要组件：\n\n1. Clinic Doctor：此工具可帮助诊断应用程序中的常见性能问题，例如内存泄漏、CPU 泄漏或事件循环拥堵。通过可视化指标，Clinic Doctor 可以给出关于如何提高性能的建议。\n\n2. Clinic BubbleProf：BubbleProf 是一种可视化数据流的工具，它可以帮助开发者了解应用程序中不同操作之间的关系。通过观察这些关系，开发者可以更容易地找到性能瓶颈和优化点。\n\n3. Clinic Flame：Flame 是一个 CPU 火焰图分析器，它可以帮助开发者识别应用程序中的热点代码。它使用堆栈跟踪和定时器事件来显示哪些函数和操作占用了 CPU 的时间。\n\n要使用这些工具，你需要在项目中安装 Clinic 包，然后运行相应的 Clinic 命令。例如，使用 Clinic Doctor 对应用程序进行诊断：\n\n```\nnpm install -g clinic\nclinic doctor -- node your-application.js\n```\n\n有关更多教程和示例，请访问 NearForm Clinic 的文档：https://clinicjs.org/\n\n这些工具可以帮助你改进 Node.js 应用程序的性能，从而提供更好的用户体验。"},{"title":"nestjs-marblejs-loopback4-eggjs-hapi-node","url":"/2021/11/19/nestjs-marblejs-loopback4-eggjs-hapi-node/","content":"## Nest\n### awesome\n- https://docs.nestjs.cn/8/awesome\n- https://docs.nestjs.com/\n- https://medium.com/monstar-lab-bangladesh-engineering/why-i-choose-nestjs-over-other-node-js-frameworks-6cdbd083ae67\n- https://zhuanlan.zhihu.com/p/389639059 - great!!!\n- they have cats !!\n- 用于构建高效、可伸缩的服务端应用程序的渐进式 Node.js 框架\n- NestJS 的设计理念本身就是一个框架适配器，其主要功能是代理中间件和处理器到适当的特定库应用中，从而达到框架的独立性\n- TS  +  OOP（面向对象编程）FP（函数式编程） FRP（函数式响应编程）\n- 模块加载方面使用 IoC 模式：模块容器 - 依赖注入(通过装饰器和元数据实现)\n- 配套功能：鉴权、文档、微服务、CLI 工具\n\n## Egg\n\n### 日志\n- https://eggjs.org/zh-cn/core/logger.html\n- egg-logger\n- 使用的时候知道什么日志什么意思，接入第三方的日志收集的时候，能对得上就行\n- egg-logrotator\n- 日志同步写入内存，异步每隔一段时间(默认 1 秒)刷盘\n### 核心思想\n- https://www.yuque.com/antfe/featured/gf0y3y\n- 为企业级框架和应用而生\n- Classify\n- 内置集群：使用 Cluster，自带进程守护、多进程以及进程间通讯等功能\n\n### 约定式开发 - 配置项内部约定 - 需查询文档配置\n\n\n\n## Hapi\n- https://hapi.dev/\n- 可靠，安全，可读\n- Middleware(express) vs Plugins and Extensions(hapi)\n```\n\nMiddleware vs Plugins and Extensions\nTo extend its functionality, Express uses middleware. Middleware essentially is a sequence of functions using callbacks to execute the next function. The issue with this is as your application grows in size and complexity, the order at which middleware executes becomes more crucial and more difficult to maintain. Having a middleware execute before one it is dependant on will cause your application to fail. hapi fixes this issue with its robust plugin and extension system.\n\nPlugins allow you to break your application logic into isolated pieces of business logic, and reusable utilities. Each plugin comes with its own dependencies which are explicitly specified in the plugins themselves. This means you don't have to install dependencies yourself to make your plugins work. You can either add an existing hapi plugin, or write your own. For a more extensive tutorial on plugins, please see the plugins tutorial.\n\nEach request in hapi follows a predefined path, the request lifecycle. hapi has extension points that let you create custom functionality along the lifecycle. Extension points in hapi let you know the precise order at which your application will run. For more info, please see the hapi request lifecycle.\n```\n- https://hapi.dev/tutorials/expresstohapi/?lang=zh_CN  (express 和 hapi的比较，也是可以怎么从express迁移到hapi)\n- hapi其实常拿来和express，koa做比较，没什么最好的，只有最合适的\n- https://github.com/vendia/serverless-express\n- koa和express可见《nodejsWeb应用开发-精读》\n\n- v17是个比较大的不兼容的更新\n- https://github.com/hapijs/hapi/issues/3658  - 17.0.0 Release Notes\n- breaking changes | migration checklist\n```\n17.0.0\nRelease Notesadditional information\nbreaking changes\n#3665\nRename route 'config' with 'options'\n#3663\nLoosen sample and modify peer validator in the routeBase schema\n#3662\nprerequisite returning empty string yields null on the pre object of request\n#3658\n17.0.0 Release Notes\n#3657\nUpdate hapijs/vise to 3.0.0 from 2.0.2\n#3656\nUpdate hapijs/topo to 3.0.0 from 2.0.2\n#3655\nUpdate hapijs/podium to 3.1.2 from 1.3.0\n#3653\nUpdate hapijs/nigel to 3.0.0 from 2.0.2\n#3652\nUpdate hapijs/mimos to 4.0.0 from 3.0.3\n#3651\nUpdate jshttp/mime-db to 1.31.0 from 1.29.0\n#3650\nUpdate hueniverse/iron to 5.0.4 from 4.0.5\n#3649\nUpdate hapijs/hoek to 5.0.2 from 4.2.0\n#3648\nUpdate hapijs/cryptiles to 4.1.0 from 3.1.2\n#3647\nUpdate hapijs/content to 4.0.3 from 3.0.6\n#3646\nUpdate hapijs/catbox-memory to 3.1.1 from 2.0.4\n#3645\nUpdate hapijs/catbox to 10.0.2 from 7.1.5\n#3644\nUpdate hapijs/call to 5.0.1 from 4.0.2\n#3643\nUpdate hapijs/boom to 7.1.1 from 5.2.0\n#3642\nUpdate hapijs/b64 to 4.0.0 from 3.0.2\n#3641\nUpdate hapijs/ammo to 3.0.0 from 2.0.4\n#3640\nUpdate hapijs/accept to 3.0.2 from 2.1.4\n#3639\nUpdate hapijs/statehood to 6.0.5 from 5.0.3\n#3638\nUpdate hapijs/shot to 4.0.3 from 3.4.2\n#3637\nUpdate hapijs/heavy to 6.0.0 from 4.0.4\n#3636\nUpdate hapijs/wreck to 14.0.2 from 13.0.3\n#3635\nExpose payload and credentials to dynamic scopes\n#3634\nonCredentials ext point\n#3633\nSeparate authorization (403) from authentication (401)\n#3632\nAdd negative test on registering plugin twice without `once`\n#3631\nWhen event data is an error, field name is error\n```\n\n#### serverless\n- 通过屏蔽细节，让业务开发更容易\n- 把能在多个业务复用的东西下沉，屏蔽细节\n- 好的框架 - 把复杂的，通用的东西下沉（less化），实现渐进式\n\n- 云函数（渐进式，serverless -> 屏蔽服务器细节）\n\n### loopback4\n- https://github.com/loopbackio/loopback-next"},{"title":"tess-cis-summary","url":"/2021/11/17/tess-cis-summary/","content":"> Test and Error Support System - Continous Integration System\n \n> 持续集成组搭建的\n\n### Concept\n持续构建系统 - 代码编译 ｜ 静态扫描 ｜ 制品打包 ｜ 环境发布 ｜ 自动化测试\n质量管理工作平台 - 质量报告 ｜ 选择上线制品 ｜ 提上线单 （测试人员）\n\n#### 流程图\n\n项目/子项目 => 拉取代码 => 代码编译 => 二进制包｜docker镜像｜静态扫描（并行） => 开发｜测试｜预发环境（K8s|虚拟机） => 接口测试｜压力测试｜安全扫描（质量卡点） => 二进制包｜测试报告｜服务信息 （申请上线）=> 上线\n\n#### 项目管理\n集团那边项目管理是走这个的，项目管理无外乎项目信息的维护，人员权限的配置，服务器资源的管理，子项目的管理，操作记录等；\n我们这边走禅道；\n\n## 容器流水线\n- 我们这边有node的服务走的是容器流水线\n- 环境部署到kubernetes\n- 编译打包的制瓶类型支持二进制（zip）包盒docker镜像，我们这边是docker镜像里面拷贝了个项目的zip包\n```\n# 流水线设置\n源代码管理\n编译管理（镜像,命令）\n制品打包管理（文件或文件夹，部署目录、启动命令）\n资源管理（服务端口、容器实例数、CPU、内存）\n配置管理（代码拉取之后、编译之前对代码的配置文件进行更改）\n流水线任务开关（静态扫描等进行开启或关闭）\n质量卡点管理（配置TESS-ATS、压力测试等）\n```\n\n## 登录容器\n一般是到跳板机上，然后```kubectl```登录方式；```kubectl get pods -n NAMESPACE |grep 子项目名``` ```kubectl exec -it 容器名称 bash -n NAMESAPCE```\n\n### Q环境\nQ环境一般是指Quality Assurance环境， 即质保环境，也称为测试环境。开发人员在完成每个项目或功能点的开发工作后，会把代码部署到Q环境中，然后由专门的QA团队（质量保证团队）进行全面、系统的测试，以确保软件的质量和功能满足设定的需求。\n\n软件在Q环境中，需要接受功能测试、性能测试、安全测试、兼容性测试等多方面的测试。测试人员会按照测试用例进行操作，如发现问题，就会录入bug，让开发团队在后续的版本中进行修复。所以，Q环境是从开发环境到生产环境的重要过渡，也是保证软件质量的关键步骤。\n\n在一些组织中，还存在与Q环境类似的环境，如UAT环境（用户接受测试环境），PRE环境（预上线环境）等。不同环境的目的在于模拟可能的软件使用场景，尽可能发现和解决软件存在的问题，使其在上线后能正常运行，提供良好的用户体验。"},{"title":"mathjax在项目中的应用","url":"/2021/11/17/mathjax在项目中的应用/","content":"\n## node服务\n### history-problems\n- 腾讯云抖动，我们有放在腾讯云的文档对象存储的资源，抖动时会发生资源获取失败\n\n\n\n## browser端\n\n## Problems\n\n### 渲染每个公式另起一行，只在safari能复现\n\n- 渲染中的问题，受到了业务逻辑里面的样式的影响，导致了渲染的问题\n- 解决方案：\n1.临时在渲染完成后，增加display:inline-block在外层结构中，使其不再换行\n2.根本解决方案：找到了影响渲染的结构，因为在题目渲染里面又增加了个P标签，是block的元素，影响了渲染\n- 思路：一定要做好题目组件渲染的抽取，能进行独立测试，方便定位问题是否在业务中，然后逐步排查\n- 问题来源：“ios系统里面，如果内容里面有录入的block元素，会导致mathjax公式渲染换行的问题”本质上是最开始的录入时候，给出的题目渲染结构有问题，用span包裹了题干和解析等，这样一旦里面有div block特性的元素，在safari渲染就会换行；但这个是历史问题，就原先录入的时候没考虑Safari的渲染；Chrome不换行是因为有容错能力；Safari没有容错能力，直接把问题暴露出来了\n\n### 在iPhone8以及以下的设备中（微信小程序，小程序均为最新）\n部分mathjax渲染的数学公式，只有停在了某个视区，且点击触发，才能够显示出来；\n\n原因，还是渲染的部分收到了外层结构的影响，overflow-x:auto; overflow-y:hidden;\n\n\n### 公式渲染分提供html和svg\n- 注意 - 如果有截图的需求（html2canvas）- 使用svg做公式渲染慎重，会有问题\n- https://github.com/cisen/blog/issues/880"},{"title":"lad-source-code-study","url":"/2021/11/12/lad-source-code-study/","content":"## cli构建\n### 参考\n- cli.js\n```\n#!/usr/bin/env node\n\n// Inspired by:\n// <https://github.com/saojs/sao/issues/50>\n// <https://github.com/nuxt-community/create-nuxt-app/blob/master/packages/create-nuxt-app/package.json>\n```\n\n### npm packages\n- sao\n\n\n## email \n### bree\n- https://www.npmjs.com/package/bree\n- https://jobscheduler.net/\n- \n\n## 其他相关\n### phantomJS\n- https://phantomjs.org/\n\n#### lad\n- lad的template里面yarn.lock依赖 phantomjs-prebuilt@^2.1.14:\n- svg2png@^4.0.0 依赖于 phantomjs-prebuilt@^2.1.14\n- font-awesome-assets@^0.0.8 依赖于 svg2png@^4.0.0\n```\n### Email Engine\nOur beautiful email engine uses [email-templates][] (which is also made by the creator of Lad)!\n* [Add icons with Font Awesome with code][font-awesome-assets]\n\n```"},{"title":"complete-intro-to-containers-study-notes","url":"/2021/11/10/complete-intro-to-containers-study-notes/","content":"## 推荐学习资料:\n一定要点开，完整而全面 —— 也是frontend masters上面的一门课\nhttps://btholt.github.io/complete-intro-to-containers/\n\n下面是简单翻译：\nTABLE OF CONTENTS（目录）\n### Welcome\n####   Introduction\n### Crafting Containers By Hand\n#### What Are Containers? (什么是容器？)\n#### chroot 隔离在chroot环境中，看不见彼此的文件\n- chroot - run command or interactive shell with special root directory\n  - 容器环境：安全性\n- docker run -it --name docker-host --rm --privileged ubuntu:bionic\n  - 注意拉取时候，如果报拉取错误，可以处理下代理配置\n  - docker run意味着我们要在容器中运行一些命令，而-it意味着我们要使shell交互式（所以我们可以像普通终端一样使用它）\n  - 执行完这个命令后：\n  ```\n  # 我们可以查下ubuntu的版本\n  root@3595a31d9cad:/# cat /etc/issue\n  mkdir /my-new-root\n  cd /my-new-root\n  echo \"my super secret thing\" >> /my-new-root/secret.txt\n\n  mkdir /my-new-root/bin\n  cp /bin/bash /bin/ls /my-new-root/bin/\n\n  # ldd - print shared object dependencies,列出bash依赖的库，copy到我们新的环境\n  ldd /bin/bash\n  cp /lib/x86_64-linux-gnu/libtinfo.so.5 /lib/x86_64-linux-gnu/libdl.so.2 /lib/x86_64-linux-gnu/libc.so.6 /my-new-root/lib\n  cp /lib64/ld-linux-x86-64.so.2 /my-new-root/lib64\n  ldd /bin/ls\n  cp /lib/x86_64-linux-gnu/libselinux.so.1 /lib/x86_64-linux-gnu/libpcre.so.3 /lib/x86_64-linux-gnu/libpthread.so.0 /my-new-root/lib\n\n  chroot /my-new-root bash\n  ls\n  pwd\n  cat secret.txt\n  Ctrl + D #exit\n\n  ```\n####   Namespaces (命名空间) - 创建一个新的环境，它被隔离在系统中，有自己的PID、挂载（如存储和卷）和网络栈，避免容器间进程等彼此可见性\n1. 我有一个大服务器，空间卖给几个人\n2. 如果将用户限制在chroot的环境中，他们看不见彼此的文件，但是依然可以看到（or kill or hijack）所有的进程\n3. 如果再给每个chroot环境提供不同的命名空间，他们就看不到对方的进程了\n4. 刚刚说的是UTS（or UNIX Timesharing）命名空间；还有更多的命名空间可以帮助容器保持相互隔离\n- 安全性的试验\n```\n# 在一个终端里面chroot到我们的环境 - terminal session 1\n# 在另外一个终端\ndocker exec -it docker-host bash # terminal session 2\n\ntail -f /my-new-root/secret.txt & # ts 2 在后台启动一个无限运行的进程\nps # 2\nkill <PID you just copied> # 1 \n```\n我们可以从chroot环境中，kill掉tail进程，这说明我们不仅仅需要文件系统的隔离\n\n因此，我们使用unshare来创建一个使用namespace来隔离的chroot环境\n```\nexit # 从之前的chroot环境\n\n# 安装 debootstrap\napt-get update -y\napt-get install debootstrap -y\ndebootstrap --variant=minbase bionic /better-root\n\n# 进入新的命名空间和chroot环境\nunshare --mount --uts --ipc --net --pid --fork --user --map-root-user chroot /better-root bash # this also chroot's for us\nmount -t proc none /proc # process namespace\nmount -t sysfs none /sys # filesystem\nmount -t tmpfs none /tmp # filesystem\n```\n这将创建一个新的环境，它被隔离在系统中，有自己的PID、挂载（如存储和卷）和网络栈。现在，我们看不到任何进程了。\nPIDs + mounts(like storage and volumes, network stack)\n\n可以再试试刚刚的安全试验\n\n我们可以用namespace来限制容器相互干扰的能力（也可以试试其他的namespace）\n\n####   cgroups - 物理资源隔离限制\n我们还有一个问题，每个隔离的环境都可以访问服务器所有的资源。环境之间的物理组件没有做隔离。\nGoogle在建立基础设施的时候，也遇到了这个问题，于是提出了cgroup;这个隔离环境只能得到这么多的CPU，内存，一旦用完了，就不会再得到更多了。\n- Linux Cgroups - Linux Control Group - 限制一个进程组能够使用的资源上限（CPU，内存，磁盘，网络带宽）\n```\n# 在unshare'd环境之外，我们先安装下需要的工具\napt-get install -y cgroup-tools htop\n\n# 创建新的 cgroups\ncgcreate -g cpu,memory,blkio,devices,freezer:/sandbox\n\n# 将我们的 unshare'd 环境添加到 cgroup 中\nps aux # 拿到 紧跟在 the unshare 环境之后的 the bash PID \ncgclassify -g cpu,memory,blkio,devices,freezer:sandbox <PID>\n\n# 列出与沙盒cpu组相关的任务，我们可以看到上面的PID\ncat /sys/fs/cgroup/cpu/sandbox/tasks\n\n# 看下沙盒cpu组的cpu份额，这个数字决定了竞争资源之间的优先级，越高的优先级就越高\ncat /sys/fs/cgroup/cpu/sandbox/cpu.shares\n\n# 如果需要的话，kill所有沙盒的进程\n# kill -9 $(cat /sys/fs/cgroup/cpu/sandbox/tasks)\n\n# 对于多核系统，将使用率限制在5%\ncgset -r cpu.cfs_period_us=100000 -r cpu.cfs_quota_us=$[ 5000 * $(getconf _NPROCESSORS_ONLN) ] sandbox\n\n# 设置一个80M的限制\ncgset -r memory.limit_in_bytes=80M sandbox\n# 获取cgroup使用的内存统计信息\ncgget -r memory.stat sandbox\n\n# 在终端会话 #2 中，在unshare 环境之外\nhtop # 将允许我们通过一个漂亮的可视化工具查看资源使用情况\n\n# 在终端会话 #2 中，在unshare 环境中\nyes > /dev/null \n# 这将迅速消耗核心的CPU功率\n# 注意它只占用5%的CPU，就像我们设定的那样\n# 如果你愿意，可以运行上面的docker exec来获得第三个会话，看看上面的命令是否占用了100%的可用资源\n# CTRL+C随时停止上述操作\n\n# 在终端会话#1中，在unshared的环境中\nyes | tr \\\\n x | head -c 1048576000 | grep n # 这将加速消耗 ~1GB 的内存\n\n# 注意在 htop 中，由于我们的 cgroup，它将保持内存接近 80MB\n# 如上所述，用第三个终端连接，看看上面的命令在cgroup之外的工作情况\n```\n所以，尽管这是最基本意义上的容器，但我们还没有触及更多高级的话题，比如网络、部署、绑定，或者其他Docker为我们提供的服务。但现在你已经知道在最基本的层面上，容器是什么，它做什么，以及我们如何自己实现这些。\n### Docker\n####   Getting Set Up with Docker (使用Docker进行设置)\n####   Docker Images without Docker\n####   Docker Images with Docker\n####   Node.js on Docker\n####   Tags (标签)\n####   Docker CLI\n### The Dockerfile\n####   Intro to Dockerfiles (Dockerfiles介绍)\n####   Build a Node.js App (构建一个Node.js应用)\n####   A More Complicated Node.js App (一个更复杂的Node.js应用)\n####   A Note on EXPOSE (关于EXPOSE的说明)\n####   Layers\n### Making Tiny Containers\n####   Alpine Linux\n####   Making Our Own Alpine Node.js Container (制作我们自己的Alpine Node.js容器)\n####   Multi Stage Builds\n####   Static Assets Project\n### Features in Docker\n####   Bind Mounts\n####   Volumes\n####   Using Containers for your Dev Environment (在开发环境中使用容器)\n####   Dev Containers with Visual Studio Code\n####   Networking with Docker\n### Multi Container Projects (多容器项目)\n####   Docker Compose\ndocker-compose up -d=>在后台运行\n####   Kubernetes\n####   Kompose\n### OCI (Non-Docker) Containers （OCI(非Docker)容器）\n####   Buildah\n####   Podman\n### Wrapping Up (收尾工作)\n####   Conclusion (结论)\n\nPS：把材料放到github,也是因为文本材料的错误不可能完全无一点错误，所以放到github上，大家都可以提issue（问题），这样后续的人，就能方便查到了；而材料也能在这个过程中不断得完善; video课程收费，但是材料开源;\n\n\n### words notes:\n#### intro\n- Course Objective 课程目标\n- The objective of this course is demystify what containers are  本课程的目的是解开什么是容器的神秘面纱\n- demystify 使明白易懂 ｜diˈmɪstəˌfaɪ｜\n- and now it's not just a tool for ops, it's a tool for developers 现在它不仅仅是运维的工具，也是开发人员的工具\n- on a regular basis 经常\n- a developer demographic 开发者群体\n- the code will be incidental to the concepts being taught 代码是次要的\n- incidental 1.次要的 2.不可避免的，伴随而来的 3.附带的\n- to be incidental to sth 伴随某事物而来\n- a very basic grasp of 非常基本的掌握\n- be your first exposure to 第一次接触\n- For set up instructions, refer here 关于设置说明，请参考这里\n- File Issues 提交问题\n- Previous to that 在此之前\n- I love to teach. It's a challenging task that forces you to peel back all the knowledge you've gained so you can approach someone who lacks the same experience and terminology you have. It forces you to take amorphous(shapeless,confused) concepts floating in your brain and crystalize them into solid concepts that you can describe. It forces you to acknowledge(admit) your gaps(空白，空缺，欠缺) in knowledge because you'll begin to question things you know others will question. For me to ever master a concept, I have to teach it to someone else.\n- incentive 激励\n\n#### what are containers\n- I was very intimidated by the concept of what containers were 我对容器的概念感到非常恐惧\n- super-versed in Linux and sysadmin type activties 超级精通Linux和系统管理员类型的人\n- a few features of the Linux kernel duct-taped together 将Linux内核的一些功能duct-taped在一起\n- Honestly, there's no single concept of a \"container\": it's just using a few features of Linux together to achieve isolation. That's it. 说实话，\"容器 \"并没有一个单一的概念：它只是把Linux的几个功能用在一起实现隔离。仅此而已。\n- assume wizardry(skill) with bash or zsh \n-  \"bare metal\" 裸机 \n-  This is great if you're extremely performance sensitive and you have ample and competent staffing to take care of these servers.如果你对性能非常敏感，而且你有足够的和有能力的人员来照顾这些服务器，这是很好的。\n-  Need to spin up another server\n-  web traffic 网络流量\n-  all the drivers connecting to the hardware 驱动程序连接到硬件\n-  Virtual Machines 虚拟机\n-  one beefy server 一个强大的服务器\n-  lease a server from 租用了一台服务器\n-   drop a fork bomb and devour（毁灭） all the resources\n-   nefarious 恶毒的\n-   a shared-tenant server 共享租户服务器\n-   hum 嗯\n-   All these above features come at the cost of a bit of performance. 以上这些功能都是以牺牲一点性能为代价的\n-   Public Cloud 公有云\n-   So, as alluded to above 因此，如上所述\n-   manage all the software, networking, provisioning, updating, etc.管理所有这些服务器的软件、网络、配置、更新等。\n-   We're still paying the cost of running a whole operating system in the cloud inside of a host operating system. It'd be nice if we could just run the code inside the host OS without the additional expenditure of guest OSs.\n-   Containers 容器\n-   divine 凭直觉发现，guess\n-   As you may have divined, containers give us many of the security and resource-management features of VMs but without the cost of having to run a whole other operating system. It instead usings chroot, namespace, and cgroup to separate a group of processes from each other. \n-   flimsy (feeable,weak)\n-   But I assure you a lot of very smart people have worked out the kinks and containers are the future of deploying code.但我向你保证，很多非常聪明的人已经解决了这些问题，容器是部署代码的未来。\n\n- 容器技术的核心 - 通过约束和修改进程的动态表现，从而为其创造出一个边界\n- 在Linux内核中，很多资源和对象是不能被namespace化的，比如时间\n\n\n### Dockerfile\n#### Docker Daemon\n- Docker Engine（包括 Docker Daemon）、Docker 镜像和 Docker 容器组成。\n- Docker Daemon（dockerd）是一个在主机上持续运行的后台进程，它用于管理 Docker 容器，负责构建、运行和监控容器。Docker Daemon 还会与其他 Docker Daemon 通信，以便协同工作。Docker CLI 和 Docker API 是与 Docker Daemon 进行通信的主要方式。\n一些与 Docker Daemon 交互的操作包括：\n1. 从 Docker Hub 或其他注册表拉取镜像。\n2. 构建新的 Docker 镜像。\n3. 创建、启动、监控和停止容器。\n4. 在容器之间移动文件。\n5. 访问容器的日志和资源使用情况等信息。\n6. 管理容器网络。\n7. 管理容器存储。\n\n要启动 Docker Daemon，请在您的终端中输入以下命令（请注意，您可能需要 root 权限来运行这些命令）：\n\n对于 Linux 系统：\n\n```bash\nsudo systemctl start docker\n```\n\n或者\n\n```bash\nsudo service docker start\n```\n\n对于 macOS 和 Windows，等，请使用 Docker Desktop：\n\n下载并安装 Docker Desktop，然后按照提示启动它。这将自动启动 Docker Daemon，并在系统托盘中提供一个 docker 图标，用于访问设置和其他选项。\n\n确保 Docker 已启动，运行以下命令以检查 Docker Daemon 是否正在运行：\n\n```bash\ndocker info\n```\n\n此命令将返回有关 Docker Daemon 和容器的详细信息。如果能够看到输出的信息，说明 Docker Daemon 正在运行。\n\n### 构建优化\ndocker build 的时候会把构建上下文的所有文件打包发送给 docker deamon 来构建镜像。\n\n可以通过 .dockerignore 指定哪些文件不发送，这样能加快构建时间，减小镜像体积。\n\n多阶段构建也能减小镜像体积，也就是 build 一个镜像、production 一个镜像，最终保留下 production 的镜像。"},{"title":"unicode综述","url":"/2021/11/10/unicode综述/","content":"> a computing industry standard for providing a unique code point a number for each character - wikipedia\n- code point\n- 从0开始编号， U+0000=null,共计109499个符号\n- unicode 只规定了每个字符的码点，到底用什么样的字节序表示这个码点，就涉及到编码方法\n\n- 编码方法\nUTF-32 - 4个字节表示一个字符，完全对应unicode编码（a => 0x00000061 查找效率高，时间复杂度O(1),浪费空间，比相同ASCII编码文件大四倍）\nUTF-8 - 变长的编码方法\n\n- JavaScript采用unicode字符，但支持一种编码方法USC-2（UTF-16）\n- 由于JS只能处理USC-2编码，所以字符在这门语言中都是2个字节（四个字节的字符会当作两个双字节的字符处理）\n- ES6增强了对Unicode的支持（Array.from(string).length, '好' === '\\u597D'）\n### 涉及unicode的博文\n- dart-sass\n- iconfont使用经验总结\n- https://dmitripavlutin.com/what-every-javascript-developer-should-know-about-unicode/#comments\n```\nTable of Contents\n1. The idea behind Unicode\n2. Basic Unicode terms\n2.1 Characters and code points\n2.2 Unicode planes\n2.3 Code units\n2.4 Surrogate pairs\n2.5 Combining marks\n3. Unicode in JavaScript\n3.1 Escape sequences\n3.2 String comparison\n3.3 String length\n3.4 Character positioning\n3.5 Regular expression match\n4. Summary\n```\n- 上面这篇讲解很详尽\n### 零宽字符\n- Unicode 中还有一类格式字符，不可见，不可打印，主要作用于调整字符的显示格式，所以我们将其称为零宽字符。\n```\n零宽字符主要有以下几类：\n\n零宽度空格符 (zero-width space) U+200B : 用于较长单词的换行分隔。\n\n零宽度非断空格符 (zero width no-break space) U+FEFF : 用于阻止特定位置的换行分隔。\n\n零宽度连字符 (zero-width joiner) U+200D : 用于阿拉伯文与印度语系等文字中，使不会发生连字的字符间产生连字效果。\n\n零宽度断字符 (zero-width non-joiner) U+200C : 用于阿拉伯文、德文、印度语系等文字中，阻止会发生连字的字符间的连字效果。\n\n左至右符 (left-to-right mark) U+200E : 用于在混合文字方向的多种语言文本中（例：混合左至右书写的英语与右至左书写的希伯来语），规定排版文字书写方向为左至右。\n\n右至左符 (right-to-left mark) U+200F : 用于在混合文字方向的多种语言文本中，规定排版文字书写方向为右至左\n```\n- 可用来做隐形水印\n- 对于用户录入内容中的零宽字符，注意处理；\n\n- 相关文章\n- https://dmitripavlutin.com/what-every-javascript-developer-should-know-about-unicode/"},{"title":"vue-react-angular-svelte-持续观测笔记-historyline","url":"/2021/11/10/vue-react-angular-svelte-持续观测笔记-historyline/","content":"\n## angular\n- angular.js(1.x) - 没有样式的集成能力\n```\nAngularJS中的服务其实就是提供一种方式抽取共用类库\n创建服务的方式有三种：providers，factory，service\n```\n```\n$scope是个树形结构 \n看源代码——debug 此bootstrap非彼bootstrap\n启动～ angular.js 用自执行函数的形式让整个代码在加载完成后立即执行 window.angular\nangular.injector angular.module\n自启动（ng-app），手动启动 angular.element(document) angular.element = jqLite\nwindow.angular.bootstrap(是否多次启动)\nbindjQuery();(jqlite)\n发布ng提供的API publishExternalAPI() extend() setupModuleLoader(window)——建立模块机制 注册内核provider\nangularInit()——防止多次初始化ng-app, bootstrap——创建injector、拉起内核和启动模块，调用compile服务\n推断型注入（混淆之后名称都会改，就没有办法了） 声明式注\n内联式注入（推荐）\n创建注射器（provider，instance） $injector.invoke() $injector.annotate()——分析函数参数的 function 的 toString();\n核心目的：让接口和实现分离 在ng中，所有的provider都可以用来进行注入\nprovider/factory/service/constant/value provider是基础，其余都是调用provider函数实现的，只是参数不同 从坐向右，灵活性越来越差\nreturn 语句可以放在前\n```\n- angular 2+ - 提供了样式封装能力，与组件深度集成\n- shadowDOM- 逻辑上一个DOM，结构上存在子集结构\n- scoped css - 随机属性\n- this - 引用的是函数据以执行的环境对象，函数的名字仅仅是一个包含指针的变量\n- toolbar generator - 根据type得到generator，generator实例化，调用generator的render方法\n\n## Vue\n### UI组件库\n- https://github.com/didi/cube-ui - 移动端"},{"title":"基于electron的离线支持应用项目总结","url":"/2021/11/09/基于electron的离线支持应用项目总结/","content":"### history\n> 一个15年的应用，之所以支持离线，是因为校区教室内的网络可能不好，所以需要课中使用时支持离线；\n\n- 那个时候electron的版本和相关构建生态都是比较开始的阶段，基于node的版本也比较低，过了几年，重新起那个项目\n\n```\nnpm run start\n(会发生fse.node无法通过安全与偏好设置，这个需要在安全与偏好设置里面同意一下)\n\n开始错误暂不影响看，可点过掉\n\n\n● electron-mocha\n- https://mochajs.org/\n- https://github.com/mochajs/mocha\n\n● electron-prebuilt\n  ○ npm地址： https://www.npmjs.com/package/electron-prebuilt\n  ○ 说明：electron-prebuilt has been renamed to electron. For more details, see http://electron.atom.io/blog/2016/08/16/npm-install-electron\n\n```\n\"requires\": {\n        \"electron-download\": \"^3.0.1\",\n        \"extract-zip\": \"^1.0.3\"\n      }\n```\n被重新命名为electron了（https://www.electronjs.org/blog/npm-install-electron）\n\n● Mac，Windows包(利用两个工具，流程化得进行封包工作)\n  ○ appdmg\n  ○ rcedit\n\n(基于seal_electron)\n● 测试模块\nhttps://www.electronjs.org/spectron\n● 构建模块\ndps:\nelectron-log\nelectron-updater\n\ndev-deps:\nelectron\nelectron-builder\nelectron-webpack\n```\n\n### 截屏功能\n\n\n\n### electron rebuild\nThis executable rebuilds native Node.js modules against the version of Node.js that your Electron project is using. This allows you to use native Node.js modules in Electron apps without your system version of Node.js matching exactly (which is often not the case, and sometimes not even possible).\n该可执行文件将根据您的Electron项目使用的Node.js版本重建本机Node.js模块。这使您可以在Electron应用程序中使用本机Node.js模块，而无需与系统版本的Node.js完全匹配\n- 可配置到script中\n\n### Arch\n\n#### 主进程\n- browser window（浏览器窗口，加载网页，注入JSSDK，挂window上面）\n- electron updater （客户端更新）\n- 客户端监控 - sentry\n\n#### 渲染进程\n- JSSDK （暴露给嵌入的页面）\n\n\n### 功能模块\n#### 文件下载\n- 网页向客户端提出下载的请求\n- 客户端提供了下载的功能，由客户端向服务的请求数据，完成下载，并回调给网页进度和状态\n- https://www.electronjs.org/docs/latest/tutorial/process-model#preload-scripts\n- JSSDK的注入是通过preload scripts\n\n\n### 网页端\n- babel 是可以配置 electron兼容的\n- https://babeljs.io/docs/en/options#targets\n\"@babel/preset-env\",\n      {\n        \"targets\": {\n          \"electron\": \"9\",\n        }\n      }\n\n\n\n## sentry \n\n#### EXCEPTION_ACCESS_VIOLATION_READ\nhttps://source.chromium.org/chromium#chromium/src/v8/src/deoptimizer.cc&sq=package:chromium&l=680\nhttps://github.com/electron/electron/issues/3241\n\n\n### 其他产品\n- 语雀的客户端(https://www.yuque.com/download)\n- https://www.yuque.com/seeconf/2022/kr8mdw  - 开发的分享 - 如何打造高质量的基于electron的客户端\n\n\n### electron-builder\nelectron-builder 自身不对 Python 的版本有直接的要求，因为它是用 JavaScript 编写的。\n然而，有些依赖可能需要 Python。例如，一些原生模块可能使用 node-gyp 进行构建，而 node-gyp 需要 Python 2.7（注意不是 Python 3）。\n因此，在使用 electron-builder 时，虽然 electron-builder 自身对 Python 的版本没有直接要求，但如果你正在使用的项目中有需要 node-gyp 来构建的模块，那么就需要确保你的环境中安装了 Python 2.7。\n不过，如果在构建过程中遇到与 Python 相关的问题，建议检查你的环境设置以及项目的依赖，并确保它们与 Python 的版本兼容。\n\n\n\n### level\n`leveldown`是一个为LevelDB编写的Node.js模块，LevelDB是谷歌开发的一种快速键值存储系统。`leveldown`充当LevelDB和Node.js之间的接口，使LevelDB的功能可以用JavaScript进行操作。\n\n具体来说，`leveldown`允许数据的存储、查询、删除和更新。它可用于处理大量数据，因为LevelDB设计用于处理高速大容量数据存储。\n\n此包通常与`levelup`包一起使用，`levelup`在`leveldown`之上添加了一些额外的功能，如数据编码和解码，以及读写流。\n\n\nLevelDB 是 Google 开发的一款高效的键值对存储库，它提供了接口来处理大型数据。LevelDB 使用 log-structured merge-tree（LSM树）数据结构，这样可以提供高速的读和写途径。因此，LevelDB 特别适合于处理大量数据的场景。\n\n一些主要特点包括：\n\n1. 自动数据压缩：LevelDB 使用谷歌的 Snappy 数据压缩库来减少存储占用的空间。\n\n2. 原子批处理：LevelDB 支持“批处理”操作，这样可以保证一系列操作作为一个单元进行，要么全部成功，要么全部失败，这就是所谓的“原子性”。\n\n3. 快速查找：由于 LSM 树的数据结构特性，LevelDB 提供非常快速的键值对查找。\n\nLevelDB 在很多领域有广泛应用，包括网页索引、用户数据存储、缓存等场景。"},{"title":"tidb项目总结","url":"/2021/11/09/tidb项目总结/","content":"## 官方文档指路\n- https://github.com/pingcap/tidb\n- https://docs.pingcap.com/zh/tidb/stable\n\n\n\n## Tips\n\n### properties\n#### max-server-connections\n- https://docs.pingcap.com/zh/tidb/stable/tidb-configuration-file#max-server-connections\n- 用来兼容mysql协议的一个参数\n```\n- TiDB 中同时允许的最大客户端连接数，用于资源控制。\n- 默认值：0\n- 默认情况下，TiDB 不限制客户端连接数。当本配置项的值大于 0 且客户端连接数到达此值时，TiDB 服务端将会拒绝新的客户端连接。\n```"},{"title":"RPC协议","url":"/2021/11/05/RPC协议/","content":"\n> remote procedure call 远程过程调用\n\n## RPC协议（跨语言类）\n- ONC RPC\n- （XML） SOAP\n- （JSON）RESTful\n- Hessian2\n\n> 二进制传输性能好，难以跨语言；文本类的则相反；\n\n## 模式演变\n- 客户端服务器模式\n- 微服务\n\n## 对RPC框架的要求\n- 传输性能\n- 跨语言\n- 严谨且灵活（添加字段不需要重新编译发布程序）\n- 服务发现，服务治理（Dubbo ｜ Spring Cloud）\n\n## GRPC\n### 二进制序列化协议\n- Protocol Buffers\n- .proto\n- 压缩效率很高\n\n### 网络传输\n- Java - Netty(高效的基于异步IO的网络传输框架) - 见netty-summary\n- 服务方法 - 单向RPC ｜ 服务端流式RPC ｜ 客户端流失RPC ｜ 双向流式RPC\n\n### 服务发现(Discovery Service)与治理\n- 负载均衡 - LVS HAProxy Nginx\n- Envoy - GRPC\n- 配置 - listener ｜ endpoint ｜ cluster ｜ route\n- 注册治理中心\n- 未来服务治理的趋势 - Service Mesh(基于Envoy)\n\n#### 注册治理中心\n- https://mp.weixin.qq.com/s/IhPfssotldNWn9GF4Dx6qg - 腾讯注册中心演进及性能优化实践\n\nDubbo是一个高性能、轻量级的开源Java RPC框架，它是阿里巴巴集团开发和开源的服务化治理解决方案，对于构建大规模的分布式应用系统具有重要的作用。\n\nDubbo主要提供以下核心功能：\n\n1. **透明化的远程方法调用**：把RPC调用转换为本地调用，服务消费者无需知道远程调用的细节，就像调用本地方法一样方便。\n\n2. **负载均衡**：Dubbo支持多种负载均衡策略，如随机（Random）、轮询（Round Robin）、最小活跃调用数（Least Active）等。\n\n3. **服务注册与发现**：通过注册中心对服务提供者进行注册和服务消费者进行发现，实现了服务消费者和服务提供者的解耦。\n\n4. **容错机制**：包括失败自动切换、超时重试等多种容错方式，可以保证服务的高可用性。\n\n5. **服务治理**：包括动态配置、访问控制、权重调整、负载均衡、熔断与降级等一系列服务治理功能。\n\n6. **分布式事务**：通过集群内部协调，实现服务间的一致性。\n\n7. **监控**：提供丰富的服务调用监控、访问日志、统计及报警系统。\n\nDubbo接口安全性增强的策略：\n\n访问控制列表（ACL）：通过配置白名单或黑名单来管理哪些消费端可以或不能访问你的服务。\n\n服务降级：在消费端或者提供端配置mock结果，当服务出现异常时，可以根据mock的策略来返回“mock结果”，防止服务尝试不当访问。\n\n令牌验证：可以对接口调用进行令牌验证，只有持有有效令牌的消费端才能访问。\n\n数字签名：消费端和提供者端可以采用相同的签名算法，提供者用于检验请求的合法性，消费者用来确认回复的正确性。\n\n传输层安全（TLS）：可以使用Dubbo的TLS支持在传输数据时进行加密，防止数据被截获。\n\n限流：通过设置每秒请求数量的上限，防止因过度请求而导致服务崩溃。\n\n"},{"title":"双11-notes-summary","url":"/2021/11/03/双11-notes-summary/","content":"> 又到双11了，发现每年ali都会出双11技术总结的手册，看了下，记个summary\n\n## Concepts\n\n### Words\n#### CVR - Conversion rate, term used to calculate website visitors in Internet marketing\n#### CTR - Click-Through Rate \n\n## Details\n### 支付宝\n- 金融 - 分布式 - 一致性\n- 云计算 - 云服务\n- 容器 - 离线服务器资源临时用于在线业务\n- OceanBase - 三地五中心\n- GeaBase - 风控\n- 客服 - 查询应答 快捷应答 未问先答（AI训练）\n- 可靠性，安全性\n\n### 苏宁API\n#### 异常码\n- 唯一性，风格一致，有层级有分类，可扩展\n- 分类 - 系统级 ｜ 业务级\n- 系统级 - 流控 ｜ 权限 ｜ 系统校验 ｜ 服务不可用\n- 业务级 - 业务字段（非空｜格式｜枚举）｜业务场景（单场景｜组合场景）\n- 解决的问题 - 异常码监控 ｜ 接口告警 ｜ 定位及快速解决问题"},{"title":"聊聊MIME","url":"/2021/11/02/聊聊MIME/","content":"### 项目\n涉及视频文件上传类型的控制\n\n### MIME (Multipurpose Internet Mail Extensions) \n\n\n\n### some tips\n\n#### HTTP server\n- 如果本地起静态资源服务，默认配置下\n- svg (python simple-http-server type:octet-stream | node http-server type:svg+xml)\n- https://github.com/http-party/http-server\n```\nhttp-server的原理\n\n```"},{"title":"mock这件事","url":"/2021/11/02/mock这件事/","content":"\n### mockjs\n#### 语法规范\n- 数据模版定义 DTD\n- 数据占位符定义 DPD\n  - 占位符：只在属性字符串中占个位置，不出现在最终的属性中\n- Mock.random\n\n### 应用\n#### web应用\n可以在express（or其他能快速构建服务的框架）中集成mockjs，mock后端接口（数据格式定义+mockjs+API实现）\n\n### swagger\n见其他博文\n### yapi\n见其他博文\n\n### Tips\n#### .ejs\n- 使用时注意：\n```\n# if mockData里面有 单引号，则会报错，这个时候可以用正则进行替换成转义 ' => \\\\'\n<script>\nconst mockDataObj = JSON.parse('<%- JSON.stringify(mockData) %>');\n</script>\n```\n- 所以使用时候要注意内容本身，是否会造成错误\n\n## rap2\n> 提供给我们统一登录平台的团队，使用的是rap2，可以用来搭建中台的接口平台，文档也可以在里面维护\n\n- 阿里妈妈前端团队出品的开源接口管理工具RAP第二代, rap2.taobao.org\n- https://github.com/thx/rap2-delos\n- 私有化部署\n\n### 仓库\n### 数据字典\n- 不同项目的数据表字段\n- 字典表（sys_dict）字典表主要存储系统常用的枚举类型数据，主要包含编号、标签、数据值、类型等字段\n### 业务身份\n- 系统编号｜系统名称｜密钥｜联系人姓名｜联系人邮箱\n### 团队\n### 接口\n### 状态\n### 接口标准\n- 平台的接口标准\n1.appid\nappid | appname | appsecret | 业务系统联系人 | 联系人email | 业务系统域名 | 业务系统简介\n2.鉴权的规范\n对外 && 对内\n对外-accesstoken\n对内-验签\n3.数据包格式\njson\n通用参数定义-内部服务｜外部服务\n状态码定义\n返回字段名｜字段类型｜字段说明\nstatus状态编码|msg状态描述|data业务数据\n4.服务文档\n### 系统通知"},{"title":"leadship-tech-reading-summary","url":"/2021/11/02/leadship-tech-reading-summary/","content":"- 明确目标，做接近目标的事\n- 激发工程师动力，开心干活，态度积极\n- 理解，信任，尊重 - 默契是磨合和积累的\n- 用户需求的本质？\n- case by case - sometimes\n- black swan incidents\n- The Process (接受过程，接受变化)\n- 产品价值\n- 未来-语言对数据的处理能力\n- Java的生态"},{"title":"团队项目质量控制","url":"/2021/11/02/团队项目质量控制/","content":"\n## 谈什么\n### 首先：\n- 线上的稳定性相关\n### 项目评审设计阶段：\n- 产品使用的流畅度\n- 布局是否合理，UI交互组件是否合适\n- 重点是否突出｜逻辑是否完备（建议，提醒，越早越好）\n\n## 过程\n### 发现问题，整理问题\n#### 现状（线上质量，开发测试阶段质量）\n- 运营,测试团队 - p0,p1,p2\n- 冒烟测试情况｜各轮测试情况\n- 自测质量\n\n\n#### 问题原因\n- 业务逻辑\n- 技术（底层依赖，语法兼容，null safety等）\n- 构建（版本依赖）\n\n\n#### 技术控制\n- git hooks\n- 测试驱动的冒烟用例\n\n#### 流程制度\n- 新人业务串讲 - 细节+导师评审\n- 技术评审｜业务设计评审\n- 思维上 - 抓住本质，feature类简单的问题不确定的就查文档，查规范，问问caniuse，不要模糊-模糊等于0；\n\n### 定期项目review\n#### unused 清理\n> npm\n- depcheck （依赖）\n- unused-file-pligun（图片资源文件等）"},{"title":"broadcast-随便听听-summary","url":"/2021/11/02/broadcast-随便听听-summary/","content":"\n## netdisk\n### language reltives\n#### 新年愿望清单（New Year resolution）\n这是西方人力资源管理中常用的一个模型，KSA（Knowledge, Skills and Abilities framework）即知识、技能和才华模型。这个模型阐述了知识和技能的区别和联系。\n学习知识（knowledge），是多渠道获取、消化和记忆信息（information）的过程，主要通过理解概念（concept）以及知悉事实（fact），最终达到“我知道了、我懂了、我记住了（know what）”的效果。\n而学习技能（skills），是在已有知识的基础上，通过反复模仿（repeated imitation）和刻意练习（deliberate practice），最终能够娴熟使用某种工具（tool），达到“我会了、我熟练了、我运用自如了（know how）”的效果。\n语言，从本质上讲是一种技能，一种需要通过反复模仿和刻意练习才能娴熟使用的工具。"},{"title":"小程序开发总结","url":"/2021/11/02/小程序开发总结/","content":"> 大量产业升级 - 新需求 - 小程序=>解决前端的问题\n\n## 一些库\n- https://tdesign.tencent.com/miniprogram/components/button\n\n## 一些文档\n- https://www.yuque.com/webboys/pnadia/qggxhs\n## Video\n> 互动视频组件开发\n### why\n- 视频（v2.4.0 起支持同层渲染） 相关api：wx.createVideoContext\n- 可以做互动视频播放\n- https://developers.weixin.qq.com/miniprogram/dev/api/media/video/VideoContext.html\n\n### API\n- https://developers.weixin.qq.com/miniprogram/dev/api/media/video/VideoContext.seek.html\n- 跳转到指定位置\n### 什么场景会用\n\n- why\n\n• 诞生背景\n\t◦ 更好的体验\n\t◦ 规范与管理\n\n- what\n• 触手可及\n\t◦ 不需要下载安装即可使用\n• 用完即走\n\t◦ 扫or搜即可打开\n• 无需安装卸载\n\nAPP VS 小程序\n无需安装\n不占内存\n易传播\n\nwith h5 - 小程序（消息订阅，直接转发给好友）\n\n#### advantage\n（相对）（app - 时频，时长）\n- 下载，安装成本 - 无\n- 启动速度\n- hybrid-app - 审核周期\n- 用户体验｜商户运营｜技术开发\n\n> 学生端引流或者小型测试使用（运营引流+教师测试-课后配套免费服务）\n\n### feature - 持续拓展中！\n- 命名（可重名）\n- 星标\n- 关联多个公众号\n- 群能力\n- 灰度更新｜线上回退\n- 客服能力\n- 微信能力的接入\n\n#### 搜索\n- 百度影响了微信\n- 微信小程序SEO指南（20年1月） - 去中心化？\n- 搜一搜 - 提高小程序搜索排名（注意描述到填写）\n- 中间有个坑，22年的时候，年初，新开发的小程序，IOS端一直搜不到，然后需要配置搜一搜才能搜到\n#### 附近小程序\n- 评价机制\n- 本地化商家\n\n#### 基础商业能力的完善\n\n#### 直播组件\n- 2020年\n\n#### 小程序框架\n- 脱离微信客户端环境\n\n#### 订阅消息\n- 通知机制\n\n#### 安全问题\n- 对于webview部分，对于允许访问的域要做好控制，尤其设置文档对象存储的部分，一旦文档对象存储的密钥泄漏，容易被放入违规内容，然后进行举报\n\n#### 服务器域名配置\n每个微信小程序需要事先设置通讯域名，小程序只可以跟指定的域名进行网络通信。\n\n#### 业务域名\n\n- https://developers.weixin.qq.com/miniprogram/dev/framework/ability/domain.html\n- webview 指向网页的链接。可打开关联的公众号的文章，其它网页需登录小程序管理后台配置业务域名\n- 配置业务域名后，可打开任意合法的子域名；\n- 注意安全部分\n\n\n#### 登录及鉴权及权限设计\n- 待补充 - 简单逻辑 + 复杂项目逻辑 + 改造\n\n\n## 总结\n#### 触碰区域：\n要比显示的大点\n1.设计师切图，留点空白（透明的）\n\n\n#### Flex 布局(宽度陷阱)\nContainer 也要设置宽度\n记得设置内容的宽高\n如果确定宽度是100%，就设置，不然container是自适应的，被内部元素撑起来的\n\n#### 小程序中的继承机制——behavior——实现组件中的复用\n- 构造器\n- Es6 extend 单继承\n- 单继承比较简单\n- Behavior 继承与多继承的覆盖规则（子类会覆盖父类中的相关属性）（生命周期函数不会覆盖，会每个都执行）\n- (如果要构建自己的组件库，就很有用了，可以用在多个项目之中)\n- 面向对象中是通过class继承的\n- python 支持多继承\n\n#### tips\n```\n// 自定义事件的激活与监听\n可以设置事件的detail属性\n```\n- 表示类型命名尽量不用type，type 是保留关键字，用category\n- 想看data的初始值，可以在生命周期函数里面进行打印\n```\nNumber\nƒ Number() { [native code] }\ntypeof Number\n\"function\"\nProperties / data\n打印出来显示结果一样\n```\n- 设置name不要重名\n- 注意防范内存泄漏，不要在observer中修改自身属性， 会引起无限递归"},{"title":"Decorator模式","url":"/2021/11/02/Decorator模式/","content":"修饰器：\n\n\nObject.assign()\n\n基本用法\nObject.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。\nconst target = { a: 1 };\n\nconst source1 = { b: 2 };\nconst source2 = { c: 3 };\n\nObject.assign(target, source1, source2);\ntarget // {a:1, b:2, c:3}\nObject.assign方法的第一个参数是目标对象，后面的参数都是源对象。\n注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。\n\n\nObject.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。\n\nObject.defineProperty(obj, prop, descriptor)\n\nobj\n要在其上定义属性的对象。\nprop\n要定义或修改的属性的名称。\ndescriptor\n将被定义或修改的属性描述符。\n\n\n该方法允许精确添加或修改对象的属性。通过赋值操作添加的普通属性是可枚举的，能够在属性枚举期间呈现出来（for...in 或 Object.keys 方法）， 这些属性的值可以被改变，也可以被删除。这个方法允许修改默认的额外选项（或配置）。默认情况下，使用 Object.defineProperty() 添加的属性值是不可修改的。\n\n\n\n\n\n\n\n\n\n为什么修饰器不能用于函数？\n修饰器只能用于类和类的方法，不能用于函数，因为存在函数提升。\nvar counter = 0;\n\nvar add = function () {\n  counter++;\n};\n\n@add\nfunction foo() {\n}\n上面的代码，意图是执行后counter等于 1，但是实际上结果是counter等于 0。因为函数提升，使得实际执行的代码是下面这样。\n@add\nfunction foo() {\n}\n\nvar counter;\nvar add;\n\ncounter = 0;\n\nadd = function () {\n  counter++;\n};\n\n函数声明提升\n\n另一方面，如果一定要修饰函数，可以采用高阶函数的形式直接执行。\nfunction doSomething(name) {\n  console.log('Hello, ' + name);\n}\n\nfunction loggingDecorator(wrapped) {\n  return function() {\n    console.log('Starting');\n    const result = wrapped.apply(this, arguments);\n    console.log('Finished');\n    return result;\n  }\n}\n\nconst wrapped = loggingDecorator(doSomething);\n"},{"title":"android项目总结","url":"/2021/11/01/android项目总结/","content":"\n## 环境配置\n\n### doc\n- https://developer.android.com/studio/releases/platforms#9.0\n### Error \n#### Gradle sync failed: Could not install Gradle distribution from 'https://services.gradle.org/distributions/gradle-6.7.1-all.zip'. (40 s 221 ms)\n- ping了下这个域名 -> ping: cannot resolve https://services.gradle.org/distributions/gradle-6.7.1-all.zip: Unknown host\n- Gradle Scripts ->  gradle-wrapper.properties -> 在官网找到对应版本，下载，把能下载的地址粘贴过来(https\\://downloads.gradle-dn.com/distributions/gradle-6.7.1-all.zip) \n- https://developer.android.com/studio/build/?hl=zh-cn , Gradle官方相关配置说明\n\n#### Could not resolve all dependencies for configuration ':classpath'.\n- Using insecure protocols with repositories, without explicit opt-in, is unsupported.\n- http 改成 https\n### build err\nbuild => rebuild\n\n\n\n\n## WebView\nx5内核\t原生webview\n内核版本\t统一Blink内核(基于chromium)\t4.4以下WebKit，4.4以上chromium\n\n### 调试\n- https://github.com/google/ios-webkit-debug-proxy\n## Code-Review-Fix\n### 闪黑屏\n```\npublic abstract class BaseAppCompatActivity extends AppCompatActivity {\n    @Override\n    protected void onPause() {\n        super.onPause(); //fix\n        if (!isXXX()) {\n            return;\n        }\n        // origin \n        // super.onPause(); \n    }\n}\n```\nWeb调用原生提供的openPage的方法，中间会闪黑屏，Android的查问题，发现这个问题；\n\n## 单位\n- dp：Density-independent pixels\n- 以160PPI屏幕为标准，则1dp=1px\n- dp*ppi/160 = px\n- sp：Scale-independent pixels\n- 以160PPI屏幕为标准，当字体大小为 100%时， 1sp=1px\n- sp*ppi/160 = px\n- 建议文字用sp单位，非文字用dp单位\n- dp,sp 让物理感官上面的高度呈现不会因为设备的分辨率而受影响\n```\n <TextView\n            android:id=\"@+id/tv_content\"\n            style=\"@style/widget_font_medium\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"wrap_content\"\n            android:gravity=\"center\"\n            android:paddingHorizontal=\"8dp\"\n            android:text=\"@string/home_ai_speech_tip\"\n            android:textColor=\"@color/widget_color_white\"\n            android:textSize=\"16sp\"\n            app:layout_constraintBottom_toBottomOf=\"parent\"\n            app:layout_constraintLeft_toLeftOf=\"parent\"\n            app:layout_constraintRight_toRightOf=\"parent\"\n            app:layout_constraintTop_toTopOf=\"parent\" />\n\n```\n## 混淆\n- build process\n## 加固\n- apk文件\n- 爱加密移动APP安全加固系统\n- https://www.ijiami.cn/AppProtect/\n### 问题处理\n- .so , https://developer.android.com/ndk/guides/abis?hl=zh-cn\n- 加固之后，之前处理webview的包，需要再加个插件，解决加固之后的问题\n- 如果有注解的包，可能在加固之后容易有问题，需要做好处理\n\n### activity - launchmode - singletask\nandroid:launchMode=\"singleTask\"\n停机维护页面,和服务端约定接口状态，给出弹窗\n改成singleTask，类似于web的单例模式，这样只有唯一一个弹框了\n\n### user-agent 大赏\n#### 小米平板\n- Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/534.24 (KHTML, like Gecko) Chrome/89.0.4389.116 Safari/534.24 Device/nabu Model/21051182C XiaoMi/MiuiBrowser/14.6.62\n\n### 屏幕分辨率问题\n- 锁放大缩小\n\n### android端部分机型口语评测无法使用\n- 反馈情况为，第一次能用，后面突然无法使用\n- 同时接入了某飞的SDK（需要麦克风-语音助手类似）\n- 接入了第三方口语测评SDK\n- 第三方口语测评部分机型无法使用\n- 真机复现 -> 发现第三方口语测评SDK调用时报错，查出受另一SDK影响，因为都需要收音的资源，麦克风被占用了，所以上报的录音结果多次为0\n- 但是第三方口语测评SDK没有报错\n\n\n### bugly\n- Javascript的异常捕获功能\n- https://bugly.qq.com/docs/user-guide/advance-features-android/?v=1.0.0#javascript\n\n\n###\nHilt是一种非常好的依赖注入框架，如果按照最佳实践使用，可以大大提高Android应用的开发效率。下面是一些经验：\n\n1. **尽可能的使用预定义的注解范围：**Hilt提供了@Singleton, @ActivityRetainedScoped, @ActivityScoped, @FragmentScoped, @ViewScoped, @ViewModelScoped 这些预定义的注解范围。尽量使用这些来标记你的依赖。\n\n2. **在AndroidEntryPoint之下的组件中，不要使用自定义的组件依赖：**自定义的组件（使用`@DefineComponent`标注的）在`@AndroidEntryPoint`标注的类中不能保证正确的行为。\n\n3. **仅在必要的情况下使用自定义的组件：**自定义的组件可能会让Hilt的使用变的复杂。\n\n4. **模块中的重要标注：**对于模块中提供依赖的方法，要确保使用了`@Provides` 或 `@Binds` 标注。同时还要确保模块用`@InstallIn` 标定安装到了合适的组件中。\n\n5. **在模块中避免使用运行时参数：**尽量避免在`@Provides`或者`@Binds` 的方法中使用运行时参数。因为Hilt得知如何提供这些参数会很困难。\n\n6. **避免在应用启动时执行长耗时的操作：**尽量减少`@EntryPoint`或者`@Inject`在`Application`子类中执行耗时的操作，因为这会影响应用的启动时间。\n\n7. **使用Hilt的Android测试库进行单元测试：**Hilt 提供了一套工具，用以测试使用Hilt的Android应用。\n\n"},{"title":"react-native-summary","url":"/2021/10/25/react-native-summary/","content":"\n> notion 2022-7.22 除编辑器部分，切回原生开发（这种重交互的应用，长期看来，性能是核心指标）\n- 2020 rn 20-22 kotlin/swift + webview 22.7->从webview逐渐切回到原生\n- https://www.notion.so/releases/2022-07-20\n- https://twitter.com/jitl/status/1530326516013342723?s=20&t=xT0gfWhFvs0yNvc1GQ3sTQ\n- https://mp.weixin.qq.com/s/Jzqx3DWLlowszESQfBJZ9A （搞不定移动端性能，全球爆火的Notion从Hybrid转向了Native）\n\n## concept\n### view为中心\n\n\n## basic\n- create\n- run-ios | run android\n- import\n\n## \n\n## 直播\n### preview view\n### player view\n \n### RN API\n#### API设计风格\n#### 配置管理\n#### 状态管理\n#### 动作管理\n#### 事件管理\n\n\n### RN Layout\n- Flex Box\n- Streaming View Hierarchy\n - AspectFrameLayout\n - CameraPreviewFrameView\n - GLSurfaceView\n - Focus View\n\n### 腾讯云互动直播\n- https://cloud.tencent.com/solution/ilvb\n\n## 原生端和JS的通信\n- JavaScriptCore 桥阶层 - 翻译\n- RN对通信做了封装\n\n### 从RN向JS传递原生信息\n- 调用原生模块获取信息\n- 页面初始props\n- 原生端发送事件进行信息传递\n- 原生端设置JS全局变量\n\n```\n通信效率 | 时机问题 | 多入口场景 | 影响调试\n```\n\n### JavaScriptCore\n\n\n## Core - Basic \n### Component\n\n\n### Style\n\n\n### State\n- state - page里面会“动”的数据\n- state - 初选 ｜ 确定 ｜ 声明 ｜ 更新\n- 一件事情一个状态 & 重复状态去除 & 可计算的不是新状态\n\n\n### fast refresh\n- 快速刷新 => https://reactnative.dev/blog/2019/09/18/version-0.61#fast-refresh\n- `{} !== {}`\n- 基础的模块替换功能 - 组件级别的强制刷新\n- 复用组件和状态\n - 编译时-修改组件的注册方式\n - 运行时-“代理”的方式管理新旧组件的切换\n - \n\n\n## rn - lib\n- 可腾讯云文档里面搜，他们支持的sdk\n- bonree也支持\n#### .podspec\n- CocoaPods\n\n\n### ENV SETUP\n#### watchman\n- brew install watchman\n- Facebook Watchman 是一个文件监视服务，用于监控文件系统的更改。对于 React Native 项目，Watchman 可以提高开发效率，因为它能够实时监控项目中的文件更改并自动重新构建和刷新。当文件发生更改时，它会在后台执行相应的任务，例如实时重新加载应用。\nWatchman主要依赖几种主要的库和软件，这些库和软件包括：\n1. Autoconf：一个用于自动化生成可移植编译系统的工具，它会根据你的系统环境和你的特定需要来生成一份适合你机器的Makefile。\n2. Automake：与Autoconf配套使用的工具，它可以自动产生跨平台的Makefile.in文件。\n3. Libtool：用于创建可移植库的工具。\n4. pkg-config：它是用来在配置阶段检测库安装路径的工具。当你编译需要一些库文件（比如X、GTK、QT库等）支持的程序时，你可以用它快速找到这些库文件安装在哪里。\n5. Python-dev (仅在构建Python扩展时需要)\n6. OpenSSL (仅在构建fb303 Thrift 服务时需要)\n\nZstandard（也被称为zstd）是一个实时压缩算法，提供高压缩率和极快的解压缩速度。它由Facebook开发并且已经开源。Zstandard在设计上十分灵活，可允许用户在压缩/解压缩速度与压缩率之间进行权衡。\n1. 高性能：它提供了类似gzip的压缩率，但解压速度要快得多，对于需要频繁解压缩的场景，比如服务端服务，效果明显。\n2. 高压缩比：Zstandard也支持高压缩等级，以获取更高的压缩比，这意味着它可以为需要压缩大量数据的场景，如数据仓库大规模存储和传输，提供更好的解决方案。\n3. 具备字典压缩功能：Zstandard可以训练一个字典，以改进小数据压缩。如果存在大量的重复字符串，使用预训练的字典可以显著提高压缩率。\n在大多数系统上安装zstd非常简单，对于Unix/Linux系统，可以通过包管理器(如apt, yum等)来安装。例如，在基于Debian的系统上，可以用以下命令安装：\n```bash\nsudo apt-get install zstd\n```\n在macOS上，你可以通过brew来安装：\n```bash\nbrew install zstd\n```\n\n\n#### ruby\n- Ruby是一种通用的编程语言。React Native在一些与iOS依赖性管理相关的脚本中使用。和每一种编程语言一样，Ruby也有不同的版本，这些年来一直在开发。\n- React Native使用一个.ruby-version文件来确保你的Ruby版本与需要的版本相一致\n- ruby --version\n- 一些常见的Ruby版本管理器是：\n```\nrbenv\nRVM - https://rvm.io/\nchruby\n带有asdf-ruby插件的asdf-vm\n```\n- .ruby-version \n\n### CLI\n- React Native有一个内置的命令行界面。与其在全局范围内安装和管理特定版本的CLI，我们建议你在运行时使用Node.js附带的npx来访问当前版本。使用npx react-native <command>，当前稳定版本的CLI将在运行命令时被下载和执行。\n\n###\n- https://github.com/microsoft/react-native-windows\n\n- apps - opensource\nhttps://github.com/ReactNativeNews/React-Native-Apps"},{"title":"数字媒体技术相关-工作总结","url":"/2021/10/11/数字媒体技术相关-工作总结/","content":"> 本科时候专业是树莓，工作中也时常遇到相关问题（视频播放，直播等业务），同事也会来找我，现对这几年的问题做个总结，持续更新。\n\n\n## Basic\n### HTML 标签\n- <video> https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/video\n- <audio> https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/audio\n- <source> https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/source\n- <track> https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/track\n简单标签，但是细化的播放的需求需要借助媒体API\n\n### MSE\n- Media Source Extension\n- MediaSource && SourceBuffer && TrackBuffer && Video｜Audio Decoder\n- flv.js(封装视频流格式为目标的支持的格式)\n\n### Web Audio API \n- audio-react-flow-cn(https://github.com/zidanDirk/audio-react-flow-cn)\n### Media Stream API\n\n\n### WebRTC\n```\nMediaDevices.getUserMedia() 会提示用户给予使用媒体输入的许可，媒体输入会产生一个MediaStream，里面包含了请求的媒体类型的轨道。此流可以包含一个视频轨道（来自硬件或者虚拟视频源，比如相机、视频采集设备和屏幕共享服务等等）、一个音频轨道（同样来自硬件或虚拟音频源，比如麦克风、A/D转换器等等），也可能是其它轨道类型。\n```\nhttps://developer.mozilla.org/zh-CN/docs/Web/API/MediaDevices/getUserMedia\n\n### Canvas\n\n### WebGL \n\n### WebVR|XR\n\n### HLS协议\n- HTTP Live Streaming \n- 短连接 HTTP\n- 集合一段时间数据，生成TS切片文件，更新m3u8\n- 延时 >10秒\n- m3u8索引文件\n - 动态列表 live playlist\n - 静态列表 event playlist\n - 全量列表 vod playlist\n- TS容器格式\n- MSE帮助浏览器识别，把媒体内容封装成可识别的容器格式，如MP4\n- 单向广播\n\n### flv.js\n- 使flv格式能在浏览器上播放\n- H.264-视频\n- AAC｜MP3-音频\n- https://caniuse.com/#feat=mediasource - 浏览器\n- video && fetch|xhr|websocket - 浏览器支持\n### http-flv \n- RTMP over HTTP\n- 长连接HTTP\n- 同RTMP，使用HTTP协议\n- (一定程度避免防火墙干扰，http302兼容，https，移动端支持)\n- 1-3秒延时\n- 跨平台差，Flash Player以外的平台都需要做移植\n- 适合即时，要互动的\n\n### RTMP\n- real time messaging protocol\n- 基于tcp\n\n\n## 参考阅读文章\n- WebGL | WebGPU\n- https://mp.weixin.qq.com/s/4LfaNHP77s9n9SghucYoaA\n- 每个时刻的数据，收到后立刻转发\n- 延时 1-3秒\n\n### Video\n- container/wrapper\n- metadata\n- image \n - resolution\n - color\n - luminosity\n - frame rate\n- audio\n- audio\n\n## chromium-graphics\n- https://www.chromium.org/developers/design-documents/chromium-graphics/\n\n## ffmepg\n- x265\n- https://stackoverflow.com/questions/36118658/how-to-install-libx265-for-ffmpeg-on-mac-osx\n- https://superuser.com/questions/785528/how-to-generate-an-mp4-with-h-265-codec-using-ffmpeg\n- https://caniuse.com/?search=hevc\n- https://ffmpeg.org/ffmpeg.html\n### 有个文件，腾讯云转码后播放到3：21的时候就卡住了\n```\nffmpeg -i f0.mp4 -c:v libx264 -preset medium -crf 23 -c:a copy ouput_h264_f0.mp4\n```\n```\nframe= 6049 fps=183 q=29.0 size=    5376kB time=00:03:21.24 bitrate= 218.8kbits/frame= 6129 fps=183 q=29.0 size=    5632kB time=00:03:24.31 bitrate= 225.8kbits/[h264 @ 0x7feac2012e00] Invalid NAL unit size (224994 > 215737).\n[h264 @ 0x7feac2012e00] Error splitting the input into NAL units.\n[mov,mp4,m4a,3gp,3g2,mj2 @ 0x7feac1008200] stream 1, offset 0x2402089: partial file\nf0.mp4: Invalid data found when processing input\n[mov,mp4,m4a,3gp,3g2,mj2 @ 0x7feac1008200] stream 1, offset 0x2402100: partial file\nf0.mp4: Invalid data found when processing input\n[mov,mp4,m4a,3gp,3g2,mj2 @ 0x7feac1008200] stream 1, offset 0x240214f: partial file\nf0.mp4: Invalid data found when processing input\n[mov,mp4,m4a,3gp,3g2,mj2 @ 0x7feac1008200] stream 1, offset 0x240219b: partial file\nf0.mp4: Invalid data found when processing input\n[mov,mp4,m4a,3gp,3g2,mj2 @ 0x7feac1008200] stream 1, offset 0x24021e9: partial file\nf0.mp4: Invalid data found when processing input\n[mov,mp4,m4a,3gp,3g2,mj2 @ 0x7feac1008200] stream 1, offset 0x240223f: partial file\nf0.mp4: Invalid data found when processing input\n[mov,mp4,m4a,3gp,3g2,mj2 @ 0x7feac1008200] stream 1, offset 0x240228d: partial file\nf0.mp4: Invalid data found when processing input\nError while decoding stream #0:1: Invalid data found when processing input\n[mov,mp4,m4a,3gp,3g2,mj2 @ 0x7feac1008200] stream 1, offset 0x24022d9: partial file\nf0.mp4: Invalid data found when processing input\n[mov,mp4,m4a,3gp,3g2,mj2 @ 0x7feac1008200] stream 1, offset 0x2402327: partial file\nf0.mp4: Invalid data found when processing input\n[mov,mp4,m4a,3gp,3g2,mj2 @ 0x7feac1008200] stream 1, offset 0x240237e: partial file\nf0.mp4: Invalid data found when processing input\nframe= 6157 fps=182 q=-1.0 Lsize=    5971kB time=00:03:25.33 bitrate= 238.2kbits/s speed=6.06x    \nvideo:2845kB audio:2907kB subtitle:0kB other streams:0kB global headers:0kB muxing overhead: 3.804614%\n\n```\n\n## webkit-scrolling\n\n\n## 图像优化\n- https://assets.coursebox.xdf.cn/TaHwOKPytcKVLJlHUlMdz.pdf\n- https://tinypng.com/\n- https://squoosh.app/\n- 可以找UI做处理，根据图形or图像本质的特点，选择合适的方法，满足渲染诉求的情况下，做出压缩\n- https://cloud.tencent.com/document/product/460/36544 - 服务端对业务数据的一些处理\n\n\n### reading\n- https://mp.weixin.qq.com/s/6GomXdpIoNg87MC7lY7O7Q - 大前端视频播放器\n\n### 标签 + 认知通道效应 => 推荐\n\n\n### cocos3d\n```\n开启 WebGPU\nCocos Creator自3.6.2起开始支持WebGPU, 构建Web-Desktop的时候勾选WEBGPU即可. 构建WebGPU之后，先定位到构建好的资源文件所在文件夹，可以点击构建面板上的文件夹按钮直达，需要一个http-server或者nginx服务器来访问。 在此之前请先检查浏览器的兼容性，下章浏览器兼容性会有详细介绍\n```\n- https://www.w3.org/TR/webgpu/\n\n### css GPU animation\n- https://www.smashingmagazine.com/2016/12/gpu-animation-doing-it-right/\n- https://fed.taobao.org/blog/2016/04/26/performance-composite/"},{"title":"flutter技术解析与实战-闲鱼-精读","url":"/2021/10/11/flutter技术解析与实战-闲鱼-精读/"},{"title":"python-language层面-总结","url":"/2021/10/11/python-language层面-总结/","content":"> bytes are bytes; characters ara an abstraction;an immutable sequence of unicode characters is called a string;an immutable sequence of numbers-between-0-and-255 is called a bytes object;(dive into python3)\n## 开发指南\n### google python style guide\n- https://google.github.io/styleguide/pyguide.html\n\n### PEP 8 -- Style Guide for Python Code\n- https://www.python.org/dev/peps/pep-0008/\n- flake8 ```pip install flake8```\n\n## 推荐\n### Jupyter Notebook\n- vscode 插件\n- https://github.com/jupyter/notebook\n- The Jupyter notebook is a web-based notebook environment for interactive computing.\n- https://jupyter-notebook.readthedocs.io/en/stable/\n\n### SQLAlchemy\n#### ORM\n- Object-Relational Mapping\n- ORM框架的作用 - 把数据库表的一行记录与一个对象互相做自动转换\n- https://github.com/sqlalchemy/sqlalchemy\n- nodejs的话就是mongoose(https://github.com/Automattic/mongoose)\n\n### type -a python\n- 找到python解释器的完整路径\n\n## lib\n#### contextlib\n- https://pymotw.com/3/contextlib/index.html\n\n## basic\n### pythonic\n- https://www.tiobe.com/\n- Java 静态语言，有编译过程\n- ES6出来后，对面向对象的支持改善了\n- python动态语言，面向对象（思想），（现实到计算机的映射）的语言\n- 缺点：慢\n- 编译型：C，C++（源代码编译成机器码）\n- 解释型：javascript, python\n- Java,C#（编译成中间代码）\n- 胶水语言（把C，C++编写的模块组合在一起）\n- 回归语言的本质，享受语言本身的纯粹之美\n### 基本数据类型\n#### 数字 - Number\nint 整型 | float 浮点 | bool 布尔 | complex 复数\n\n#### 组\n序列 - str | list | tuple (有序，可用下标索引来访问，切片操作[0,5])\n集合 - set (无序，没有索引，不能切片)\n字典 - dict(key:value 键值对)\n\n#### 字典 枚举\n- Python的枚举是个类，其它的语言是个类型，有关键字\n```\nclass VIP(Enum):\n\tYELLOW = 1\n\nPrint(VIP.YELLOW)\nVIP.YELLOW \n\n\nVIP.YELLOW.value\nVIP.YELLOW.name\n# 枚举类型，名字，值\n\nfor v in VIP:\n\tprint(v)\n\n枚举类型不支持 > < 比较\n```\n- 表示类型：字典（数据结构），类（封装）\n\n- 缺点：都是可变的，可以被更改（类型被确定下来之后，是不让更改的）没有防止相同标签的功能\n\n- 枚举：如果值相同，第二个的标签就是第一个的别名了，遍历的时候，第二个就不会出现;想要得到第二个，遍历这个\n```\nfor v in VIP.__members__.items():\n\tprint(v)\n\n\nfor v in VIP.__members__:\n\tprint(v)\n```\n- 数据库存储：值用数字\n```\na = 1\nprint(VIP(a))\n# 枚举转换\nEnum\nIntEnum\n```\n\n### 装饰器：\nunique\n@unique\n\n- 枚举在python中的实现是单例模式，所以不能new\n\n- 设计模式应该在实践中,设计模式防止代码乱变化\n\n\n## 函数：\nprint()\n\nround(1.234, 3)\n\n\nhelp(round)\n\nimport this\nThe Zen of Python, by Tim Peters\n\n函数：\n1. 功能性\n2.   隐藏细节\n3.   避免编写重复的代码\n组织代码，自定义函数\n\ndef 关键字定义一个函数\n\n1.参数列表可以没有\n2.return value ,如果没有，默认返回的是None\n\nImport sys\n\nsys.setrecursionlimit(100000)\n\n\n可变参数\n\n对函数的返回值没有类型限制（动态类型语言）\n\n解构赋值（序列解包）： 接收返回结果\n\nPython 中数字不能和字符串相加\n\n（定义过程中：形参，调用过程中：实参）\n代码的可读性\n1. 必须参数\n2. 关键字参数（c = add(y=3, x=2)）\n（区别在于调用上，定义上一样的）（关键字参数也要满足必须参数）\n\n3.  默认参数（定义和调用的时候：非默认参数不能放在默认参数后面）\n\n## 面向对象\n有意义的面向对象的代码\n\n类，对象\n实例化\n\nclass StudentHomeWork( ):\n\n\n调用了类下面的方法\n\ndef fun(self):\n\n类最基本的作用：封装代码\n\n类只负责定义（刻画，描述）\n运行和调用要放在类的外部\n\n建议模块里面如果写类，就写类，对类的调用就不要放在这个模块了\n\n\n函数，方法：\nC,C++\nJava, C#\n\n方法：设计层面\n函数：程序运行，过程式的一种称谓\n\n\n变量出现在模块，就是称为变量\n如果出现在类里面，就是数据成员\n\n\n类和对象：\n\n类是现实世界或思维世界中的实体在计算机中的反映\n它将数据以及这些数据上的操作封装在一起\n\n数据成员表现特征\n方法刻画行为\n\n\n当类被实例化后，就变成了一个具体的对象\n\n\ndef __init__():\n不能返回除none之外的值\n构造函数\n初始化对象的属性（特征）\n\n实例化的时候，自动调用构造函数\n\n模块下的全局变量，模块下函数里的局部变量\n\n\n类变量-和类相关联在一起\n实例变量-和对象相关联在一起\n在面向对象的角度思考这个问题\n\n类是抽象的，对象是具体的\n\nStudent类就不要name,name应该是对象有的\n\n保存对象的特征值：\nself（对实例变量赋值要加self）\n\n谁调用了这个方法，self就是调用的那个实例对象\n\n实例方法：和对象实例相关联的，实例可以调用的方法，定义时要self（显胜于隐），调用时不用传的\n\n其他语言可能会用this \n显胜于隐\n\n动态语言，写起来简单，但是对一些机制理解不深刻，就容易有坑\n\nstudent1.__dict__\nStudent.__dict__\n\n\n\npython类\n\t变量\n\t\t类变量\n\t\t实例变量\n\t方法\n\t\t实例方法\n\t\t类方法\n\t\t静态方法\n\t构造函数\n\t成员的可见性\n\t面向对象3大特性\t\n\t\t继承性\n\t\t封装性\n\t\t多态性\n\n方法可以操作变量，大部分是用来操作变量的\n\n实例方法描述类的行为\n构造函数初始化类的各种特征的\n\n实例方法访问类变量\n\nself.__class__.sum1\nStudent.sum1\n\n定义类方法：\n\n@classmethod\ndef plus_sum(cls):\n\tpass\n\n\nStudent.plus_sum()\n\nPython 中，对象可以调用类方法\n\n\n静态方法，类方法\n\n静态方法，和类和对象都没什么关系，不太推荐使用\n\n类的内部调用，外部调用\n\n## 包，模块，函数与变量作用域\n\n高性能，封装性（可复用），抽象能力\n\n包(文件夹) dll.jar\n模块 .py\n类\n函数，变量\n\njs:npm is the package manager for JavaScript and the world’s largest software registry. Discover packages of reusable code — and assemble them in powerful new ways\n\n\n\nFind, install and publish Python packages with the Python Package Index\n\n\nseven.c4\nsix.c4\n\n命名空间\n\n包下面可以有子包\n\n__init__.py\n\nimport module_name\nimport t.c7 as m\n包引用的方法机制也是为了解决引入的各种问题，方便我们使用\n\n\n解释型语言——有顺序的\n__pycache__ 提高python运行效率的，虚拟机\n\nVscode:\n Files.exclude\n__pycache__\n\nPy换行 \\\n\n或者加（）\n\nFrom c9 import (a, b \n,c) \n\n系统内置类库（内置标准库）\n\nclear  清屏vscode\n\n\n\n\n\n\n\n批量导入库\n\n__init__\n\n\n系统思维\n\n包和模块不会被重复导入的\n避免循环导入\n\n一旦导入，就会执行模块里面的代码，在导入阶段只会执行一次\n\n入口文件的概念\n\n## 工程\n- vim ｜ vscode 插件\nPython \n不强制；\n不需要{}区分代码块，用的缩进\n\n条件控制 if else\n循环控制 while\n分支 switch(python不是)\n\n桌面端代码的加密比较重要\n\nPython 不适合去空格的压缩\n\nACCOUNT\ntype_kind_level\n\n\n看似变量的丢到模块里面，会导致识别为不应为变量\n变量应该在函数或者模块里面\n\nPylint\n\nSnippet\n\n结构体-作用域\n\n代码块里面的代码是同级别的\n\npython 没有goto \n\n分支里面很多分支，典型面向过程\n\n抽成函数，基本的抽象\n\nelif 替代 switch\n字典的方式替代 switch（比较好）\n\n从终端输入的得到的是字符串\n\nA,b 不可能同时为false\n\na or b\n\n循环，解决问题的思维模式，甚至穷举\n\nWhile（condition 不能是常量）（python 中有else）(递归)\nFor 遍历/循环 序列，集合，字典(break, continue)(range())\n\n序列切片\nB = a[0, len(a):2]\nPrint(b)\n\n## concept\n命名可读性\n\n变量要有意义\n\n变量存储在内存中的值。这就意味着在创建变量时会在内存中开辟一个空间。\n基于变量的数据类型，解释器会分配指定内存，并决定什么数据可以被存储在内存中。\n因此，变量可以指定不同的数据类型，这些变量可以存储整数，小数或字符。\n\n保留关键字不能用作变量名\n如type,print 等方法也不要用做变量名\n\n值类型，引用类型（值可以改变）\n\nPython id 显示内存地址\n\n\t1.\t1，id() 内存地址2.==比较的是值3.is  比较的是内存地址    数字，字符串，有小数据池    int -5--256    str:1,不能有空格        2.长度不能超过20个字符        3.不能有特殊字符如：#@....\n\n\njs取不到的，用chrome的heap snapshot，能看到一个等价的地址，但不是真实的内存地址。\n\n回复 flcwl：\njs不提供对内存的直接访问，debug工具也只提供到vm的虚拟内存空间，想要取到底层的进程虚拟内存空间，只有用gdb去调试引擎源代码：https://medium.com/fhinkel/de...\n\n\n一、作用域链：函数在定义的时候创建的,用于寻找使用到的变量的值的一个索引,而他内部的规则是,把函数自身的本地变量放在最前面,把自身的父级函数中的变量放在其次,把再高一级函数中的变量放在更后面,以此类推直至全局对象为止.当函数中需要查询一个变量的值的时候,js解释器会去作用域链去查找,从最前面的本地变量中先找,如果没有找到对应的变量,则到下一级的链上找,一旦找到了变量,则不再继续.如果找到最后也没找到需要的变量,则解释器返回undefined。\n二、内存回收机制：一个函数在执行开始的时候,会给其中定义的变量划分内存空间保存,以备后面的语句所用,等到函数执行完毕返回了,这些变量就被认为是无用的了.对应的内存空间也就被回收了.下次再执行此函数的时候,所有的变量又回到最初的状态,重新赋值使用.但是如果这个函数内部又嵌套了另一个函数,而这个函数是有可能在外部被调用到的.并且这个内部函数又使用了外部函数的某些变量的话.这种内存回收机制就会出现问题.如果在外部函数返回后,又直接调用了内部函数,那么内部函数就无法读取到他所需要的外部函数中变量的值了.所以js解释器在遇到函数定义的时候,会自动把函数和他可能使用的变量(包括本地变量和父级和祖先级函数的变量(自由变量))一起保存起来.也就是构建一个闭包,这些变量将不会被内存回收器所回收,只有当内部的函数不可能被调用以后(例如被删除了,或者没有了指针),才会销毁这个闭包,而没有任何一个闭包引用的变量才会被下一次内存回收启动时所回收。\n\n>>> id(p)\n16079976\n>>> hex(id(p))\n'0xf55c68'\n\n#!/usr/bin/python\n\naList = [123, 'xyz', 'zara', 'abc'];\naList.append( 2009 );\nprint \"Updated List : \", aList;\nUpdated List :  [123, 'xyz', 'zara', 'abc', 2009]\n\n\njQuery append()\n\nTuple 不可改变，有时候需要\n\n\n\nJs:\n2**9\n512\nMath.pow(x,y) // x的y次幂 x——底数,y——幂数\n\n成员运算符\n\n对象的三个特征\n值，身份， 类型\n==    is   isinstance\n\n位运算符\n\n表达式是运算符和操作数所构成的序列 (序列：有序的)\nexpression     operator   operand\n\n从左向右 左结合\n\n如果有 =\n右结合\n\n \n转义字符 - 特殊的字符\n- 无法“看见”的字符\n- 与语言本身语法有冲突的字符"},{"title":"css应用总结","url":"/2021/10/09/css应用总结/","content":"### 分页\n> 做的PDF打印的服务\n\n#### break\n- 用于模版的分页处理\n- block元素（不脱离文档流，非弹性布局）\n- page-break-after | page-break-before | page-break-inside\n- https://developer.mozilla.org/zh-CN/docs/Web/CSS/page-break-after\n- break-after\n- https://developer.mozilla.org/zh-CN/docs/Web/CSS/break-after\n- inside用avoid，避免元素被分割，例如本项目中题目index|tag|icon等元素(page-break-inside: avoid;)\n- after用always，在需要插入分页的地方使用\n\n#### orphans | windows\n\n### css\n```\nreset.css # 所有样式都被消除\nnormalize.css # 更合适\n# 引入第三方样式库之后，可以看看他们对全局样式的处理，再决定自己要不要做\n```\n#### box-sizing\n- https://developer.mozilla.org/zh-CN/docs/Web/CSS/box-sizing\n- \n```\nNote: 对于新的web站点，你可能希望首先将box-sizing设置为border-box，如下所示：\n\n* { box-sizing: border-box; }\n\n这使得处理元素大小的工作变得容易得多，并且通常消除了在布局内容时可能遇到的许多陷阱。然而，在某些情况下，你应谨慎使用这个属性。例如： 你正在编写一个将由其他人使用的共享组件库，如果他们网站的其余部分没有设置此值，他们可能会发现很难使用你的组件库。\n```\n\n#### outline\n- https://developer.mozilla.org/zh-CN/docs/Web/CSS/outline\n```\nborder 和 outline 很类似，但有如下区别：\n\noutline不占据空间，绘制于元素内容周围。\n根据规范，outline通常是矩形，但也可以是非矩形的\n\n```\n\n#### :focus | :hover\n\n#### mask处理\n可以写个mask\n<div class=\"xxx-xxx-mask\"></div>\n<div class=\"xxx-xxx\"></div>\n可以用结构的方法调\n\n\n#### calc()\n- https://developer.mozilla.org/zh-CN/docs/Web/CSS/calc()\n- 应用在嵌入到IOS，Android的应用的服务项前端页面\n\n\n#### white-space\n- 富文本相关的录入和渲染，英语学科对 \n`white-space: pre-wrap; work-break:work-break; text-align:justify;`\n- 这个会在Safari`text-align:justify;` 不生效； Safari 只设置 `text-align:justify;`才能生效；\n- https://developer.mozilla.org/zh-CN/docs/Web/CSS/white-space\n\n\n#### hover \n- https://developer.mozilla.org/en-US/docs/Web/CSS/@media/any-hover\n- 媒体查询，可以判断hover的可用性\n- https://caniuse.com/?search=hover\n- can i use - See full reference on MDN Web Docs. As of Safari for iOS 7.1.2, tapping a clickable element causes the element to enter the :hover state. The element will remain in the :hover state until a different element has entered the :hover state.\n- js - window.matchMedia('(any-hover: hover)');\n\n\n## unocss\n- https://antfu.me/posts/reimagine-atomic-css-zh \n- 基本上上面这篇看完了就知道了\n- 原子化CSS\n```\nJohn Polacek 在 文章 Let’s Define Exactly What Atomic CSS is 中写道：\nAtomic CSS is the approach to CSS architecture that favors small, single-purpose classes with names based on visual function.\n译文：\n原子化 CSS 是一种 CSS 的架构方式，它倾向于小巧且用途单一的 class，并且会以视觉效果进行命名。\n```\n\n#### querySelector | querySelectorAll\n- 如果选择器是一个ID，并且这个ID错误使用多次，返回第一个匹配该ID的元素\n- CSS伪类不会返回任何元素，selectors API\n\n#### object-fit/object-position\n- css3\n- https://developer.mozilla.org/zh-CN/docs/Web/CSS/object-fit\n\n\n#### em | rem\n- em相对于父元素，rem相对于根元素\n- r - root\n\n- 子元素字体大小的em是相对于父元素字体大小\n- 元素的width/height/padding/margin用em的话是相对于该元素的font-size\n- rem是全部的长度都相对于根元素(一般为<html>)\n\n#### BFC \n```\nBlock Formatting Context\n- https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Block_formatting_context\n- 页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素, 反之也如此\n- 因为BFC内部的元素和外部的元素绝对不会互相影响，因此， 当BFC外部存在浮动时，它不应该影响BFC内部Box的布局，BFC会通过变窄，而不与浮动有重叠。同样的，当BFC内部有浮动时，为了不影响外部元素的布局，BFC计算高度时会包括浮动的高度。避免margin 重叠也是这样的一个道理。\nclear:both BFC/haslayout\nzoom:1(IE6/IE7)\n.clearfix:after { content:\"; display:block; height:0; overflow:hidden; clear:both; }\n.clearfix{ *zoom:!; }\n.clearfix 应用在包含浮动子元素的父级元素上\n```\n\n#### 定位\n```\n内凹圆角\n学会组合，拆解图形\nlinear-gradient()\n径向渐变\nrelative/absolute\n限制定位 ab:  left:0 top:0\n限制层级\n限制超越overflow\noverflow：hidden 不能限制ab 但是加了relative，可以了\nrelative、fixed 限制z-index层级\nrelative，定位特性 相对自身定位 无侵入定位：自定义拖拽\ntop/bottom left/right 绝对定位是拉伸 相对定位是斗争（top,left）\nrelative 提高层叠上下文\ndom流后面覆盖前面\nposition：relative(提高层级)\nrelative z-index :auto->不限制内部absolute层叠问题\nIE6，7下，容易出现层级覆盖bug\nrelative的最小化影响原则\n```\n\n### ifc / bfc / 盒模型\n- 格式化上下文 - 决定渲染区域内节点的排版，关系和互相作用的渲染规则\n- https://zhuanlan.zhihu.com/p/110617108\n\n### @charset @import\n- https://developer.mozilla.org/en-US/docs/Web/CSS/@import\n- https://developer.mozilla.org/en-US/docs/Web/CSS/@charset\n```\nImported rules must come before all other types of rules, except @charset rules and layer creating @layer statements. The @import rule is not a nested statement. Therefore, it cannot be used inside conditional group at-rules.\n```\n\n### CSS模块化\nclass名 + hash值\n\n\n### CSS Hack\n- IE8以下\n```\n<!--[if IE]>\n\t<style>\n\t.zzz {\n\t}\n\t</style>\n\t<![endif]-->\n```\n- Avoid CSS Expressions\n\n#### 微观现象\n- 换行编写行内元素，排版会出现5px空隙\n- 行内元素统一以底边垂直对齐\n- 排版若一行无法完成则换行接着排版\n\n#### 文档流\n- 节点参与浮动布局后，自身脱流但其文本不脱流\n- 节点参与定位布局后，自身及其文本一起脱流\n\n#### z-index\n- 层叠上下文指盒模型在三维空间Z轴中的表现行为\n- z-index只在声明定位的节点中起效\n- 节点在Z轴的层叠顺序根据z-index、层叠上下文和层叠等级共同决定\n\n#### clearfix\n- https://stackoverflow.com/questions/211383/what-methods-of-clearfix-can-i-use\n\n#### 布局\n\n### 函数\n#### 颜色函数\n- rgb | rgba | hsl | hsla | color \n- RGB色彩模式 - A透明度（rgba声明的透明度不会应用到子节点中，而opacity声明的透明度会应用到子节点）- 基于笛卡尔坐标系\n- 普通颜色可以用HEX色彩模式（16进制色彩模式）\n- HSL色彩模式是工业界的色彩标准（色相，饱和度，亮度）\n- HSL是将RGB中的点在圆柱坐标系中标记出来的表示法\n#### 属性函数\n- attr | var\n- While attr() is supported for effectively all browsers for the content property, CSS Values and Units Level 5 adds the ability to use attr() on any CSS property, and to use it for non-string values (e.g. numbers, colors).\n\n#### 数字函数\n- clamp ｜ counter ｜ counters ｜ calc | max | min\n- calc - 每个运算符号必须使用空格间隔，可混合不同计量单位动态计算\n- 解决路由切换时滚动条导致的网页抖动（`padding-right: calc(100vw - 100%)`）\n#### 背景函数\n- url | element | image-set | linear-gradient | radial-gradient | conic-gradient | repeating-linear-gradient | repeating-radial-gradient | repeating-conic-gradient\n\n#### 滤镜函数\n- blur ｜ brightness ｜ contrast ｜ drop-shadow ｜ grayscale ｜ hue-rotate | invert | opacity | saturate | sepial \n\n#### 图形函数\n- circle ｜ ellipse ｜ inset ｜ path ｜ polygon \n\n#### 变换函数\n- matrix ｜ perspective ｜ rotate ｜ scale ｜ skew ｜ translate\n\n#### 缓动函数\n- cubic-bezier ｜ steps\n\n#### 图形函数\n- clip-path - 创建一个只有节点的部分区域可显示的剪切区域 - 只能裁剪折线形成的图形，曲线不行\n\n### 变量\n#### --var | var()\n- 自定义属性（--var）\n- 函数var()用于引用自定义属性\n\n#### API\n- elem.style.getPropertyValue()\n- elem.style.setProperty()\n- elem.style.removeProperty()\n### background ｜ mask\n#### 属性连写\n- color | image | repeat | attachment | position |｜ size | origin | clip | blend-mode\n- margin padding border outline mask font transition animation\n- position/size\n- clip - 镂空文本\n#### 渐变\n- line-gradient\n- radial-gradient\n- conic-gradient\n- repeating-*\n\n#### mask\n- https://www.canvasapi.cn/CanvasRenderingContext2D/globalCompositeOperation\n\n\n#### filter:grayscale(1)\n- <html style=\"filter:grayscale(1)\"> - 把当前节点及后代节点声明为100%的灰度模式\n- 节点声明不为none的filter时，如果自身及后代节点声明了position:absolute/fixed，则为其创建一个新容器，使这些定位节点其定位基准相对新容器进行\n- 所以不要在body或者主要节点中声明filter，html是合适的\n- html是最顶层的容器，即使创建了新的定位基准节点，不会对自身及后代节点产生不符合预期的影响\n\n#### transform\n- flat | perserve-3d\n- tarnslate | scale | skew | rotate | matrix | perspective - 视距效果\n- GPU硬件加速模式 - transform：translate3d() | translateZ() ， webkit内核中，translate3d() 明显； 问题解决-will-change（还会有别的问题），减少translate3d() 节点数量\n\n#### 1px\n- 移动端某些设备看着粗\n- 使用伪元素的边框去当作节点边框，声明border为1px,宽高声明成200%，再声明transform:scale(.5)\n\n#### 内容翻转\n- transform:scale()为负值\n\n#### 过渡\n- transition-property 。。。\n- 缓动函数 - 贝塞尔曲线 - https://cubic-bezier.com/\n\n#### 选择器\n```\n+：相邻同胞选择器\n~：通用同胞选择器\n:not()：非指定条件的元素\n:hover：鼠标悬浮的元素\n:focus：输入聚焦的表单元素\n:valid：输入合法的表单元素\n:invalid：输入非法的表单元素\n:checked：选项选中的表单元素\n:placeholder-shown：占位显示的表单元素\n:nth-child(n)：元素中指定顺序索引的元素\n```\n#### 动画\n- 状态\n- 关键帧动画 ｜ 逐帧动画 - GIF\n- 关键帧动画必须通过animation与@keyframes声明\n- 逐帧动画只能通过animation-timing-function:steps()声明\n\n#### 表单控件\n```\n模块切换   ~  :checked  nth-child(n) \n选中状态   :hover\n输入状态，校验内容  :focus  :valid  :invalid\n判断输入框是否存在内容  +  :not()  placeholder-shown\n```\n```\nplaceholder：占位，在未输入内容时显示提示文本\npattern：正则，在输入内容时触发正则验证\n:valid：作用于输入合法的表单节点\n:invalid：作用于输入非法的表单节点\n```\n## 其他\n#### 声音波形\n- https://wavesurfer-js.org/\n"},{"title":"ecs-and-cvm","url":"/2021/10/06/ecs-and-cvm/","content":"> 17年到现在，团队在阿里云和腾讯云之间切换了几回（各种原因），现对于使用过的产品做下梳理；\n\n# 阿里云\n\n## 网络与CDN - 负载均衡\n### 文档\n- https://help.aliyun.com/document_detail/196874.html\n- \n\n### TIPS\n- 计费 ｜ 可用区（单｜多）\n\n## 云服务器 - ECS\n### 文档\n\n### Basic\n- Elastic Compute Service\n- 基于虚拟化资源池\n- 多线BGP\n  - border gateway protocol 边界网关协议 - 配置在路由上\n  - 三网（跨运营商）\n  - 解决不同网络之间的差异\n  - 动态｜静态BGP - https://developer.aliyun.com/article/179417\n- 专线\n\n#### 创建\n- 地域 - 可用区\n- “不同地域的实例之间内网互不相通；选择靠近您客户的地域，可降低网络时延、提高您客户的访问速度”\n- 用户所在地 \n- 相关别的产品也买在相同可用区\n- 数据备份，冗余，异地多活\n\n\n## 控制台Tips\n- APP｜Web\n- Web全功能，也在不断改进体验 - console域下\n- 善用站点提供的搜索功能\n- 公司账号 - 费用和工单 - 按量计费｜包年包月\n- 腾讯云我们是比较大的用户，会有专门的客服QQ群，回复还是非常及时的（不同支持时效收费也不一样，和每年消费的额度到达某个额度也相关，各部分服务的折扣也和消费额度相关）\n\n## ECS节点选择\n- 目标用户所在地\n- 购买的各种服务之间注意关系\n- 数据冗余\n\n## 选型\n- 公网带宽（注意根据需求计算）\n- 会本身有类型分类，根据指引选择 - 个人\n- 企业有定制的\n## VPC\n- 经典网络 - 所有ECS直接建立在传统网络层之上\n- VPC - 加入逻辑隔离私有网络 - 安全性提升\n- VPC - natGateway|Router|Switch - 自定义\n- 企业网络 - 需要接入专线到XX云机房 - VPC提供了可能\n\n## EIP\n- eth0 内网IP eth1 公网IP\n- 弹性公网IP ｜ ECS公网IP - 和实例绑定在一起的\n- 弹性公网IP - 支持在ECS上面弹性绑定和解绑\n- ECS ｜ EIP - 关系\n- 弹性公网IP支持的协议 - TCP｜UDP｜ICMP\n\n## ECS弹性网卡\n- 随时可以实现分离的虚拟网卡\n- vCPU >= 4\n- 适合搭建高可用集群\n- 低成本故障转移\n- 精细化网络管理\n- 不同配置支持的可增加的弹性网卡的数量不一样\n\n## NAT网关\n- 公司采用的就是这种\n- 具体可见腾讯云文档\n- 不用每一个服务器，绑定一个vpc公网；通过统一得公网地址做限制策略，便于管理，也比每一个公网地址绑定省钱 \n## ECS配置\n- 密钥对 ｜ 密码\n- 密钥对生成 - ssh-keygen - 公钥配置到服务器\n- 登录 ssh -i ~/.ssh/id_rsa root@xxx.xxx.xxx.xxx\n- 如果ssh登录有问题，可以通过远程连接\n\n## ECS快照\n- 手动 ｜ 自动\n- 增量快照机制（第一次快照全量，后续增量）\n- 快照会影响磁盘I/O - 所以处理场景和时机要把握好\n- 自动快照执行前清理不必要数据 - 定时任务清理日志等\n- 快照OSS资源包 - 容量选择 - 看下Used大小\n- 备份周期\n\n## ECS镜像\n- 镜像源快速生成ECS实例\n- 创建自定义镜像\n- 快照可以生成自定义镜像\n\n# 腾讯云\n\n### NAT\n- https://cloud.tencent.com/document/product/552/12951\n# 其他\n\n## Tengine\n- 配置nginx的时候走这个\n- http://tengine.taobao.org/\n\n\n## SLB\n- 负载均衡\n- 访问流量-转发策略-后台服务器\n- 承载高并发，提高性能，高可靠性，后端服务冗灾\n- 内网的负载均衡一般没啥费用\n- 多可用区｜单可用区\n\n#### LB - 轮询协议\n- 前端协议[端口] + 后端协议[端口]\n- 轮询｜加权轮询｜加权+最小连接数\n- 会话保持-基于ip （按照源ip,分配给对应服务器） ｜ 用户登录等场景\n- TCP协议 - 会话保持 - 基于ip\n- HTTP协议 - 会话保持 - 基于Cookie\n\n#### 配置\n- 基本配置\n- 健康检查配置\n```\n健康检查\n- 基于TCP\n- 基于HTTP\n仅七层监听器（HTTP/HTTPS）支持配置访问日志（Access Log），四层监听器（TCP/UDP/TCP SSL）不支持\n腾讯云监听器（https://cloud.tencent.com/document/product/214/1255）\n监听器的配置规则如下：\n在同一个负载均衡中，一个负载均衡端口只能对应一种协议，\n支持 HTTP、UDP、TCP、HTTPS 协议，内网型只支持 UDP、TCP 协议，\n当创建 HTTPS 协议监听器时，不支持批量创建。\n```\n\n#### 主备服务器组\n\n#### 虚拟服务器组\n\n## 弹性伸缩\n- 自动调整弹性计算资源的大小，满足业务需求的变化\n- LB + 云监控（自动控制资源数）\n#### feature\n- 自动化资源配置\n- 性能问题还是要先看性能瓶颈在哪儿\n- 模式 - 定时模式｜动态模式-基于云监控性能指标 ｜ 固定数量模式 ｜ 自定义模式 ｜ 健康模式 ｜ 多模并行模式\n- 自定义模式 - 自己监控平台\n- 开通服务 - 创建伸缩组 - 设置触发任务\n\n#### 伸缩组\n- 配置 - 最大，最小实例数\n\n#### 任务管理\n- 定时任务｜\n\n## GRE隧道\n#### Basic\n- Generic Routing Encapsulation 通用路由封装\n- 把两个不同的VPC网络通过建立一条虚拟隧道的方式连接到一起\n- 本质上还是通过公网连接的\n```\nhttps://www.sdnlab.com/gre-tunnel-experiment/\nGRE(通用路由协议封装）是由Cisco和Net-smiths等公司于1994年提交给IETF的，标号为RFC1701和RFC1702。GRE规定了如何用一种网络协议去封装另一种网络协议的方法。GRE的隧道由两端的源IP地址和目的IP地址来定义，允许用户使用IP包封装IP、IPX、AppleTalk包，并支持全部的路由协议（如RIP2、OSPF等）。通过GRE，用户可以利用公共IP网络连接IPX网络、AppleTalk网络，还可以使用保留地址进行网络互连，或者对公网隐藏企业网的IP地址。\n```\n- `ip r` 查看本机路由表 `ip route add|del` `ip tunnel add` - 新建隧道 `ip link set xxx up`\n- GRE报文封装 - GRE报文解开\n- 网段配置规划\n```\n10.0.0.0/8\n172.16.0.0/12\n192.168.0.0/16\n```\n```\nlsmod | grep ip_gre\nmodprobe ip_gre\n```\n\n## 云架构\n- ECS + RDS + Memcached 基础架构\n- ECS + 云盘 -> 云存储storage(oss)\n- 入口 -> （不同节点分流（DNS -> 根据不同地区的用户打到不同节点）+ CDN）\n- 高并发 - 冗灾 && 负载均衡 + 数据库-读写分离 + memcached集群\n- 多VPC - 不同地域之间 - 阿里云VPC专线 \n- 混合云 - 安全性｜可控性｜可弹性 - IDC托管 + 公有云服务的优势"},{"title":"centos7","url":"/2021/10/06/centos7/","content":"## history\nUnix（FreeBSD） - 贝尔实验室\nMinix - 安德鲁\nLinux - Linus Benedict Torvalds - (Redhat -> Centos | Ubuntu )\n\n## 使用率\n\n## basic\n#### 基础变更\n- 文件系统 - xfs\n- /etc/hostname - 修改主机名 | timedatectl set-timezone - 时区设置 | ip - ip信息查看| ss - 端口查看 ｜ firewalld - 防火墙 | systemd - 服务管理 ｜ chrony - 时间同步\n- 默认支持docker - 内核支持：OverlayFS ｜ Repo源支持\n- 不再支持32位操作系统\n- GNOME 3.x\n- centos7 - systemd 不断完善，强大 (ubuntu等也在不断加强使用)\n\n#### hostname\n```\nvim /etc/hostname\n直接改里面的名字\nreboot # reboot 之后，永久修改才会生效\n```\n\n#### file | dir\n- 树状结构\n```\n/bin = User BINaries \n/sbin = Superuser BINaries \n/etc = ETCetera - configuration files\n/dev = DEVices files\n/proc = PROCesses information - top命令\n/lib = LIBrary - system libraries\n/tmp = TeMPorary \n/usr = Unix Shared Resources  - user programs\n/boot = Boot loader files\n/var = VARiable \n/opt = optional add-on apps\n/mnt = mount directory\n/media = removable devices\n/src = service data\n```\n有时候查问题的时候，注意6/7的文件目录结构的变更\n- bin -> usr/bin (7链接到了usr/bin下)\n- sbin -> usr/sbin\n- lib | lib64 等同上\n- centos7 里面多了run目录\n```\ncd /;ls ./\n```\n\n#### timezone\n- 中国 - +8\n- 时区不准确，会导致系统时间有问题，即使配置了时间同步\n```\ndate -R\ncat /etc/local\ncat /ect/localtime\ntime\ntimedatectl # ntp的协议进行时间同步的｜RTC - 本地主板时间\ntimedatectl set-timezone Asia/Shanghai\ntimedatectl set-local-rtc 1 # 将硬件时间调整成和本地时间（local time zone）一致\n```\n\n#### 网络接口\n- 默认命名规则\n- centos6，如果是Dell的，可能会有em0等出现\n- centos7 - net.ifnames 命名全自动，可预知，但是命名比较难读 ｜ biosdevname = 提供给Dell部分\n- /etc/sysconfig/grub -> GRUB_CMDLE_LINUX\n- ifconfig - 阿里云的有这个命令，这个命令在（centos7-minimal安装）里面就默认没有了\n- ip还是很强大的，推荐使用\n```\nip a # a - addr \nip a add|del # 修改ip地址信息\nip link set dev eth1 down|up # 关闭｜启用网络接口\n# 策略路由配置\n```\n\n#### 自动补全\n- tab （一下｜两下）\n- 名字 ｜ 参数 - 安装bash-completion,然后重新登入主机\n\n#### 系统内存\n- 操作系统内存 - 应用程序 ｜ buffers ｜ cached ｜ 未使用\n- shared 是很小的，不同程序间的共享内存\n- Buffers - 存储速度｜优先级 - 不同的设备之间传输数据的缓存区域\n- Cached - CPU读取数据文件缓存的存储缓存区域\n- Buffers ｜ Cache 部分可以回收，来提供给应用程序使用\n- 操作系统内存耗尽，触发OOM机制（out of memory），导致系统自动重启\n- swap原理要理解 - 操作系统内存不够，会用swap -其实解决不了根本问题- mongoDB等还会产生问题\n- Used到60%-80% 要注意\n```\ntop # 1 | shift + M | shift + P\nfree # 内存\nfree -m # 单位 M，free是未被分配的内存，Used-应用程序使用的\n```\n\n#### 端口状态查看\n```\n# ss - centos7 - 执行快（比netstat）- /proc/net/\n# netstat - centos6 - /proc/-遍历\n# ECS里面这两个默认都有\nnetstat|ss -luntp # 查看正在监听的端口\nnetstat -an | grep 80 # 查看使用某个端口的情况\n# umount /proc/ -l 再用netstat或者ss，就会提示，提取不到信息了\nss -ltn # 查看tcp对应的\nss -lun # 查看udp对应的\n# ss 可以通过各种参数配置，查看各种状态，判断问题\nss state established | wc -l\nss -s # 概览，做一个大概判断 ｜ synrecv如果很高，可能遭受攻击\nss -an sport eq 22\n```\n\n#### TCP\n- listen | established | fin_wait1 | close_wait | fin_wait2 |last_ack | \"time_wait\" | closed\n- syn_sent | syn_recv\n- 三次握手｜四次挥手\n\n## Systemd\n#### basic\n- Systemd - centos7 - 新采用的管理体系，对比sysVini(centos6)\n- 服务管理｜启动项管理｜系统启动级别｜定时任务｜日志管理\n- centos6 - service|chkconfig|init|cron|syslog\n- centos7 - systemctl|systemctl|systemctl|timer|Systemd-journal\n- 支持并行启动\n```\n# 可以提高开机启动速度(case，找一台中间机器，比较下速度)\nyun install vsftpd\n# 对于不同的6,7的，进行reboot，从中间机器上，看下联通情况\nsystemctl enable vsftpd # 加入开机启动-7\nchkconfig vsftpd on # 加入开机启动-6\n\nwatch 'echo exit|nc xxx.xxx.xxx.xxx 21' # 中间机器\n```\n- centos7 关机只关闭正在运行的服务\n- 对于服务的挂历不需要init.d下的脚本\n- Service ｜ Syslog - 原有问题解决\n\n#### systemctl\n- 文件扩展名 - 管理单元\n```\nsystemctl -t help # 查看支持哪些单元的管理\ndf -h\nsystemctl list-unit | grep 'boot' \nsystemctl start|stop nginx # service\n```\n- 如果无扩展名，systemctl默认会把扩展名当成.service\n- `systemctl list-units | --failed | list-unit-files | deamon-reload`\n- 单元管理命令 - start|stop|restart|reload|status|is-enabled\n- 基本命令 enable|disable|mask|unmask\n- systemctl [options] command [name]\n- systemctl -h\n\n#### target \n- SysVinit vs Systemd\n- 系统启动运行级别 - 0～6\n```\n# SysVinit\ncat /etc/rc.d/rc3.d\nrunlevel\ninit|telinit 6 # 非永久\n# Systemd\nsystemctl get-default\nsystemctl set-default|isolate xxx.target\nreboot\n```\n- `systemctl list-dependencies` # 看到关联关系\n- `systemctl --reverse list-dependencies xxx.service`\n\n#### service\n```\n# SysVinit\nservice name start|stop|restart|reload|status|condrestart\n# Systemd\nsystemctl start|stop|restart|reload|status|condrestart name\n```\n```\nrpm -ql nginx\nrpm -qa nginx\nvim nginx.service\nsystemctl start nginx.service\nsystemctl status nginx.service\nsystemctl reload nginx.service # 不希望重启，只是重载下配置文件，这样几乎不会影响用户访问\nsystemctl restart nginx.service # 如果有用户正在使用，会有影响\ncat nginx.service 或 systemctl cat nginx\n# [unit] - 单元的说明及依赖相关的设置 (wants|requires区别)\n# [service] - define - 单元的管理方式(type=simple-该服务将立刻启动|forking-当该服务进程fork,且父进程退出后服务启动成功｜oneshot|notify|dbus|idle)\n# [install] - define - 加入到target单元中\n```\n- 软件包安装的单元 - /usr/lib/systemd/system/\n- 系统管理员安装的单元 - /etc/systemd/system/\n\n#### 自定义服务单元\n```\n#!/bin/bash\n\necho $$ > /var/run/xxx.pid\nwhile :\ndo \n    echo \"hello,\"$(date) >> /tmp/xxx.res\n    sleep 1\ndone\n```\n```\ntail -f /tmp/xxx.res\ncp nginx.service xxx.service # 改一下拷过来的配置文件\n# :! ls /path 可以测试路径是否正确\n```\n```\nsystemctl daemon-reload # 每次改完配置文件，要reload\n```\n\n#### Timers\n- 替代cron,定时控制服务事件（.service文件）\n- 定时任务 = service服务单元 + timer定时单元\n- 单调定时器 - 从一个时间点过一段时间后激活定时任务｜ 实时定时器 - 类比crontab(OnCalendar=*-*-* 00:00:00)\n- [Unit][Timer][Install]\n- https://fedoramagazine.org/systemd-timers-for-scheduling-tasks/\n```\nsystemctl list-timers\n```\n\n#### Journal\n- Systemd的日志管理\n- /etc/systemd/journald.conf\n- RAM - tmpfs /run (df -h)\n- /run/log/journal/  - 重启之后不会存在\n- ```journalctl```\n- 操作系统日志级别 - 0～7\n- `journalctl [options] [matches]`\n- notice|warning - 粗体 error-红色\n- `journalctl -n` # -n最后20行, -f实时，-p级别,-u具体单元\n\n#### Firewalld\n- https://firewalld.org/\n- iptables - centos6\n- 底层调用的iptables\n- 区域管理\n- 默认区域 - public\n- 活跃｜非活跃 区域\n- ls /usr/lib/firewalld/zones/\n- systemctl start firewalld.service\n- `fiewall-cmd --list-all`\n- `ip a`\n- 外部访问服务器，默认阻止，服务器访问外部默认允许\n```\n# 一个网卡接口只能属于一个zone,一个zone可以有多个网卡接口\n# 配置了网络接口的区域是活跃区域（或者源地址配置add-source）\nsystemctl status\nip a\nfirewall-cmd --get-active-zones\n```\n```\n# 端口白名单配置\nss -lntp\ntelnet xxx.xxx.xx.x 21 # 本机测试端口连通性\nfirewall-cmd --zone=public --add-port=21/tcp\nfirewall-cmd --list-all\nfirewall-cmd --reload # 动态加载新规则，在规则修改后，要执行这个，来使规则生效\nfirewall-cmd --complete-reload\nfirewall-cmd --zone=public --add-port=21/tcp --permanent\n# 服务白名单配置\nfirewall-cmd --zone=public --add-service=http\n```\n- 区域规则结合，可以得出想要的最终配置\n```\n# default 设置为drop\nfirewall-cmd --zone=trusted --add-source=xxx.xxx.xxx.xx/24\n```\n\n## 文件系统\n#### 基本\n- 装载 - 分区 - 格式化 => 文件系统\n- c6 - ext4,ext3,ext2   c7 - xfs  c7-ecs-ext4\n- xfs - 扩展性支持能力高于ext4\n\n#### 云盘\n- ECS存储空间\n- 数据隔离\n- 提升性能\n\n- /dev/vda ext4 /系统目录\n- /dev/vd* xfs /应用目录\n- fdisk /dev/vdb\n- mount \n\n"},{"title":"安全之滑块","url":"/2021/09/26/安全之滑块/","content":"### 文档指南\n- https://docs.geetest.com/sensebot/deploy/client/ios\n\n### 概述\n- 根据用户触摸行为轨迹判断用户类型\n- 脚本 ｜ 真人 \n- 根据用户类型的不同，不同类型概率触发滑块\n\n## 接入\n\n### IOS\n### Android\n### Web\n\n## bypass\n- https://docs.geetest.com/sensebot/deploy/bypass\n```\nByPass 定义\nByPass Mode（宕机模式或旁路模式）是极验为了确保在任何极端状况下都能及时、可控地实现服务降级，作为对客户业务流程保障的最终兜底机制。极验设置了一个独立于行为验证通讯流程之外的服务可用性监控接口，利用心跳检测查询极验服务，通过接口返回的状态标识确认当前验证服务可用性。当无法获取到极验服务器的响应时，该模式可及时进行降级处理暂时绕过极验服务，避免客户正常业务流程受到影响，保障客户业务流程的流畅性和稳定性。\n```"},{"title":"algorithm-and-logic-practice","url":"/2021/09/26/algorithm-and-logic-practice/","content":"\n## Course in JS\n- http://btholt.github.io/four-semesters-of-cs/\n- https://btholt.github.io/four-semesters-of-cs-part-two/\n- 包括了 \n```\nBig O\nRecursion\nBubble Sort\nInsertion Sort\nMerge Sort\nQuick Sort\nSet | Map | Stack | Queue - Data Structures - Interfaces\nArray List | Linked List | Binary Search Tree | AVL Tree | Hash Table - Data Structures - Implementations\nMap | Reduce | Filter - functional programming \nBloom Filters\nTree Traversals\nPathfinding\nGraphs\nGenerating a Maze\nTries\nSearching for an Element in an Array\nHeap Sort\nRadix Sort\n```\n## 随便写写\n#### 水仙花数\n\n```\nconst n = 150\nconst m = 158\nlet rangeStart = n\nlet rangeEnd = m\nlet isIn = (element) => {\n  let arr = element.toString().split('')\n  arr.unshift(0)\n  let res = arr.reduce((prev, cur) => {\n    return prev + Math.pow(Number(cur), 3)\n  })\n  if (res == element) {\n    return true\n  } else {\n    return false\n  }\n\n}\nlet getNarc = (rangeStart, rangeEnd) => {\n  let arrayIn = []\n  for (let index = n; index <= m; index++) {\n    if (isIn(index)) {\n      arrayIn.push(index)\n    }\n  }\n  return arrayIn\n};\nlet narcs = getNarc(n, m)\nconsole.log(narcs)\n```\n\n## leetcode\n\n\n\n## basic\n\n排序（快排，选择，希尔，冒泡） \n堆栈，队列，链表 递归～～～本质，终止条件，参数的传递\n波兰式和逆波兰式（1+2/3）\n\n## Stack && Queue[kju:]\n- Stack - FILO - Array || Linked List \n- Queue - FIFO - Array || Doubly Linked List\n- MQ\n- www.bigocheatsheet.com - time|space complexity\n\n## 20 合法括号\n```\nfunction isValid(s: string): boolean {\n    let stack : Array<string> = []\n    const parent_map : Object = {\n        ')': '(',\n        ']': '[',\n        '}': '{'\n    }\n    for(let i = 0; i< s.length; i++) {\n        if(!parent_map[s[i]]) {\n            stack.push(s[i])\n        } else if(stack.length === 0 || stack.pop() !== parent_map[s[i]]) {\n            return false\n        }\n    }\n    return stack.length === 0\n}\n```\n```\n不讲武德解法，一旦遇到(),{},[] 就用replace到空串，do while，哈哈哈哈，复杂度高点\n```\n\n### 232 225 栈和队列的彼此实现\n\n\n### adjacency Matrix\n\n\n## 经典排序算法\n- "},{"title":"flutter-study-summary","url":"/2021/09/25/flutter-study-summary/","content":"# Part1 - 领域knowledge\n\n## Dart\n### Tools\n- Dart Pad | dart online ground\n\n### Basics\n- print \n- 未初始化的变量的初始值为null\n- 1.12 => null-aware(?.  ??)\n- fn和js的差异主要在声明\n- Future ｜ Promise（JS）\n\n\n## Flutter\n### Basic\n- 命令式imperative｜声明式declarative UI（不管是原生还是Web，都经历了这样的过程）\n- 视图配置（like Widget）\n- create|run|import\n- import => material.dart(Material Design) | Cupertino(IOS风格Widget) | widgets.dart(基本窗口集)\n\n### 资源\n- Android - resources\n- IOS - Images\n- flutter - Assets引用方法 - pubspec.yaml中声明\n- device Pixel Ratio\n```\nldpi 0.75x | mdpi 1.0x | hdpi 1.5x | xhdpi 2.0x | xxhdpi 3.0x | xxxhdpi 4.0x\n```\n- images/xxx.png  | images/2.0x/xxx.png\n- IOS - Localizable.strings | Flutter - flutter_localization && intl && easy_localization\n\n### 依赖\n- Android - Gradle\n- IOS - Podfile\n- 仅在添加单平台相关的文件时候使用Podfile和Gradle文件\n- pub.dev\n- dart构建系统｜pub管理依赖\n\n### View 视图\n- Android - View\n- IOS - UIView\n- Widget\n\n### 布局\n- Android - XML\n- IOS - Storybook ｜ view controller\n## modules\n\n### Scaffold\n\n### PageView\n\n### Navigator\n\n### List\n\n### Image\n\n\n### NotificationListener\n### 自定义组件\n### Native Modules\n### AI Voice\n\n## Network && Storage\n### http\n\n## Channel\n\n\n## Plugins\n### Flutter\n### Native\n### 自定义\n\n\n\n# Part2 - 领域工程化，环境相关\n\n## ENV（具体Tips可参考之前“Flutter 开发环境配置”的博文）\n- 官方文档配置即可\n- 用好flutter doctor命令帮忙解决问题\n- 镜像按需配置（科学上网之后可忽略 \n- bash or zsh 配置（PATH ｜ storage_base_url && hosted_url）\n- ```PUB_HOSTED_URL https://pub.flutter-io.cn | FLUTTER_STORAGE_BASE_URL https://storage.flutter-io.cn```\n- Android Studio 也可进行环境变量配置 - 按需\n- Xcode - 安装&&命令行工具配置&&许可协议\n- IOS模拟器（Window > Scale）\n- 热加载-r｜热重启-R\n- Android Studio（按官方文档操作就行） - 机器上设置好硬件加速（VM acceleration）\n- Android Studio安装Flutter和Dart插件（perferences 选 plugins，搜对应关键词）\n- Android Studio - Android SDK 下载对应的（preferences 搜 Android SDK），View - VSC里面可视化版本控制\n- emulator -avd xxx (bash or zsh里面可配置好 emulator 路径)\n\n## 真机\n### IOS \n- homebrew - 安装相关库\n- worksapce - 进行设置（bundle id 确保唯一 - 不然自动签名会失败）\n### Android\n- 设备上启用开发人员选项和USB调试\n- ```flutter devices```\n\n## IDE\n### VS code\n- Android无法直接调试\n### Android Studio\n\n## Hybrid\n\n\n## Update && Upgrade\n\n\n\n## Build && deploy\n\n# Part3 - 业务模块\n### "},{"title":"http-request-cancel-chrome","url":"/2021/09/24/http-request-cancel-chrome/","content":"> review团队代码的时候发现这么一段，一看到某个操作依赖于上一个的异步行为，但处理不是走回调的时候，感觉就有问题了;\n```\n# 有问题的代码\ntoDownload(files) {\n        files.forEach(file => {\n          const iframe = document.createElement('iframe')\n          iframe.classList.add('downloading-iframe')\n          iframe.src = file.url\n          document.body.appendChild(iframe)\n        })\n        setTimeout(() => {\n          document.querySelectorAll('.downloading-iframe').forEach(i => i.remove())\n        }, 1000)\n      },\n```\n这是一个批量在浏览器里面下载的按钮，导致的问题是，如果快速点击这个按钮，会导致请求被cancel；\n在移除了\n```\nsetTimeout(() => {\n          document.querySelectorAll('.downloading-iframe').forEach(i => i.remove())\n        }, 1000)\n```\n这段代码后，请求被cancel的情况不再发生；\n即在上一个被load之前，就把上一批iframe标签remove了，这就导致了cancel（之所以快速点击按钮会让问题发生频繁，是因为每次点击会触发10个下载请求，这样会导致并发请求阻塞）\nstackoverflow上回答图片：\n![](cancel.png)\n\n#### 我们可以看看被cancel的资源请求的状态：\n![](status1.png)\n\n#### 一个没被cancel的\n![](status2.png)\n"},{"title":"google-api-design-guide-精读","url":"/2021/09/24/google-api-design-guide-精读/","content":"## 文档资源\n### 英文版\n- https://cloud.google.com/apis/design\n### 中文版\n- https://google-cloud.gitbook.io/api-design-guide/\n\n## 精读\n### "},{"title":"codeReview总结","url":"/2021/09/23/codeReview总结/","content":"\n### 逻辑完备，准确\n#### 看出循环调用的问题\n例如：一个报错方法，方法里面通过http post请求报错，但是这个报错方法本身是在http请求中做拦截处理，报错；这个时候，一旦报错的那个请求本身异常，被列为需要报错的部分，则进入循环引用；"},{"title":"iframe在项目中应用总结","url":"/2021/09/22/iframe在项目中应用总结/","content":"### 已落地的多种项目形式\n- 富文本编辑器-结合业务的输出\n- 公式编辑器\n\n### 跨部门团队协作\n- XXX-客户端，嵌入iframe\n- 报告对接\n- 中台系统-业务模块输出\n\n### 什么时候用？怎么用？\n\n## 基础点\n### iframe\n- https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/iframe\n\n### hack\n- 基于iframe的src,提供下载资源功能\n### 通信\n#### postMessage\n- https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage\n\n### 线上问题处理\n#### CSP\n- https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP\n- https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy\n- https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options\n- Specifies valid parents that may embed a page using <frame>, <iframe>, <object>, <embed>, or <applet>\n\n```\n# 不允许被嵌入\nContent-Security-Policy: frame-ancestors 'none'\n# 只允许被同源的页面嵌入\nContent-Security-Policy: frame-ancestors 'self'\n# 只允许被白名单内的页面嵌入\nContent-Security-Policy: frame-ancestors www.example.com\n\n# 不允许被嵌入\nX-Frame-Options: deny\n# 只允许被同源的页面嵌入\nX-Frame-Options: sameorigin\n\n```\n\n### nginx\n如果一个域名xxx.xxx.xxx  /abc/ 路径下部署了前端服务\n\n- iframe 里面嵌入 xxx.xxx.xxx/abc\n- 如果是xxx.xxx.xxx/abc 会被重定向，nginx , 这样会有问题，请求https，会被转为http\n- Nginx 内部重定向规则会被启动，例如，当 URL 指向一个目录并且在最后没有包含“/”时，Nginx 内部会自动的做一个 301 重定向\n- 需要xxx.xxx.xxx/abc/ ，这样才能匹配到，从而不被重定向\n\n\n### 视频自动播放问题\nhttps://developer.chrome.com/blog/autoplay/#iframe-delegation\n如果是跨域的站点，又希望能自动播放，需要再加上这个属性\n\n## 一些其它的结局方案\n### 微前端框架\n- qiankun\n- https://juejin.cn/post/6938207400457404430"},{"title":"yuque桌面端分析","url":"/2021/09/22/yuque桌面端分析/","content":"> 看语雀也用electron包了个桌面端，和我们这边现有的几款electron的application处理方式比较相似，稍微查看学习下；\n\n### 分析方式\n- 抓包（Charles）\n- 反解（asar）\n```\ncode Content\n# 打开终端\ncd resources\nasar e app.asar app\n# 这个时候，目录下就有了app文件夹，我们就可以具体看看了\n# 目前结构清晰，代码是压缩编译过的，不影响看\n# 找到main.js，加上\nwebContents.openDevTools()\n# 重新启动客户端，调试工具就加上了\n# 这个时候我们就能看到resources部分，资源大概是怎么分配的了，什么放在端上，什么不是\n```\n\n#### 包地址\n- https://www.yuque.com/install/desktop\n\n"},{"title":"email-基于HTML","url":"/2021/09/22/email-基于HTML/","content":"- 参考资料：https://github.com/rodriguezcommaj/frontendmasters\n\n### 限制\n- 基础的HTML+CSS\n- 基于table的布局\n- 简单的语义\n\n### 注意\n- CSS 样式重置（MS Office｜ 浏览器客户端 ｜ 超链接）\n- HTML标签的选择\n  - div|span  && h1-h6 && p|strong|em && img \n- 样式 embedded｜inline style\n- CSS选择\n  - text: color|font-family|font-size|font-style|font-weight|line-height|text-align\n  - block element: margin|padding|width|max-width\n- 图片\n  - 响应式\n  - 文本说明\n  - 格式限制：jpg,png,gif\n  - max-width:100%;min-width:X;width:100%; 宽度适应\n- accessibility\n  - 视弱｜色盲\n  - 高对比度｜视觉上面的层级｜可读性｜布局简单可用\n  - 少使用图片，用真的文字，这样可以通过辅助工具（NVDA，VoiceOver｜JAWS）读出来\n  - role=\"presentation\" - table\n  - 语义化标签｜图片有文本的alt|标注语言\n- table\n```\n<table border=\"0\" cellpadding=\"0\" cellspacing=\"0\"\nrole=\"presentation\" width=\"100%\">\n<tr>\n<td style=\"styles go here\">\n</td>\n</tr>\n</table>\n```\n- 移动端可读\n  - 判断版本\n  - 媒体探测\n\n- 交互\n  - :hover\n  - transition|@keyframes\n\n- 测试\n  - 可以用litmus进行测试\n  - caniemail.com\n  - Campaignmonitor.com/css\n  - Freshinbox.com/resources \n  - mjml.io\n\n- 参考\n  - TheBetter.Email/resources\n\n  ### API\n  - https://developer.mozilla.org/zh-CN/docs/Web/API/Document/createDocumentFragment\n  - createDocumentFragment"},{"title":"typescript-联合类型-UnionTypes","url":"/2021/09/18/typescript-联合类型-UnionTypes/","content":"\n在TypeScript中，接口或类型映射定义多属性时，用分号（;）来分隔是为了区别与对象字面量的定义。在JavaScript和许多其他语言中，对象字面量是使用逗号来分隔属性的。由于TypeScript是JavaScript的超集，为了避免混淆，所以在TypeScript的类型系统中引入了分号来区分这种不同环境。\n\n此外，分号在TypeScript类型定义中的使用还有助于增强代码的可读性和维护性。在某些情况下，逗号可能会引起语法混淆或者误解。例如，类型联合 `TypeA | TypeB，TypeC` 可能被误读为 `(TypeA | TypeB) 和 TypeC` 的联合类型，而实际上正确的解析应该是 `TypeA 和 (TypeB，TypeC)` 的联合类型。这是由于逗号在类型系统中的优先级低于“|”和“&”。因此，使用分号可以避免这种混淆。\n\n需要注意的是，即使在TypeScript中定义接口或类型，也可以用逗号来分隔属性，但是这并不是标准的使用方式。而且在有些Strict模式下的TSLint或ESLint规则中，可能会因此提出警告或错误。因此，最佳实践应当是在定义接口或类型时使用分号作为属性的分隔符。"},{"title":"single-file-component","url":"/2021/09/18/single-file-component/","content":"### vue 2.x\n\n- vue-template-compiler\n- https://cn.vuejs.org/v2/guide/single-file-components.html\n\n\n### vue 3.x\n- @vue/sfc-compiler\n- https://v3.cn.vuejs.org/guide/single-file-component.html#%E5%8D%95%E6%96%87%E4%BB%B6%E7%BB%84%E4%BB%B6\n```\n=>文档描述：\n工作原理\nVue SFC 是框架指定的文件格式，必须由 @vue/compiler-sfc 预编译为标准的 JavaScript 与 CSS。编译后的 SFC 是一个标准的 JavaScript（ES）模块——这意味着通过正确的构建配置，可以像模块一样导入 SFC：\n\nimport MyComponent from './MyComponent.vue'\n\nexport default {\n  components: {\n    MyComponent\n  }\n}\nSFC 中的 <style> 标签通常在开发过程中作为原生 <style> 标签注入以支持热更新。对于生产环境，它们可以被提取并合并到单个 CSS 文件中。\n\n可以在 Vue SFC Playground 中使用 SFC ，探索其是如何编译的。\n\n在实际项目中，通常会将 SFC 编译器与 Vite 或 Vue CLI（基于 webpack）等构建工具集成在一起，Vue 提供的官方脚手架工具，可让你更快地开始使用 SFC。查阅 SFC 工具 部分查看更多细节。\n```\n\n·\n### tips\n这个compiler的版本依赖于vue的版本，锁版本的时候注意，避免一个锁了，一个又有升级的宽容度（项目中出现过vue锁了版本，compiler没锁，但是没提示版本问题，编译出来的包Object（）,err）\n"},{"title":"e2e-testing","url":"/2021/09/18/e2e-testing/","content":"\n## nightwatch\n- https://github.com/vuejs/vue/blob/dev/test/e2e/nightwatch.config.js\n- vue使用的是nightwatch\n\n\n## 测试\n#### 第三方\n- WeTest - https://wetest.qq.com/products/topic/mp"},{"title":"dart-sass","url":"/2021/09/18/dart-sass/","content":"\n### 为啥要说这个\nvue-cli , create的时候，如果选择手动，在配置CSS预处理器的时候，提供了dart-sass 和 node-sass的选择；\n```\nPick a CSS pre-processor (PostCSS, Autoprefixer and CSS Modules are supported \nby default): (Use arrow keys)\n❯ Sass/SCSS (with dart-sass) \n  Sass/SCSS (with node-sass) \n  Less \n  Stylus\n```\n\n想到了若干年前，之前项目node-sass安装时候，网络的问题\n\n### 存在问题\nelementui的icon.scss\n里面的\ncontent的unicode会在loader sass-dart 处理过程中被转成  等字符，从而导致浏览器 接收css文件的时候如果编码方式有问题，会变成\"î›»\"，进而影响渲染；\n\n#### 解决方案\nissue讨论：https://github.com/PanJiaChen/vue-element-admin/issues/3526\n- \"sass\": \"1.39.0\",\n- @charset 'UTF-8';(src/styles/element-variables.scss)\n- (vue.config.js)\n```\ncss: {\n    loaderOptions: {\n      sass: {\n        sassOptions: { outputStyle: 'expanded' }\n      }\n    }\n  },\n\n```\n\n### node-sass\nnode-sass\nWarning: LibSass and Node Sass are deprecated. While they will continue to receive maintenance releases indefinitely, there are no plans to add additional features or compatibility with any new CSS or Sass features. Projects that still use it should move onto Dart Sass.\n\n\n### Node version support policy\n- 支持的Node.js版本因版本不同而不同\n- readme页面有对应列表\n- https://github.com/sass/node-sass#node-version-support-policy"},{"title":"浏览器基础梳理","url":"/2021/09/17/浏览器基础梳理/","content":"### 渲染\n- DOM｜CSSOM => Object Model\n- Render Tree\n- Script会阻塞渲染进程，因为里面的内容会改变Render Tree\n- css的link标签在head中，在渲染body里面内容时候，已经知道了样式应该怎么渲染（提升性能），body出来之前把样式定了\n- script标签在body最底部，不然会阻塞后面标签内容的渲染\n- window监听的load事件，页面全部资源加载完之后（图片，视频也包括），才执行\n- document监听的DOMContentLoaded事件，DOM加载完成后就可以执行了\n- nodejs做的PDF渲染服务，puppeteer，headless browser 里面提供的几个回调状态（不同加载和渲染状态）（TO BE COMP）\n- 懒加载（img => src（小图的地址） | data-realsrc（真正大图的地址）, 在最后的script标签里面（真正要用图的时候），再执行拉取资源替换图片的操作）\n- DOM查询缓存（构建list），合并DOM插入（document.createDocumentFragment）-通用处理策略\n- 事件节流（咱有个timeOutId,监听事件的时候呢，如果id有，就clear掉，如果没有，就赋值个定时器）\n\n### 资源\n- 压缩，合并｜分离\n - 构建工具处理这部分的plugin-模式，类型，经验总结（TO BE COMP）\n- 缓存 -- 浏览器缓存策略\n - 文件命名\n- CDN - 域名CDN加速\n\n### 安全\n- signature\n- DNS劫持（找运营商）\n- 上https\n- 456（集团接口正则匹配拦截）- 题目内容（公式加密转码后还是被误拦截了）\n- 集团安全组（端扫描）\n- http only cookie, 防止XSS攻击，获取cookie处理\n- 注意输入内容的控制（前端替换，后端替换），数据库maybe会报错（反解之后）；长度控制（约定，在设计数据库字段时候对类型的设计）；\n- 核心流程滑块+短信验证（XSRF）\n\n### cookie\n如果不设置有效期，默认存在内存，退出浏览器即没有了\n设置之后，存在了本地存储里面，退出浏览器再重新登录，可以不用重新登录；\n\n### 域名\n- www or not\n- https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/Choosing_between_www_and_non-www_URLs\n- http://www.hyperarts.com/blog/www-vs-non-www-for-your-canonical-domain-url-which-is-best-and-why/\n\n### setcookie\n如果请求的接口和origin不是一个域名\n那么，设置的时候，需要加上； secure; same-site=none;来允许跨域请求，这样才能set上\n要支持多个前端域名都可以访问，不过接口是其中一个域名，所以set-cookie的时候要增加这个配置\n\n如果是Safari浏览器的一些版本，则这么设置就不可以了，除非修改浏览器配置；出于安全策略考虑，就保持一个根域，请求的origin和接口的域；如果需要使用cookie的情况下。\n- https://bugs.webkit.org/show_bug.cgi?id=198181\n- https://github.com/GoogleChromeLabs/samesite-examples\n- https://web.dev/samesite-cookie-recipes/ - 说明了same-site属性的一些当下的情况和解决方案\n```\nRequire Secure with SameSite=None\nFlag: chrome://flags/#cookies-without-same-site-must-be-secure\nChrome Status entry: Reject insecure SameSite=None cookies\nTurn on this flag along with the previous flag to have Chrome enforce the need for any SameSite=None cookie to also specify the Secure attribute.\n```\n\n\n## web performance\n- https://speakerdeck.com/stevekinney\n- https://web.dev/i18n/zh/tbt/ - TBT的概念 - Total Blocking Time 总阻塞时间 (TBT)\n```\n总阻塞时间 (TBT) 是测量加载响应度的重要实验室指标，因为该项指标有助于量化在页面交互性变为可靠前，不可交互程度的严重性，较低的 TBT 有助于确保页面的可用性。\n```\n\n#### performance.now()\nhttps://developer.mozilla.org/zh-CN/docs/Web/API/Performance/now\noasis deltaTime计算\n#### link\n- https://blog.csdn.net/kaosini/article/details/42495471   比较早的一个说前端性能监控的文章，顺了下相关概念\n\n\n#### Xpath\nhttps://developer.mozilla.org/en-US/docs/Web/XPath\n\n\n#### browserlist\n- https://github.com/browserslist/browserslist\n\n\n## HTML\n#### form\n- https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form\n```\nenctype\nIf the value of the method attribute is post, enctype is the MIME type of the form submission. Possible values:\n\napplication/x-www-form-urlencoded: The default value.\n发送前编码所有字符 - 空格转为加号，特殊符号转为ASCII HEX值\nmultipart/form-data: Use this if the form contains <input> elements with type=file.\n不对字符编码\ntext/plain: Introduced by HTML5 for debugging purposes.\n空格转换为加号，但不对特殊字符编码\nThis value can be overridden by formenctype attributes on <button>, <input type=\"submit\">, or <input type=\"image\"> element\n```\n- https://developer.mozilla.org/en-US/docs/Web/API/HTMLFormElement/enctype\n\n## web APIs\n### DOM \n- https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model\n```\nThe Document Object Model (DOM) is the data representation of the objects that comprise the structure and content of a document on the web. This guide will introduce the DOM, look at how the DOM represents an HTML document in memory and how to use APIs to create web content and applications.\n```\n\n### ua\nWindows NT 系列的版本有以下这些：\n1. Windows NT 3.1：第一个NT版本,发布于1993年，使用NT内核。\n2. Windows NT 3.5：在NT 3.1的基础上增加了许多改进和特性，发布于1994年。\n3. Windows NT 3.51：对NT3.5版本进行小范围升级，发布于1995年。\n4. Windows NT 4.0：在用户界面和内核方面进行了大规模的更新与提升，发布于1996年。\n5. Windows NT 5.0：相当于Windows 2000，对Windows98进行升级，发布于2000年。\n6. Windows NT 5.1：这个版本更为人所熟知的是Windows XP，发布于2001年\n7. Windows NT 5.2：相当于Windows Server 2003版本，发布于2003年。\n8. Windows NT 6.0：对应于Windows Vista，发布于2006年。\n9. Windows NT 6.1：对应于Windows 7，发布于2009年。\n10. Windows NT 6.2：对应于Windows 8，发布于2012年。\n11. Windows NT 6.3：对应于Windows 8.1，发布于2013年。\n12. Windows NT 10.0：对应于Windows 10，发布于2015年。"},{"title":"browser相关-一些总结","url":"/2021/09/17/browser相关-一些总结/","content":"\n###\n- https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/\n- loupe\n### DTD\n\n### 占有率\n- https://gs.statcounter.com/browser-market-share/ \n\n\n## 问题处理\n### 清除所有cookie相关\n同样项目，起本地前端服务调试的时候，一个同事的电脑请求返回如下\n```\n{\"status\":0,\"message\":\"com.google.gson.stream.MalformedJsonException: Unterminated string at line 1 column 7 path $.\",\"data\":null}\n\n```\n清除了浏览器的所有application里面cookies等缓存，再次请求就好了\n\n服务端日志是入参被截断了；\n\n### browserslist\n- Share target browsers between different front-end tools, like Autoprefixer, Stylelint and babel-preset-env.\n- caniuse\n- https://github.com/browserslist/browserslist\n\n### caniuse\n```\nBrowserslist: caniuse-lite is outdated. Please run:\nnpx browserslist@latest --update-db\nWhy you should do it regularly: https://github.com/browserslist/browserslist#browsers-data-updating\n```\n\n### favicon - favorite icon -website icon - page icon - urlicon\n- `<link rel=\"icon\" href=\"/favicon.ico\">`\n## 性能\n- 10年前的 - yslow - https://github.com/marcelduran/yslow - http://yslow.org/\n\n\n### 浏览器兼容性真机测试\n- https://live.browserstack.com/\n- browser stack\n- 不方便的点可能是没有一些国产浏览器的选项\n\n## history\n- 市场占有 https://gs.statcounter.com/\n#### 渲染引擎\n Google Chrome：Webkit(前期 1-28)、Blink(后期 28+)\n Apple Safari：Webkit 1+\n Mozilla Firefox：Gecko 1+\n ASA Opera：Presto(前期 7-14)、Blink(后期 15+)\n Microsoft IExplorer：Trident 4+\n Microsoft Edge：Trident(前期)、Blink(后期)\n\n #### 国产浏览器 极速模式｜兼容模式\n - 双内核\n - 极速模式 - blink内核\n - 兼容模式 - Trident内核（政务网站，金融网站等）\n\n #### 浏览器私有属性\n - -webkit- -moz- -ms- -o-\n - 厂商 ｜ W3C组织\n - 兼容性写法前，标准写法最后\n - webpack postcss-loader | postcss-preset-env(autoprefixer-caniuse)\n\n #### 外观属性 ｜ 几何属性\n - 几何属性（布局｜尺寸）- 可用数学几何衡量的属性\n - 外观属性（界面｜文字）- 可用状态向量描述的属性"},{"title":"dns-prefetch","url":"/2021/09/15/dns-prefetch/","content":"> 之前对同一个系统的不同端及业务做了域的划分，切了不同的域名；降低服务器的压力；\n> 外网域名都会先走集团的服务\n> 目前会有几个移动端的项目，静态资源域本身会做CDN加速，然后入口页会集成不同业务，在合适的场景下，做下DNS-prefetch\n\n### 文档指路\n- https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/X-DNS-Prefetch-Control\n\n### 检测方式\n- WebPageTest\n- https://www.webpagetest.org/\n- 可以看到DNS解析消耗的时间\n\n### 原理\n- 通过html里面增加meta,告知浏览器，先解析指定链接，提前查询\n- 缓存DNS查询结果\n\n### 适用情况\n```\nchore:根据使用场景，增加DNS-Prefetch，项目负责人后续可根据业务及首页拉取情况进行增加或者删减(如果首屏不请求，后续会请求，且业务场景多的，可增加；如果首屏已请求，则可删除，避免浪费)\n\n    <!-- add dns-prefetch according to situation, if have been fetched in fisrtpage, just delete it; -->\n    <meta http-equiv=\"x-dns-prefetch-control\" content=\"on\" />\n    <link rel=\"dns-prefetch\" href=\"//xxx.xxx.cn\" />\n    <link rel=\"dns-prefetch\" href=\"//xxx.xxx.cn\" />\n\n```\n\n### 使用方式\n```\n# 打开和关闭 DNS 预读取\nX-DNS-Prefetch-Control: on\nX-DNS-Prefetch-Control: off\n\n<meta http-equiv=\"x-dns-prefetch-control\" content=\"off\">\n# 强制查询特定主机名\n<link rel=\"dns-prefetch\" href=\"http://www.spreadfirefox.com/\">\n\n```\n\n### 注意\n不要滥用，否则会增加DNS的压力（基于逻辑和数据来判断使用的场景和具体域）\n感觉最合适的应该是国际化的站点，如果没有对应国家部署不同的域的话；"},{"title":"通信协议-websocket","url":"/2021/09/13/通信协议-websocket/","content":"> 还是说文解字，用于“通信”的“协议”； web 指运行在web（也就是通常我们广义的理解的话 HTTP那一层的） 上；\n\n### 先明确几个定义\n\n#### “请求-应答”的通信模式-半双工\nHTTP是这个模式，问题在于同一时刻只能单方向动作；服务器被动响应；\n\n（HTTP/2 ｜ HTTP/3  ———— Stream｜Server Push）\n\n#### 轮询-polling\n问题： 消耗带宽和CPU资源\n\n#### long-polling\n- 发出大量请求\n- 在某个时间间隔内进行AJAX调用\n- 关键是什么？\n```\n保证核心操作的简单，快\n\n不要只使用setInterval - 没有考虑到请求需要时间的事实\n在当前请求完成后立即为下一个请求启动一个定时器（在函数的末尾为下一个请求SetTimeout）\n```\n\n\n\n### Websocket\n- HTML5规范出来的，RFC6455\n- 全双工，服务器和客户端可以随时发送数据\n- 二进制帧结构，语法语义与HTTP不兼容\n\n#### 协议\n- IETF \n#### API\n- W3C\n#### 服务发现\nURI：wss|ws 表明协议\n\n#### 默认端口\n80｜443\n\n#### 应用场景\n实时通信\n客户端需要不断更新的部分\n\n#### 帧结构\n- 指路wiki:https://zh.wikipedia.org/wiki/WebSocket\n- 指路RFC：https://datatracker.ietf.org/doc/html/rfc6455\n- 可以Wireshark抓包试一下，看看就有感觉了（N年前网络实验课啥都抓一下后遗症。。。\n- 抓出来的报文，Masking-key 异或下，就可以转出来明文了\n\n#### handshake\n- \"Connection:Upgrade\" \"Upgrade:websocket\" (HTTP 协议升级)\n- \"Sec-WebSocket-Key\" \"Sec-WebSocket-Version\"(Challenge，防止HTTP被识别为WebSocket)\n- 服务器返回一个\"101 Switching Protocols\"响应报文，\"Sec-WebSocket-Accept\"-由服务器对前面客户端发送的Sec-WebSocket-Key进行确认和加密后的结果，相当于一次验证，以帮助客户端确信对方是真实可用的WebSocket服务器\n- https://www.yuque.com/fe9/basic/101\n### case\n#### WebSocket is closed before the connection is established.\n\nIf you go to http://jsbin.com/ekusep/6/edit and view the JavaScript console you'll see the 'WebSocket is closed before the connection is established' logged. I've tested this in Chrome.\nIn this code what it means is that ws.close() was called (by user code) before the connection was even given a chance to be established.\nSo, the cause of this error is if code attempts to close the WebSocket connection before it's had a chance to actually connect.\n\n#### send()\n- 消息类型\n- 字符串 ｜ Blob ｜ ArrayBuffer\n- binaryType - 初始值为blob,可以设置为arraybuffer\n### 拓展理解\n- TCP Socket\n#### SSE - Server-Sent Events\n- https://developer.mozilla.org/zh-CN/docs/Web/API/Server-sent_events\n- 服务器推送信息\n- 服务器向客户端声明 - 接下来要发送的是流信息 streaming\n- 基于HTTP协议\n- IE/Edge低版本不支持\n- 单向通道\n- https://caniuse.com/eventsource\n\ncontent-type:\ntext/event-stream\n\n`text/event-stream`是一种MIME类型，它被用于服务器发送事件(SSE，Server-Sent Events)协议中。在这个协议中，通过一个HTTP连接，服务器可以发送到客户端的一连串的事件。与Websockets相比，SSE是单向的，只允许服务器向客户端发送消息。\n\n每个事件以`data: `开始，后面跟着消息的内容，然后是两个换行符来表示消息的结束。服务器可以发送任意多的事件，只要连接保持打开状态。\n\n这种类型的通信特别适合于服务器需要实时，持续地发送更新（例如股票价格更新，新闻滚动，实时计分等）给客户端，但客户端不需要频繁地向服务器发送数据的场景。\n\n使用`text/event-stream`的服务器发送事件(SSE)是HTML5引入的一个标准，被所有现代浏览器支持。"},{"title":"flutter-weekly-notes","url":"/2021/09/12/flutter-weekly-notes/","content":"> Youtube上面订阅的官方每周频道，的确是为了构建生态不遗余力了；\n### refresh indicator\n- https://dartpad.dartlang.org/?id=b00c533708923d9051356ba9b2da997e&null_safety=true\n- https://api.flutter.dev/flutter/material/RefreshIndicator-class.html\n\n"},{"title":"longman-expressions-and-words","url":"/2021/09/12/longman-expressions-and-words/","content":"### 54\n- swipe your card\n- tap | touch your card\n- tap/touch on/off in/out\n- insert your card\n\n### 53\n- You can read the book once I have finished it\n- once S V\n- when sth happens, sth changes / as soon as\n\n### 52\n- the Olympic Games | the FIFA World Cup | FIA Formula 1 World Championship\n\n\n## Documentries\n- Die gefährlichsten Schulwege der Welt - The Most Dangerous Ways to School\n\n\n## Engineering\n## Word List\n- sundries\n- grove\n## Sundries\n#### KSA\nknowledge，skills，abilities framework\n人力资源管理模型-知识和技能\n\n#### 剑南诗稿\n汝果欲学诗，工夫在诗外\n\n#### parallel text\n平行文本，相同话题的\n\n#### 张载\n- 横渠四句-为天地立心，为生民立命，为往圣继绝学，为万世开太平\n- 心中苟有所开，即便札记。不则还塞之矣\n\n#### proactive | reactive\n\n#### pro- re-\n- progress\n- regress\n- https://www.etymonline.com/\n\n#### settle for | settle\n\n#### specification\n- a detailed description of the design and materials used to make sth\n\n#### thin air\n- nowhere to be found in a giant void; nihility;nothingness; nullity;void; the state of nonexistence;\n- conjure a career from thin air\n\n#### empathy | sympathy\n- 共情｜同情\n\n#### software metrics | software measurements\n\n#### 语言学习的目的是交流\n\n#### curiostiy killed the cat\n- Inquisitiveness can lead one into dangerous situations.\n- Curiostiy killed the cat, but satisfaction brought it back.\n- keen as mustard\n- wasabi\n\n#### ship the milestone\n\n#### driveless | autonomous\n\n\n#### communicator\n\n#### listening tips\nthree, a number of ,numerous, a variety of , various, several, those 后面一般加可数名词复数\n\n#### festival\n```\nthe lunar new year\nusher in the lantern festival\nthe first lunar month\neat rice dumplings\nview lanterns\nriddle guessing games\nwatch stilt walking\ngather at a temple\npray for good luck\n```\n#### goods | products | commodities | merchandise\n\n#### arts funding\n```\nstate funding for the arts\nallocate budget to\nallocate funds to\narts funding\nrestore historical monuments\ncultural institutions\nchronic cash shortages\n```\n\n#### dogfooding\n- Eating your own dog food, also called dogfooding, is a slang term used to reference a scenario in which a company uses its own product to test and promote the product\n#### due date - the date on which sth is supposed to happen\n\n#### he responded on the fly with a brief statement\n- on the fly\n- off the cuff - spontaneous \n- off the top of my head - 不假思索地（说出某事）\n- comedy is just tragedy that occurs to some other person\n\n#### The main reason is inconsistent implementation by different browsers\n- inconsistent implementation 执行不一致\n#### relative pronoun |  participle\n\n#### idle | prompt-提示符 | distribution-发布 \n- 我们常用dist文件夹，用于distribution(存放最终发布版本代码)\n\n#### index｜ plural - indices\n\n#### live less out of habit and more out of intent | Life has taught us that love does not consist in gazing at each other but in looking outward together in the same direction | Create a life that feels good on the inside not one that just looks good on the outside | Make the most of yourself, for that is all there is of you \n\n#### My guideline is as good as any other's\n- 我的办法是最好的\n\n#### continual | continuous\n\n#### intelligent | smart | wise\n## newsDigest\n\n# Word Power Made Easy\n\n\n# Songs\n## let it go\n- versus\n- chords\n- bridge\n\n# travel\n### taking a taxi\n- pick up | drop off | pull over\n- phrasel verbs\n- move over | move to the side | out of the way\n- parking lot | basement parking\n- make a u-turn | turn around\n- \n\n## class\n#### restaurant\n- booth (sit at a booth)\n- a table for \n- patio\n\n\n### songs\n#### songs\n- in the end - Linkin Park\n- let it go - Lopez\n- somebody to love - Queen\n- the sound of silence - Simon & Garfunkel\n\n### Idiom\n```\nhave ants in your pants\nbehind closed doors\nbehind the scenes\nunder the table\ndeliver the goods\n```\n## channel\n### nts\n\n\n### dan\n- solving math exercises live\n- studio\n- \n\n"},{"title":"Java项目-startup","url":"/2021/08/30/Java项目-startup/","content":"\n> 公司 Java 项目快速起起来，一是深入了解下架构和实现，二是方便本地起，做调试；能在对接具体问题的时候，具体脉络有个清晰的概念；\n\n### 书籍 prepare\n\n- 码出高效，阿里巴巴 Java 开发手册\n- 编写高质量代码，改善 Java 程序的 151 个建议\n- Google API design guide 中文版\n- netty 权威指南\n\n### Java 代码规范\n\n- alibaba-代码规约 plugin\n- findBugs - plugin\n- SonarLint\n- sequence diagram\n- 设计原则：单一职责｜开闭｜接口隔离｜里氏替换｜迪米特｜依赖倒置\n\n### 数据库设计规范\n\n#### 命名规范\n\n- 库｜表｜字段 名不允许出现大写字母\n- 统一规范，数据库名：`ucan_业务名` ｜ 表名：`业务名_类型名_实体名`\n- 表类型：tb（基础信息表-数据基本不会增长） | td（业务产生数据表-数据随着用户操作增长） | tr（业务关系表-实体间的关联关系表）\n- 普通索引命名： `idx_字段名_字段名`； 唯一索引命名：`uniq_字段名_字段名`；\n\n#### 设计规范\n\n- 表｜字段 - 必须有注释\n- 表间逻辑关系\n- 表结构设计文档\n\n#### 设计文档规范\n\n- 项目背景（背景｜现状）\n- 设计目标\n- 系统设计（总体架构｜边界说明｜模块设计｜核心数据结构｜存储设计｜接口设计｜稳定性考虑｜兼容性考虑｜性能考虑）\n- 测试关注点\n- 上线及回滚方案\n- 工作拆解\n\n#### 运维部署文档\n\n- 数据库｜缓存\n- 域名\n- git\n- 服务器\n- 服务器内项目地址｜文件夹权限｜日志地址｜ 日志索引\n- 队列\n\n### Tips\n\n- 如果非结构化数据不涉及查询，聚合等操作，可以用 MySQL 的 JSON 字段替换 MongoDB document（分布式事务处理｜）\n\n### rules\n- 把简单的问题尽可能交给工具完成\n- 简单\n - 1、代码格式化 包引用\n - 2、编码规范规约（安装阿里的代码规约插件），右键菜单点击编码规范扫描\n - 3、安装FindBugs插件，用FindBugs查找bug\n - 4、安装SonarLint插件，右键菜单选Analyze with SonarLint\n - 5、安装Sequence Diagram 插件，可以从controller层点右键查看调用路径\n- 中等：1、根据模块业务查看代码逻辑，确认代码正确2、根据代码确认完成功能开发\n- 复杂：查看代码符合的设计原则，是否符合整体架构逻辑【原则是复杂的问题简单化】设计原则：单一职责、开闭、接口隔离、里氏替换、迪米特、依赖倒置\n\n\n### Java API Design Best Practices\n- https://static001.geekbang.org/con/33/pdf/3939125782/file/1%E3%80%81jgiles+-+API+Best+Practices+-+v2+-+qcon.pdf\n- https://java.jonathangiles.net/\n- Jonathan Giles\n- API design theory | practical advice\n- effective java 3rd edition - joshua bloch\n- API - 开发者 - 达成目标\n- 抽象层面 - 更好的抽象\n- API的使用者 ｜ 使用者的目的\n- API Characteristics\n - Understandable\n  - 使用者能看了能马上知道这个接口干什么的, 接口文档也是必须的\n  - 面向对象的设计\n  - entry points\n - Consistency\n  - null 的处理要严格符合文档里面写的\n- restrained\n- evolvable\n- documentation\n- there is no magical process to api Design\n- api design is an art , and like art, becomes easier with practice\n\n\n### APIs are the thing that gets us to the thing\n- \"Computers aren't the thing. They’re the thing that gets you to the thing.\"\n -- Joe MacMillan (Halt and Catch Fire)\n- We have always assumed that applications are the thing\n- The real “thing” is delivering solutions through capabilities\n- APIs will always be a thing\n\n\n## 线上项目debug\n- arthas\n```\n2022-05-11 16:52:53.396 ERROR http-nio-8188-exec-26 com.xx.xxx.account.util.JwtUtil (JwtUtil.java:40)-\nio.jsonwebtoken.ExpiredJwtException: JWT expired at 2022-04-30T09:41:22Z. Current time: 2022-05-11T16:52:53Z, a difference of 976291396 milliseconds.  Allowed clock skew: 0 milliseconds.\nat io.jsonwebtoken.impl.DefaultJwtParser.parse(DefaultJwtParser.java:385)\n```\n- http://arthas.gitee.io/\n- https://github.com/alibaba/arthas\n\n\n\n## 安全\n- 紧急漏洞\n涉及应用\nJackson - Jackson-databind 反序列化漏洞(CVE-2021-20190)\nlog4j - Apache Log4j 远程代码执行漏洞(CVE-2021-44228、CVE-2021-45046)\nFastJSON - FastJSON＜=1.2.80 反序列化漏洞\nXStream - XStream 远程代码执行漏洞(CVE-2021-29505)\nSaltstack - SaltStack 未授权访问漏洞(CVE-2021-21996、CVE-2021-22004、CVE-2021-31607)\n\n### binlog\n二进制日志（binnary log）以事件形式记录了对MySQL数据库执行更改的所有操作\n- 二进制日志索引文件 ｜ 二进制日志文件\n- binlog消息分发服务（收敛binlog消息）\n- https://github.com/pingcap/tidb-binlog\n- https://docs.pingcap.com/zh/tidb/dev/tidb-binlog-overview\n- canal 基于 MySQL 数据库binlog增量日志解析，提供增量数据订阅和消费\n\n#### 配置应用配置\n- Run/Debug Configurations - override parameters \n- configuration - environment - program arguments - --eureka.client.serviceUrl.defaultZone=xxxx/eureka/ --eureka.client.register-with-eureka=false\n"},{"title":"maven","url":"/2021/08/30/maven/","content":"\n### 文档指路\n\nhttps://maven.apache.org/\n\n### 概述\n\n“Apache Maven is a software project management and comprehension tool. Based on the concept of a project object model (POM), Maven can manage a project's build, reporting and documentation from a central piece of information.”\n\n### 构建工具，依赖管理\nmaven排在Java生态的第一，Gradle用于Android\n#### 基于XML格式的文件描述依赖配置\n- https://maven.apache.org/pom.html#What_is_the_POM\n- POM（Project Object Model）\n- pom.xml \n  - groupId,artifactId,version - 坐标\n  - type - 类型\n  - scope - 范围\n  - optional - 依赖是否可选\n  - exclusions - 排除传递性依赖\n\n#### 依赖仲裁原则\n- 最短路径优先\n- 第一声明有限\n\n\n### Best Practice\n- 减少重复配置的代码\n- 减少不确定因素\n\n### 问题解决\n- 确认系统，确认Java，Maven版本\n- 确认本地依赖的缓存\n- 检查完整依赖树\n\n### 推荐插件\n- http://maven.apache.org/enforcer/maven-enforcer-plugin/\n### 关于私仓\n- 可见这篇文章（也是基于nexus构建的）：http://www.imaginingme.cn/2020/04/13/npm%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%E7%9A%84%E6%90%AD%E5%BB%BA%E5%8F%8A%E5%8F%91%E7%89%88%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95/"},{"title":"PAI-DSW","url":"/2021/08/30/PAI-DSW/","content":"\n> 阿里云的 DSW（PAI-DSW（Data Science Workshop）是 PAI 推出的在线深度学习开发平台）\n\n### 文档指路\n\nhttps://help.aliyun.com/document_detail/102789.html#section-o64-ypv-8ow\n\n```\n本文为您介绍PAI-DSW的相关问题。\n\n什么是PAI-DSW？\nPAI-DSW实例如何挂载和使用自己的NAS文件系统？\n如何在PAI-DSW中使用第三方库\n运行机器学习代码时，为什么页面放置一段时间后提示重新登录？\n使用ECS搭建FTP上传下载文件到NAS，执行挂载（mount）命令报错mount:wrong fs type,bad option,bad superlock\n如何使用PAI-DSW读取OSS数据？\n为什么安装的第三方包没有生效？\n如何部署PAI-DSW生成的模型？\nPAI-DSW如何收费？\n如何查看PAI-DSW账单？\n```\n\n目录如上\n\n### NAS 挂载问题\n\n#### 阿里云文档\n\n```\n\nPAI-DSW实例如何挂载和使用自己的NAS文件系统？\nPAI-DSW实例默认提供的系统盘为临时存储，在停止或删除实例后，系统会清空数据。如果您需要永久化存储数据，则需要挂载自己NAS。您所有的NAS文件均存储在/nas目录，可以通过PAI-DSW Terminal进入该目录查看并使用文件。\n\n新版的PAI-DSW仅支持在创建实例时，挂载自己的NAS，详情请参见创建实例。实例一旦创建，则无法编辑实例信息或挂载NAS。\n```\n\n#### 具体操作\n\n对 ECS 实例进行配置&&挂载 NFS\n\n```\n# 安装NFS客户端\nsudo apt-get update\nsudo apt-get install nfs-common\n\n# 修改NFS请求数量限制\nsudo echo \"options sunrpc tcp_slot_table_entries=128\" >> /etc/modprobe.d/sunrpc.conf\nsudo echo \"options sunrpc tcp_max_slot_table_entries=128\" >> /etc/modprobe.d/sunrpc.conf\n\n# 执行挂载NFS的命令\nsudo mount -t nfs -o vers=3,nolock,proto=tcp,rsize=1048576,wsize=1048576,hard,timeo=600,retrans=2,noresvport 挂载点地址\n\n# 验证是否挂载成功\ndf -h | grep aliyun\n```\n"},{"title":"flutter-sound-null-safety","url":"/2021/08/24/flutter-sound-null-safety/","content":"\n### 英文贴士\n\nsound 这里指完全的，彻底的； （adj,只能用在名词前）\n\n### sound null safety 迁移\n\n- dart pub get // 更新 pub\n- dart pub outdated --mode=null-safety // 展示没有升级到 null-safety 的依赖\n- 修改依赖库的版本\n- dart pub get // 更新 pub\n\n#### 自动迁移\n\n- dart migrate --apply-changes\n\n#### 手动迁移\n\n- dart migrate // 按提示操作\n"},{"title":"dart-Isolate","url":"/2021/08/23/dart-Isolate/","content":"\n### 文档指南\n- https://dart.dev/guides/language/language-tour#isolates\n```\n# 下面是文档里面给出的深入阅读链接，基本上看完对原理和应用场景就比较清晰了\nDart asynchronous programming: Isolates and event loops\n(https://medium.com/dartlang/dart-asynchronous-programming-isolates-and-event-loops-bffc3e296a6a)\ndart:isolate API reference, including Isolate.spawn() and TransferableTypedData\n(https://api.dart.dev/stable/2.14.2/dart-isolate/dart-isolate-library.html)\nBackground parsing cookbook on the Flutter site\n(https://flutter.dev/docs/cookbook/networking/background-parsing)\nIsolate sample app\n(https://github.com/flutter/samples/tree/master/isolate_example)\n```\n\n\n### 概述\nDART：\n- 基于“单线程”的\n- 提供了 Isolate 这样的“多线程”能力\n- 并发 Isolate 处理 CPU 密集型任务\n- 基于消息机制通知主 Isolate 运行结果\n\n### 使用场景\n- compute函数"},{"title":"由flutter-bloc聊起","url":"/2021/08/23/由flutter-bloc聊起/","content":"\n## 资料指路\n\n- https://www.didierboelens.com/2018/08/reactive-programming-streams-bloc/ （Introduction to the notions of Streams, Bloc and Reactive Programming. Theory and practical examples.）\n- https://www.didierboelens.com/2018/12/reactive-programming-streams-bloc-practical-use-cases/\n- https://medium.com/flutter-community/flutter-bloc-package-295b53e95c5c\n- https://bloclibrary.dev/\n- https://bloclibrary.dev/#/zh-cn/coreconcepts\n\n## 其它\n\n- fish-redux\n"},{"title":"flutter-项目分析-GitJournal","url":"/2021/08/20/flutter-项目分析-GitJournal/","content":"\n## 背景\n\n### 项目地址\n\n### packages\n\n#### time 2.0.0\n\n- https://pub.dev/packages/time\n\n## 功能点分析\n\n#### 用户权限申请\n\n- https://pub.dev/packages/permission_handler\n\n```\npermission_handler:\n    dependency: \"direct main\"\n    description:\n      name: permission_handler\n      url: \"https://pub.dartlang.org\"\n    source: hosted\n    version: \"6.1.1\"\n  permission_handler_platform_interface:\n    dependency: transitive\n    description:\n      name: permission_handler_platform_interface\n      url: \"https://pub.dartlang.org\"\n    source: hosted\n    version: \"3.1.1\"\n```\n\n```\n<!-- android/app/src/main/AndroidManifest.xml -->\n    <uses-permission android:name=\"android.permission.INTERNET\"/>\n    <uses-permission android:name=\"com.android.vending.BILLING\" />\n    <uses-feature android:name=\"android.hardware.camera\" android:required=\"false\" />\n\n    <uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" />\n    <uses-permission android:name=\"android.permission.READ_INTERNAL_STORAGE\" />\n    <uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\"/>\n```\n\n#### 引导页\n\n## 问题处理\n### context.read in build()\n- https://stackoverflow.com/questions/62432759/why-cant-i-use-context-read-in-build-but-i-can-use-provider-of-with-listen"},{"title":"material-ui","url":"/2021/08/17/material-ui/","content":"\n> 团队要基于 flutter 做 Android 端的产品，研究了下 material-ui；\n\n### history\n\n- Andy Rubin - Android\n- ROM 系统（MIUI ｜ FLyme | Smartisan | 联想乐 OS ｜ 华为 ROM）\n- 尺寸问题 - PS-cutterman sketch|XD->按尺寸调整\n- Material Design 规范（类似 APPLE HIG）\n- 2014-googleI/O(https://www.youtube.com/watch?v=97SWYiRtF0Y)\n\n### 文档指南\n\nvscode 可以配置好对应语言使用的拓展，这样可以书包放上去就能看到提示；\nhttps://material.io/design/color/the-color-system.html#color-usage-and-palettes\n\nhttps://material-io.cn/resources/get-started#design\n\n#### 从设计角度来看的一篇介绍文章\n\nhttps://www.uisdc.com/material-design-knowledge\n\n#### Web\n\nhttps://github.com/muicss/mui\nhttps://github.com/Dogfalo/materialize\nhttps://getmdl.io/\nhttps://en.wikipedia.org/wiki/Comparison_of_Material_Design_implementations\n\n#### React:\n\nhttps://material-ui.com/zh/\n\n#### Flutter\n\n- https://flutter.cn/docs/development/ui/widgets/material\n- Flutter 提供了遵循 Material Design 规范的 ThemeData\n- https://api.flutter.dev/flutter/material/ThemeData/ThemeData.html (themedata 相关文档)\n\n```\n\n// 全局 ——————\nMaterialApp(\n  title: 'Flutter Demo',\n  theme: ThemeData(\n      brightness: Brightness.dark, //明暗\n      accentColor: Colors.black, //Widget前景色\n      primaryColor: Colors.blue, //主色调\n      iconTheme:IconThemeData(color: Colors.cyan),// icon主题色\n      textTheme: TextTheme(body1: TextStyle(color: Colors.white)) // 文本颜色\n  ),\n  home: MyHomePage(title: 'Flutter Demo Home Page'),\n);\n// 局部覆盖 ——————\n\n// 新建\nTheme(\n    data: ThemeData(iconTheme: IconThemeData(color: Colors.blue)),\n    child: Icon(Icons.favorite)\n);\n\n// 继承\nTheme(\n    data: Theme.of(context).copyWith(iconTheme: IconThemeData(color: Colors.blue)),\n    child: Icon(Icons.feedback)\n);\n\n// 复用\nTheme.of(context)\n\n// 区分平台\n初始化时候在theme里面做个判断，分别复制不同主题的配置（defaultTargetPlatform）\n\n```\n\n### 相关阅读推荐\n\n#### 设计相关\n\n- https://blog.nicolesaidy.com/7-steps-to-become-a-ui-ux-designer-8beed7639a95\n- https://en.wikipedia.org/wiki/Twelve_basic_principles_of_animation\n- https://design.facebook.com/\n- https://www.ibm.com/design/language/\n- https://bradfrost.com/blog/post/atomic-web-design/\n- https://uxplanet.org/the-psychology-principles-every-ui-ux-designer-needs-to-know-24116fd65778\n- https://medium.com/thinking-design/the-evolution-of-ui-ux-designers-into-product-designers-623e4e7eaab3\n\n#### 书本推荐\n\n- 简约至上\n- dont't make me think\n\n#### 好用的工具\n\n- http://palette.site/ （Chrome 插件，可以抓取网站颜色，生成 palettes）\n\n#### 产品案例\n\n- Primer - 卡片\n- Fabulous\n"},{"title":"图标生成","url":"/2021/08/16/图标生成/","content":"\n### electron\n\n```\n# testimg.png 为原始文件\n# 新建文件夹 icons.iconset\n# man sips | man iconutil\n\nsips -z 16 16 testimg.png --out icons.iconset/testimg_16x16.png\n\nsips -z 32 32 testimg.png --out icons.iconset/testimg_16x16@2x.png\n\nsips -z 32 32 testimg.png --out icons.iconset/testimg_32x32.png\n\nsips -z 64 64 testimg.png --out icons.iconset/testimg_32x32@2x.png\n\nsips -z 64 64 testimg.png --out icons.iconset/testimg_64x64.png\n\nsips -z 128 128 testimg.png --out icons.iconset/testimg_64x64@2x.png\n\nsips -z 128 128 testimg.png --out icons.iconset/testimg_128x128.png\n\nsips -z 256 256 testimg.png --out icons.iconset/testimg_128x128@2x.png\n\nsips -z 256 256 testimg.png --out icons.iconset/testimg_256x256.png\n\nsips -z 512 512 testimg.png --out icons.iconset/testimg_256x256@2x.png\n\nsips -z 512 512 testimg.png --out icons.iconset/testimg_512x512.png\n\nsips -z 1024 1024 testimg.png --out icons.iconset/testimg_512x512@2x.png\n\n\niconutil -c icns icons.iconset -o testimg.icns\n\n```\n\n### Flutter\n\nhttps://flutter.cn/docs/development/ui/assets-and-images\n\n- 可以借助 sips 进行生成，编写个生成脚本\n- 然后按约定规则放置到对应位置\n- ios 和安卓的规则不完全一样，但是思路是一样的，生成不同尺寸的图片，按照约定的命名规范命名，放置到对应的文件夹\n- assets 基于像素密度结构\n\n> Flutter 应用，最终以原生工程的方式打包运行在 Android 和 iOS 平台上，so, Flutter 启动时依赖的是原生 Android &&iOS 的运行环境；在引擎初始化之前的（如启动图、App 图标、App 名字）需要在原生工程中实现；\n\n#### IOS\n\n- 图标：ios/Runner/Assets.xcassets/AppIcon.appiconset\n- 启动图：ios/Runner/Assets.xcassets/LaunchImage.imageset\n\n#### Android\n\n- app/src/main/res/mipmap\n- res/drawable + 分辨率\n- res/layout 布局 ｜ res/values 资源描述 | assets 原始文件\n- drawable\n  可以借助 sips 进行生成，编写个生成脚本\n  最好是借助 UI 的专业工具进行生成\n- 启动图：app/src/main/res/drawable/lauch_background.xml\n"},{"title":"语法分析","url":"/2021/08/15/语法分析/","content":"## 计算机语言实现\n### 编译技术\n### 计算机语言的特性\n类型系统 ｜ 面向对象 ｜ 函数式编程\n\n### 运行时技术\n虚拟机技术 ｜ 内存管理\n\n### JS的实现\nQuickJS: https://github.com/quickjs-zh/QuickJS\nV8 - Chrome | node.js\nTraceMonkey - FireFox\n\n### 编译器前端\n- 包括：词法分析｜语法分析｜语义分析\n- 生成方式：手写｜工具生成\n- 最佳实践：LL算法 ｜ 运算符优先级算法\n\n### 编译器后端\n- LLVM（Rust，Julia）- 问题：资源占用，即时编译速度\n- JVM，Android的运行时，V8 ，自己实现的后端\n- 优化算法-基于图的IR\n- 生成汇编代码\n\n### 运行时机制\nAST解释器\nAST编译成字节码\n字节码在虚拟机上运行\n\n### 高级特性的实现\n协程 ｜ JIT ｜ 类型体系的实现 ｜ 运行时的多态 ｜ 高阶函数 ｜ 闭包\n\n- 字节码带来的跨平台特性\n\n\n#### Parse\n- 解析 - 读入程序，形成一个计算机可以理解的数据结构的过程\n- parser - 解析器\n\n\n### AST\n- 抽象语法树 (Abstract Syntax Tree)，是源代码语法结构的一种抽象表示。它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构\n\n#### 节点类型\n- literal\n- Identifier\n- Statement\n- Declaration\n- Expression\n- Import \n- Export\n\n#### 节点属性\n- pos\n- end\n- kind（SyntaxKind  - https://github.com/microsoft/TypeScript/blob/v4.7.4/lib/typescript.d.ts#L105\n）\n\n#### 可视化工具\n- https://ts-ast-viewer.com/#\n- https://astexplorer.net/#/gist/0beb6bb16461e59baf96be02c82df9a0/c92e363f8f037df97a2434d71a5e28c55c4cc1e4\n- https://astexplorer.net/\n#### 用法\n- 代码编译\n\n\n- 代码加工\n\n\n\n- 代码分析"},{"title":"词法分析","url":"/2021/08/15/词法分析/","content":"## lexical analysis\n\n### wikipedia\n> 词法分析（英语：lexical analysis）是计算机科学中将字符序列转换为标记（token）序列的过程。进行词法分析的程序或者函数叫作词法分析器（lexical analyzer，简称lexer），也叫扫描器（scanner）。词法分析器一般以函数的形式存在，供语法分析器调用。\n\n#### wiki地址\nhttps://zh.wikipedia.org/wiki/%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90\n\n## Tips\n### 结构\n词法分析结果 => 列表\n语法分析结果 => AST树\n\n### 任务\n（从字符串转成token串）\n\n- 关键字 ｜ 标识符 ｜ 分隔符 ｜ 运算符 ｜ 字面量（Literal）｜ 注释（不形成token） ｜ 空白字符 \n- JS - \"0x\"-16 \"0\"-8 \"0b\"-2\n- 所以不是简单规则能解决，需要用系统性的解决方法\n\n### 词法规则\n#### 词法规则-formal grammar(正则文法)-上下文无关文法的子集\n#### 语法规则-context-free grammer-CFG\n \n### 用程序实现词法分析\n\n#### LL算法\n- First|Follow 集合\n- 避免回溯 -> 实现性能上的提升"},{"title":"chromium","url":"/2021/08/13/chromium/","content":"\nhttps://chromium.googlesource.com/chromium/src/+/refs/heads/main/docs/mac_build_instructions.md#Get-the-code\n\n#### history\n\nhttps://github.com/chromium/chromium/blob/d7da0240cae77824d1eda25745c4022757499131/chrome/browser/extensions/api/history/history_api.h\n\nhttps://github.com/chromium/chromium/blob/d7da0240ca/components/history/core/browser/browsing_history_service.cc\n\n- Chromium - 多进程架构\n- ipc\n## Browser - 1\n\n\n## Renderer     - n\n\n\n\n\n#### electron\nnode.js和chromiums整合\n- node.js的事件循环基于libuv\n- chromium的事件循环基于message bump\n- chromium集成到node.js：用libuv实现messagebump(nw)\n- nodejs集成到Chromium：electron - shelley Vohr - JSHeroes2019\n```\nA event happeds in node   |a   Electron Main Thread   |b   Chromium MessageLoop\n  |a    Electron's main thread is notified via the same fd as libuv\n  |b    Electron tells Chromium's MessageLopp to clear libuv events\n```\n\n- electron-internals-node-integration(electronjs.org)\n- Electron: The Event Loop Tightrope - Shelley Vohr | JSHeroes 2019 - ytb - JS/Heroes\n- shell/common/node_bindings.cc\n\n### bugs\n- https://bugs.chromium.org/p/chromium/issues/list"},{"title":"zookeeper","url":"/2021/08/13/zookeeper/","content":"\n- 经典概念 + 实践 => 逐渐加深的理解\n- 理解经典的API，而不是层出不穷的Framework\n- source code - reading - understanding - 聚焦眼前的问题 - 带着问题阅读\n- 记录 - 输出 - 加深理解\n\n### 文档\n\nhttps://zookeeper.apache.org/doc/current/zookeeperOver.html\n\n### 论文\n\nhttps://www.usenix.org/legacy/event/atc10/tech/full_papers/Hunt.pdf\nhttps://marcoserafini.github.io/papers/zab.pdf\n\n### consul 架构\n\nhttps://www.consul.io/docs/architecture\n\n#### Prepared Query\n\nhttps://www.consul.io/api-docs/query\n\n#### health service\n\nhttps://learn.hashicorp.com/tutorials/consul/service-registration-health-checks\n\n### etcd\n\nhttps://github.com/etcd-io/etcd/tree/v3.4.9/clientv3/concurrency\n"},{"title":"纯函数","url":"/2021/08/13/纯函数/"},{"title":"flutter-webview","url":"/2021/08/09/flutter-webview/","content":"\n### debugging\n\nhttps://inappwebview.dev/docs/debugging-webviews/\n\n### packages\n\nhttps://pub.dev/packages/webview_flutter\n\n#### Android\n\n- on Android the WebView widget is backed by a WebView.\n- https://developer.android.com/reference/android/webkit/WebView\n- https://flutter.dev/docs/development/platform-integration/platform-views\n\n#### IOS\n\n- https://developer.apple.com/documentation/webkit/wkwebview\n\n### Tips\n#### HTTP\n- iOS默认会白屏\n- android9.0以上版本也会限制访问\n- info.list | AndroidManifest.xml\n\n#### mode\n- When building your application in release mode, Flutter apps can be compiled for armeabi-v7a (ARM 32-bit), arm64-v8a (ARM 64-bit), and x86-64 (x86 64-bit). Flutter does not currently support building for x86 Android.\n- https://flutter.dev/docs/deployment/android#what-are-the-supported-target-architectures\n\n\n\n### h5对接第三方，webview版本低会导致的问题\n#### cases\n- padStart 支持\n- \n\n\n### WKWebView 请求拦截探索与实践\n\n- https://juejin.cn/post/6922625242796032007"},{"title":"vue-router源码探究","url":"/2021/08/09/vue-router源码探究/","content":"\n## 路由管理\n\n- 前端应用中重要的机制-页面根据 URL 的变化进行切换\n- _Uniform Resource Locator_\n- 页面+状态（定位）\n- 根据状态渲染不同的组件\n\n### 核心逻辑简单实现\n\n```\n// 基于hash实现\nconst MyRouter = ({ children }) => {\n  const routes = _.keyBy(\n    children.map((c) => c.props),\n    \"path\",\n  );\n  const [hash] = useHash();\n  const Page = routes[hash.replace(\"#\", \"\")]?.component;\n  return Page ? <Page /> : \"Not found.\";\n};\n\n\nconst Route = () => null;\n```\n\n```\n\n\n    <div className=\"sample-pages\">\n      <div className=\"sider\">\n        <a href=\"#page1\">Page 1</a>\n        <a href=\"#page2\">Page 2</a>\n        <a href=\"#page3\">Page 3</a>\n        <a href=\"#page4\">Page 4</a>\n      </div>\n      <div className=\"exp-15-page-container\">\n        <MyRouter>\n          <Route path=\"page1\" component={Page1} />\n          <Route path=\"page2\" component={Page2} />\n          <Route path=\"page3\" component={Page3} />\n          <Route path=\"page4\" component={Page4} />\n        </MyRouter>\n      </div>\n    </>\n\n\n\n```\n\n## 源码探究\n\n### 具体配置执行了什么\n\n- 拉下代码看下\n- https://github.com/vuejs/vue-router.git\n\n#### base\n\n```\nbase\n类型: string\n\n默认值: \"/\"\n\n应用的基路径。例如，如果整个单页应用服务在 /app/ 下，然后 base 就应该设为 \"/app/\"。\n```\n\n```\n//   options: RouterOptions | options.base\nexport interface RouterOptions {\n  routes?: RouteConfig[]\n  mode?: RouterMode\n  fallback?: boolean\n  base?: string\n  linkActiveClass?: string\n  linkExactActiveClass?: string\n  parseQuery?: (query: string) => Object\n  stringifyQuery?: (query: Object) => string\n  scrollBehavior?: (\n    to: Route,\n    from: Route,\n    savedPosition: Position | void\n  ) => PositionResult | Promise<PositionResult> | undefined | null\n}\nexport default class VueRouter {\n  static install: () => void\n  static version: string\n  static isNavigationFailure: Function\n  static NavigationFailureType: any\n  static START_LOCATION: Route\n\n  app: any\n  apps: Array<any>\n  ready: boolean\n  readyCbs: Array<Function>\n  options: RouterOptions\n  mode: string\n  history: HashHistory | HTML5History | AbstractHistory\n  matcher: Matcher\n  fallback: boolean\n  beforeHooks: Array<?NavigationGuard>\n  resolveHooks: Array<?NavigationGuard>\n  afterHooks: Array<?AfterNavigationHook>\n\n  constructor (options: RouterOptions = {}) {\n    this.app = null\n    this.apps = []\n    this.options = options\n    this.beforeHooks = []\n    this.resolveHooks = []\n    this.afterHooks = []\n    this.matcher = createMatcher(options.routes || [], this)\n\n    let mode = options.mode || 'hash'\n    this.fallback =\n      mode === 'history' && !supportsPushState && options.fallback !== false\n    if (this.fallback) {\n      mode = 'hash'\n    }\n    if (!inBrowser) {\n      mode = 'abstract'\n    }\n    this.mode = mode\n\n    switch (mode) {\n      case 'history':\n        this.history = new HTML5History(this, options.base)\n        break\n      case 'hash':\n        this.history = new HashHistory(this, options.base, this.fallback)\n        break\n      case 'abstract':\n        this.history = new AbstractHistory(this, options.base)\n        break\n      default:\n        if (process.env.NODE_ENV !== 'production') {\n          assert(false, `invalid mode: ${mode}`)\n        }\n    }\n  }\n\n  match (raw: RawLocation, current?: Route, redirectedFrom?: Location): Route {\n    return this.matcher.match(raw, current, redirectedFrom)\n  }\n\n  get currentRoute (): ?Route {\n    return this.history && this.history.current\n  }\n\n  init (app: any /* Vue component instance */) {\n    process.env.NODE_ENV !== 'production' &&\n      assert(\n        install.installed,\n        `not installed. Make sure to call \\`Vue.use(VueRouter)\\` ` +\n          `before creating root instance.`\n      )\n\n    this.apps.push(app)\n\n    // set up app destroyed handler\n    // https://github.com/vuejs/vue-router/issues/2639\n    app.$once('hook:destroyed', () => {\n      // clean out app from this.apps array once destroyed\n      const index = this.apps.indexOf(app)\n      if (index > -1) this.apps.splice(index, 1)\n      // ensure we still have a main app or null if no apps\n      // we do not release the router so it can be reused\n      if (this.app === app) this.app = this.apps[0] || null\n\n      if (!this.app) this.history.teardown()\n    })\n\n    // main app previously initialized\n    // return as we don't need to set up new history listener\n    if (this.app) {\n      return\n    }\n\n    this.app = app\n\n    const history = this.history\n\n    if (history instanceof HTML5History || history instanceof HashHistory) {\n      const handleInitialScroll = routeOrError => {\n        const from = history.current\n        const expectScroll = this.options.scrollBehavior\n        const supportsScroll = supportsPushState && expectScroll\n\n        if (supportsScroll && 'fullPath' in routeOrError) {\n          handleScroll(this, routeOrError, from, false)\n        }\n      }\n      const setupListeners = routeOrError => {\n        history.setupListeners()\n        handleInitialScroll(routeOrError)\n      }\n      history.transitionTo(\n        history.getCurrentLocation(),\n        setupListeners,\n        setupListeners\n      )\n    }\n\n    history.listen(route => {\n      this.apps.forEach(app => {\n        app._route = route\n      })\n    })\n  }\n\n  beforeEach (fn: Function): Function {\n    return registerHook(this.beforeHooks, fn)\n  }\n\n  beforeResolve (fn: Function): Function {\n    return registerHook(this.resolveHooks, fn)\n  }\n\n  afterEach (fn: Function): Function {\n    return registerHook(this.afterHooks, fn)\n  }\n\n  onReady (cb: Function, errorCb?: Function) {\n    this.history.onReady(cb, errorCb)\n  }\n\n  onError (errorCb: Function) {\n    this.history.onError(errorCb)\n  }\n\n  push (location: RawLocation, onComplete?: Function, onAbort?: Function) {\n    // $flow-disable-line\n    if (!onComplete && !onAbort && typeof Promise !== 'undefined') {\n      return new Promise((resolve, reject) => {\n        this.history.push(location, resolve, reject)\n      })\n    } else {\n      this.history.push(location, onComplete, onAbort)\n    }\n  }\n\n  replace (location: RawLocation, onComplete?: Function, onAbort?: Function) {\n    // $flow-disable-line\n    if (!onComplete && !onAbort && typeof Promise !== 'undefined') {\n      return new Promise((resolve, reject) => {\n        this.history.replace(location, resolve, reject)\n      })\n    } else {\n      this.history.replace(location, onComplete, onAbort)\n    }\n  }\n\n  go (n: number) {\n    this.history.go(n)\n  }\n\n  back () {\n    this.go(-1)\n  }\n\n  forward () {\n    this.go(1)\n  }\n\n  getMatchedComponents (to?: RawLocation | Route): Array<any> {\n    const route: any = to\n      ? to.matched\n        ? to\n        : this.resolve(to).route\n      : this.currentRoute\n    if (!route) {\n      return []\n    }\n    return [].concat.apply(\n      [],\n      route.matched.map(m => {\n        return Object.keys(m.components).map(key => {\n          return m.components[key]\n        })\n      })\n    )\n  }\n\n  resolve (\n    to: RawLocation,\n    current?: Route,\n    append?: boolean\n  ): {\n    location: Location,\n    route: Route,\n    href: string,\n    // for backwards compat\n    normalizedTo: Location,\n    resolved: Route\n  } {\n    current = current || this.history.current\n    const location = normalizeLocation(to, current, append, this)\n    const route = this.match(location, current)\n    const fullPath = route.redirectedFrom || route.fullPath\n    const base = this.history.base\n    const href = createHref(base, fullPath, this.mode)\n    return {\n      location,\n      route,\n      href,\n      // for backwards compat\n      normalizedTo: location,\n      resolved: route\n    }\n  }\n\n  getRoutes () {\n    return this.matcher.getRoutes()\n  }\n\n  addRoute (parentOrRoute: string | RouteConfig, route?: RouteConfig) {\n    this.matcher.addRoute(parentOrRoute, route)\n    if (this.history.current !== START) {\n      this.history.transitionTo(this.history.getCurrentLocation())\n    }\n  }\n\n  addRoutes (routes: Array<RouteConfig>) {\n    if (process.env.NODE_ENV !== 'production') {\n      warn(false, 'router.addRoutes() is deprecated and has been removed in Vue Router 4. Use router.addRoute() instead.')\n    }\n    this.matcher.addRoutes(routes)\n    if (this.history.current !== START) {\n      this.history.transitionTo(this.history.getCurrentLocation())\n    }\n  }\n}\n\n```\n#### pushState\n```\nfunction pushState (url, replace) {\n  saveScrollPosition();\n  // try...catch the pushState call to get around Safari\n  // DOM Exception 18 where it limits to 100 pushState calls\n  var history = window.history;\n  try {\n    if (replace) {\n      history.replaceState({ key: _key }, '', url);\n    } else {\n      _key = genKey();\n      history.pushState({ key: _key }, '', url);\n    }\n  } catch (e) {\n    window.location[replace ? 'replace' : 'assign'](url);\n  }\n}\n\nfunction replaceState (url) {\n  pushState(url, true);\n}\n```\n\n## 其他\n\n### react router\n\n- https://reactrouter.com/web/guides/quick-start\n- 支持多端（web browser, react native）\n- react-router-dom\n- BrowserRouter | Link | Route | Switch\n```\nThe react-router package is the heart of React Router and provides all the core functionality for both react-router-dom and react-router-native.\n\nIf you're using React Router, you should never import anything directly from the react-router package, but you should have everything you need in either react-router-dom or react-router-native. Both of those packages re-export everything from react-router.\n\nIf you'd like to extend React Router and you know what you're doing, you should add react-router as a peer dependency, not a regular dependency in your package.\n\nreact-router包是React Router的核心，为react-router-dom和react-router-native提供所有核心功能。\n\n如果你正在使用 React Router，你不应该直接从 react-router 包中导入任何东西，但你应该在 react-router-dom 或 react-router-native 中拥有你需要的一切。这两个包都从 react-router 重新导出了所有东西。\n\n如果你想扩展 React Router，并且你知道你在做什么，你应该把 react-router 作为peer dependency，而不是在你的包中作为regular dependency。\n```\n- react-router-config\n```\nimport { renderRoutes } from 'react-router-config';//renderRoutes 读取路由配置转化为 Route 标签\nrenderRoutes 这个方法只渲染一层路由\n```\n### 应用场景\n\n#### 嵌套路由\n\n#### URL 中保存页面状态\n\n#### 权限控制\n\n#### window.history\n- https://html.spec.whatwg.org/multipage/history.html\n- browsing session\n```\nA browsing session is …. See whatwg/html issue #4782 and whatwg/html issue #5350 for defining browsing session. It is roughly analogous to a top-level browsing context except that it cannot be replaced due to a `Cross-Origin-Opener-Policy` header or navigation.\n\nA top-level browsing context has an associated browsing session which is a browsing session.\n\nThe browsing session of an environment settings object environment is the result of running these steps:\n\nAssert: environment has a responsible document.\n\nReturn environment's responsible document's browsing context's top-level browsing context's browsing session.\n```\n\n### location.pathname\n\n\n### popstate"},{"title":"yapi","url":"/2021/08/08/yapi/","content":"\n- yapi\n\n### 1.9.2 处理沙盒问题不当\n\n- https://github.com/YMFE/yapi/issues/2292\n- https://github.com/YMFE/yapi/compare/v1.9.2...v1.9.3\n"},{"title":"linux系统命令及shell脚本","url":"/2021/08/02/linux系统命令及shell脚本/","content":"> 一切皆文件\n\n> 只是为了好玩\n\n- 服务端｜客户端 => 对操作系统的需求不一样\n#### 版本\n- 内核版本 www.kernel.org (次版本号奇数-开发版，偶数-稳定版)（主.次.末）\n- 发行版本 redhat enterprise linux - 运维收费|  fedora - 社区免费 | centos - community enterprise operating system - 结合前两者 ｜ debian - 界面 ｜ ubuntu(基于debian) - 界面\n- /etc/redhat-release\n\n#### virtualbox - SDN的时候可太熟了\n- oracle\n- 存储，选择虚拟光盘文件\n- centos - 软件选择 - gnome 桌面\n\n#### centos\n- 7.6.1810 (版本7，6次升级，1810-18年10月发布)\n\n#### root\n- root 账户用于管理系统\n- \n\n#### mkpaswd\n如果找不到这个命令，可能是没有安装expect包（yum -y install expect）"},{"title":"mysql8从入门到精通-精读","url":"/2021/08/02/mysql8从入门到精通-精读/","content":"nodejs\nServer version: 8.0.28 Homebrew\n```\nselect User,plugin from user;\n+------------------+-----------------------+\n| User             | plugin                |\n+------------------+-----------------------+\n| mysql.infoschema | caching_sha2_password |\n| mysql.session    | caching_sha2_password |\n| mysql.sys        | caching_sha2_password |\n| root             | caching_sha2_password |\n+------------------+-----------------------+\n4 rows in set (0.00 sec)\n```\n`2022-12-06 17:57:47,581 ERROR 35487 [-/127.0.0.1/-/0ms GET /] nodejs.ER_NOT_SUPPORTED_AUTH_MODEError: ER_NOT_SUPPORTED_AUTH_MODE: Client does not support authentication protocol requested by server; consider upgrading MySQL client`\n\n1.nodejs\negg-mysql -> ali-rds -> mysql(https://www.npmjs.com/package/mysql)\n\"ali-rds\": {\n      \"version\": \"3.4.0\",\n      \"resolved\": \"https://registry.npm.taobao.org/ali-rds/download/ali-rds-3.4.0.tgz\",\n      \"integrity\": \"sha1-6rpDN4DaMtaAT9mle917Yv2J/iU=\",\n      \"requires\": {\n        \"co-wrap-all\": \"^1.0.0\",\n        \"debug\": \"^2.2.0\",\n        \"mysql\": \"^2.13.0\",\n        \"pify\": \"^2.3.0\"\n      },\nmysql:\nPLUGIN_AUTH - Uses the plugin authentication mechanism when connecting to the MySQL server. This feature is not currently supported by the Node.js implementation so cannot be turned on. (Default off)\n\n`ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY 'mypwd';`\n```\nmysql> select User,plugin from user;\n+------------------+-----------------------+\n| User             | plugin                |\n+------------------+-----------------------+\n| mysql.infoschema | caching_sha2_password |\n| mysql.session    | caching_sha2_password |\n| mysql.sys        | caching_sha2_password |\n| root             | mysql_native_password |\n+------------------+-----------------------+\n4 rows in set (0.00 sec)\n```\n\nflush privileges; 还是 重启 mysql 服务"},{"title":"树莓派-nodejs","url":"/2021/07/27/树莓派-nodejs/","content":"\n> github指路：https://github.com/node-red/node-red ， 这是：Low-code programming for event-driven applications.\n\n### 快速开始\n\n#### 说明\nNode-RED is a programming tool for wiring together hardware devices, APIs and online services in new and interesting ways.\n\nIt provides a browser-based editor that makes it easy to wire together flows using the wide range of nodes in the palette that can be deployed to its runtime in a single-click.\n\n硬件+APIs+在线服务\n提供了基于浏览器的编辑器，可以将palette里面的节点连起来，一键部署\n#### 文档指路\n- run locally\n- on a device\n- in the cloud\n\n> https://nodered.org/docs/getting-started/local\n```\nsudo npm install -g --unsafe-perm node-red\nnode-red\nOpen http://localhost:1880\n```\n"},{"title":"Redis源码","url":"/2021/07/27/Redis源码/","content":"#### C语言 - 学习素材\n- 单测\n- 命名非常规范\n#### 设计与实现\n- 单机键值数据库\n- 分布式系统\n\n#### 代码阅读\n- 整体上掌握结构\n- 要有目标牵引和原理支撑\n- 先主线逻辑再分支细节\n\n## 整体架构\n### Redis\n#### deps\n- 可独立于src目录下的功能源码进行编译\n#### src\n- C语言风格，不同模块间不再设置目录分隔，而是通过头文件包含来相互调用\n#### tests\n> Tcl语言编写\n- 单元测试\n- Redis Cluster功能测试\n- 哨兵功能测试 - sentinel\n- 主从复制功能测试 - integration\n#### utils\n- create-cluster - 创建集群工具\n- hashtable - rehash过程可视化\n- hyperloglog - hyperloglog误差率计算和展示\n- lru - LRU算法效果展示\n\n### 服务器实例\n\n### 数据库数据类型与操作\n\n#### Redis如何优化内存使用\n- 内存分配\n- 内存回收\n- 数据替换\n\n## 可靠性\n- 对数据做持久化保存 -> 内存快找RDB｜AOF日志\n- 主从复制机制 -> 提供故障恢复功能 - replication.c\n\n## 扩展性\n- Redis Cluster\n\n## others\n### dragonfly\n- https://github.com/dragonflydb/dragonfly"},{"title":"ReactHooks","url":"/2021/07/27/ReactHooks/","content":"\n### react组件的演化\n- 组件复用方式\n- （类组件-class）\n- （Mixin）\n- (高阶组件-HOC) - 装饰器模式\n- （Hooks）\n\n## 基础\n### React Router\n- \n```\nIf you're using React Router, you should never import anything directly from the react-router package, but you should have everything you need in either react-router-dom or react-router-native. Both of those packages re-export everything from react-router.\n```\n- web用react-router-dom，react native 用react-router-native\n- connected-react-router - https://www.npmjs.com/package/connected-react-router - A Redux binding for React Router v4 and v5\n- connected-react-router - Synchronize router state with redux store through uni-directional flow (i.e. history -> store -> router -> components).\n- https://reactrouter.com/docs/en/v6/upgrading/v5 - withRouter 的使用变更，可以用hooks代替\n\n\n\n## 项目\n- https://github.com/Netflix/metaflow-ui\n\n\n## ref\n- https://reactjs.org/docs/refs-and-the-dom.html\n- https://reactjs.org/docs/hooks-reference.html#useref\n- https://reactjs.org/docs/hooks-faq.html#how-can-i-measure-a-dom-node\n\n"},{"title":"socketio","url":"/2021/07/26/socketio/"},{"title":"内存管理","url":"/2021/07/23/内存管理/","content":"## 总述\n- C这种底层语言，一般有内存管理的接口，malloc(),free()\n- 现代高级语言一般不直接管理内存\n- 程序使用的两种不同类型的内存： 局部变量，全局变量\n\n### 内存管理\n\n### 栈内存-stack\n- CPU管理栈空间\n- 栈主要用于保存执行当前函数的本地上下文数据\n- 栈的大小受操作系统的限制\n\n\n### 堆内存-heap\n- 应用程序管理堆内存\n- 一般用来保存全局变量和状态或者栈中指针引指向的时机数据\n- 堆内存可以动态的增加，只要服务器上有空闲的内存\n- 大的局部变量也可能保存在堆空间，只在栈中保存指针\n\n\n### 内存泄漏\n- 在堆内存空间中持续增加保存全局变量而没有变量释放出来\n- so, 变量生命周期管理-确保变量在不被使用时被释放\n- 处理方法-退出整个进程，释放内存，用新的进程替换来处理内存泄漏（PHP-FPM）- https://php-fpm.org/\n## JavaScript\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management\n\n### JavaScript高级程序设计（第四版）\n#### 4.4 小结\n<pre>\nJavaScript变量可以保存两种类型的值：原始值和引用值。原始值可能是以下6种原始数据类型之一：Undefined、Null、Boolean、Number、String和Symbol。原始值和引用值有以下特点。\n- 原始值大小固定，因此保存在栈内存上。\n- 引用值是对象，存储在堆内存上。\n任何变量（不管包含的是原始值还是引用值）都存在于某个执行上下文中（也称为作用域）。这个上下文（作用域）决定了变量的生命周期，以及它们可以访问代码的哪些部分。执行上下文可以总结如下。\n- 变量的执行上下文用于确定什么时候释放内存。\nJavaScript是使用垃圾回收的编程语言，开发者不需要操心内存分配和回收。\n</pre>\n#### 10.13 尾调用优化\n<pre>\n尾调用优化的条件就是确定外部栈帧真的没有必要存在了。涉及的条件如下：\n- 代码在严格模式下执行；\n- 外部函数的返回值是对尾调用函数的调用；\n- 尾调用函数返回后不需要执行额外的逻辑；\n- 尾调用函数不是引用外部函数作用域中自由变量的闭包。\n这个优化在递归场景下的效果是最明显的，因为递归代码最容易在栈内存中迅速产生大量栈帧。\n</pre>\n#### 11.1 异步编程\n<pre>\nJavaScript引擎会在创建期约时尽可能保留完整的调用栈。在抛出错误时，调用栈可以由运行时的错误处理逻辑获取，因而就会出现在栈追踪信息中。当然，这意味着栈追踪信息会占用内存，从而带来一些计算和存储成本。\n</pre>\n\n\n## Dart\n### \n\n\n\n## Java\n\n### 栈\n存取速度较快，栈数据可共享，数据大小和生存周期是确定的\n\n### 堆\n在运行时动态分配内存的（从而存取速度慢点）\n### 引用Java8 实战\n```\nJava8 实战\nJava类型要么是引用类型（比如Byte、Integer、Object、List），要么是原始类型（比如int、double、byte、char）。但是泛型（比如Consumer<T>中的T）只能绑定到引用类型。这是由泛型内部的实现方式造成的。[插图]因此，在Java里有一个将原始类型转换为对应的引用类型的机制。这个机制叫作装箱（boxing）。相反的操作，也就是将引用类型转换为对应的原始类型，叫作拆箱（unboxing）。Java还有一个自动装箱机制来帮助程序员执行这一任务：装箱和拆箱操作是自动完成的。比如，这就是为什么下面的代码是有效的（一个int被装箱成为Integer）：但这在性能方面是要付出代价的。装箱后的值本质上就是把原始类型包裹起来，并保存在堆里。因此，装箱后的值需要更多的内存，并需要额外的内存搜索来获取被包裹的原始值。\n\n实例变量都存储在堆中，而局部变量则保存在栈上。如果Lambda可以直接访问局部变量，而且Lambda是在一个线程中使用的，则使用Lambda的线程，可能会在分配该变量的线程将这个变量收回之后，去访问该变量。因此，Java在访问自由局部变量时，实际上是在访问它的副本，而不是访问原始变量。如果局部变量仅仅赋值一次那就没有什么区别了——因此就有了这个限制。（Lambda可以没有限制地捕获（也就是在其主体中引用）实例变量和静态变量。但局部变量必须显式声明为final，或事实上是final。换句话说，Lambda表达式只能捕获指派给它们的局部变量一次。）\n\n你可能已经听说过闭包（closure，不要和Clojure编程语言混淆）这个词，你可能会想Lambda是否满足闭包的定义。用科学的说法来说，闭包就是一个函数的实例，且它可以无限制地访问那个函数的非本地变量。例如，闭包可以作为参数传递给另一个函数。它也可以访问和修改其作用域之外的变量。现在，Java 8的Lambda和匿名类可以做类似于闭包的事情：它们可以作为参数传递给方法，并且可以访问其作用域之外的变量。但有一个限制：它们不能修改定义Lambda的方法的局部变量的内容。这些变量必须是隐式最终的。可以认为Lambda是对值封闭，而不是对变量封闭。如前所述，这种限制存在的原因在于局部变量保存在栈上，并且隐式表示它们仅限于其所在线程。如果允许捕获可改变的局部变量，就会引发造成线程不安全的新的可能性，而这是我们不想看到的（实例变量可以，因为它们保存在堆中，而堆是在线程之间共享的）。\n\n\n1965年，英国一位名为Tony Hoare的计算机科学家在设计ALGOL W语言时提出了null引用的想法。ALGOL W是第一批在堆上分配记录的类型语言之一。Hoare选择null引用这种方式，“只是因为这种方法实现起来非常容易”。虽然他的设计初衷就是要“通过编译器的自动检测机制，确保所有使用引用的地方都是绝对安全的”，他还是决定为null引用开个绿灯，因为他认为这是为“不存在的值”建模最容易的方式。很多年后，他开始为自己曾经做过这样的决定而后悔不迭，把它称为“我价值百万的重大失误”。我们已经看到它带来的后果——程序员对对象的字段进行检查，判断它的值是否为期望的格式，最终却发现我们查看的并不是一个对象，而是一个空指针，它会立即抛出一个让人厌烦的NullPointerException异常。\n\n\n```"},{"title":"客户端缓存-redis6","url":"/2021/07/05/客户端缓存-redis6/","content":"\n### 参考文章\n- http://antirez.com/news/130\n- https://redis.io/topics/client-side-caching\n- https://www.youtube.com/watch?v=kliQLwSikO4\n- https://www.slideshare.net/RedisLabs/redisconf18-techniques-for-synchronizing-inmemory-caches-with-redis\n- https://mp.weixin.qq.com/s/4hpu4R-IG3CgLTi_U7rjig\n\n#### 6.0 + feature\n- 实现了服务端协助的客户端缓存功能 - tracking\n- 作用\n  - 普通模式\n  - 广播模式\n  - 重定向模式\n- 场景 -> 加速业务应用访问\n\n\n## 6.0 others feature\n- 面向网络处理 - 多IO线程\n- 细粒度的权限控制\n- RESP 3 协议"},{"title":"redis-node","url":"/2021/07/03/redis-node/","content":"> 官网指南： redis.js.org/\n### cache.js\n```\n// SET ｜ GET （缓存的数据，字符串键）\n// 字符串键\n```\n\n### redisInsight\n- 官方可视化管理工具\n\n### redisMod\n```\nRediSearch：一个功能齐全的搜索引擎\nRedisJSON：对JSON类型的原生支持\nRedisTimeSeries：时序数据库支持\nRedisGraph：图数据库支持\nRedisBloom：概率性数据的原生支持\nRedisGears：可编程的数据处理\nRedisAI：机器学习的实时模型管理和部署\n```\ndocker pull redislabs/redismod:preview\ndocker run -p 6379:6379 --name redismod -v /mydata/redismod/data:/data -d redislabs/redismod:preview"},{"title":"redis使用手册-精读","url":"/2021/07/02/redis使用手册-精读/","content":"\n> 书里面的示例是用python实现的，我这边用node实现了下\n\n## 安装配置\n\n### 参考文档\nhttps://groups.google.com/g/redis-db\n\n### 安装\n\n#### Mac安装：\n```\nxcode-select --install\ngit clone https://github.com/antirez/redis.git\ncd redis\nmake\nmake test\ncd src\n./redis-server\n./redis-cli\n```\n#### windows\n官方不支持，可以用docker(https://hub.docker.com/_/redis/)\n\n#### redis-py\n```\npip install redis\npython3\n>>> from redis import Redis\n>>> client = Redis()\n>>> client.set(\"msg\",\"hello world\")\n>>> client.get(\"msg)\n>>> for i in dir(client)\n```\n\n## 数据结构\n> 命令COMMAND - https://redis.io/commands\n\n### 字符串\n- 文字数据 ｜ 二进制数据 均可\n- 制定命名格式 - 提升可读性+避免键名冲突\n- 多个字符串键存储相关联的一组数据 - 技术可行，并不最有效\n#### SET ｜ GET ｜ GETSET \nNX（只在键不存在的情况下为它设置值） ｜ XX （只在键已经存在的情况下为它设置新值）\n#### MSET \n减少网络通信次数，从而减少程序执行多个设置操作的时间\n#### MGET\n#### MSETNX\n只要有一个键有值，会放弃对所有给定键的操作\n#### STRLEN\n#### GETRANGE\n- ```GETRANGE key start end``` \n- 位于start&end的值也包含\n#### SETRANGE\n- ```SETRANGE key index substitute```\n- 自动扩展，空字节填充\n#### APPEND\n- 键不存在-设置；键存在-追加\n#### INCRBY ｜ DECRBY ｜ INCR ｜ DECR ｜ INCRBYFLOAT\n可用于计数器 ｜ id生成器 ｜ 限速器\n\n\n### 散列\n- 通过散列键，包相关联的多项数据存储到一个散列中\n- eg. 短网址生成程序\n- 无序\n#### HSET | HSETNX | HGET \n```HSET hash field value```\n#### HINCRBY\n没有提供减法操作，通过传负数增量来实现\n#### HINCRBYFLOAT\ncounter\n#### HSTRLEN ｜ HEXISTS ｜ HDEL ｜ HLEN\nlogin session\n#### HMSET ｜ HMGET\n#### HKEYS ｜ HVALS ｜ HGETALL\ngraph \n文章存储\n### 字符串键和散列键比较\n#### 资源占用\n内存&&CPU —— 散列\n#### 支持的操作\n字符串：SETRANGE｜GETRANGE\n\n#### 过期时间\n字符串粒度更细，相比较\n\n### 列表\n- list\n- 线性有序结构\n\n#### LPUSH ｜ RPUSH ｜ LPUSHX ｜ RPUSHX\n- -X 只对已存在对列表执行推入操作\n#### LPOP | RPOP | RPOP ｜ RPOPLPUSH\n- FIFO 队列\n#### LLEN ｜ LINDEX ｜ LRANGE\n- 分页\n#### LSET ｜ LINSERT ｜ LTRIM ｜ LREM \n- ToDo List\n#### BLPOP ｜ BRPOP ｜ BRPOPLPUSH\n- 有阻塞功能的消息队列\n\n### 集合\n- 非重复元素\n- 无序\n#### SADD | SREM | SMOVE | SMEMBERS | SCARD | SISMEMBER\n- unique count\n- tag\n- thumb\n- vote\n- social relationship\n#### SRANDMEMBER | SPOP\n- 抽奖\n\n#### SINTER | SINTERSTORE | SUNION | SUNIONSTORE | SDIFF | SDIFFSTORE\n- 共同关注\n- 反向索引构建商品筛选器\n\n### 有序集合\n- sorted set\n\n#### ZADD | ZREM | ZSCORE | ZINCRBY | ZCARD | ZRANK | ZREVERANK | ZRANGE | ZREVERANGE\n- ZADD - O(M*log(N))\n- 排行榜\n\n#### ZRANGEBYSCORE ｜ ZREVERAMGEBYSCORE ｜ ZUNIONSTORE ｜ ZINTERSTORE\n- 商品推荐\n\n#### ZRANGEBYLEX ｜ ZRVERANGEBYLEX ｜ ZLEXCOUNT ｜ ZERMRANGEBYLEX\n- 自动补全\n\n#### ZPOPMAX ｜ ZPOPMIN ｜ BZPOPMAX ｜ BZPOPMIN \n\n### HyperLogLog\n\n- 概率算法，对大量元素进行计数，算出近似基数\n- 使用固定大小内存\n- PFMERGE - HyperLogLog-PFCOUNT\n- 可以用于去重\n- 基数统计：cardinality of a set is a measure of the \"number of elements\" of the set\n- standard error - 0.81%\n\n### 持久化方式\nRedis的持久化方式主要有两种：RDB（Redis DataBase）和AOF（Append Only File）。\n\n1. RDB：RDB按照设定的规则定期将内存中的数据存储在磁盘上，即快照存储。这些规则可以是时间和数量的集合，例如，10分钟（时间）内如果有10000次（数量）以上的写操作，就自动进行快照存储。RDB是Redis默认的持久化方式，适用于对数据安全性要求较高的场景。\n\n2. AOF：AOF记录服务器接收到的所有写操作，并在启动时通过重新执行这些命令来还原数据集。AOF文件中的命令都是以redis协议的格式追加保存的，可以对这些命令进行人为干预，比如部分删除或者修改。此外，Redis还可以在后台自动对AOF文件进行重写，使其体积保持在最小。AOF相比RDB，在系统故障时能提供更高的数据完整性。"},{"title":"深入rabbitmq-精读","url":"/2021/06/30/深入rabbitmq-精读/","content":"### 私有化部署web端\n#### connections:\n- virtual hostname(Overview)\n- node(Overview) \n- user name(Overview)\n- state(Overview)\n- ssl/tls(Details)\n- protocol(Details) - AMQP 0-9-1\t\n- channels(Details)\n- from client\n\n#### amqp\n- https://www.npmjs.com/package/amqplib (AMQP 0-9-1 library and client for Node.JS)\n- \n\n### 流量削峰 - 容器化，扩容消费\n### 应用解耦 - 恢复后消费\n\n### test-demo\n- rabbitmq,带management的，docker desktop\n- 15672 管理界面\n- 5672 mq服务"},{"title":"handsfree使用总结","url":"/2021/06/29/handsfree使用总结/","content":"\n> github指路：https://github.com/MIDIBlocks/handsfree ，官网指路：https://handsfree.js.org/ ； 可以git项目直接拉下来，然后启动，官网的demo可以本地调试；\n\n## 技术栈分析\n### face mesh\n- 基于Google的mediapipe\n- https://github.com/google/mediapipe\n- js相关demo可见：https://google.github.io/mediapipe/getting_started/javascript\n\n"},{"title":"pm2","url":"/2021/06/29/pm2/","content":"\n## 源码分析\n### cluster\n```\n// lib/God.js\nvar cluster       = require('cluster');\nrequire('./God/ClusterMode.js')(God);\n/**\n     * Cluster mode logic (for NodeJS apps)\n     */\n...\n// ./God/ClusterMode.js\nmodule.exports = function ClusterMode(God) {\n\n  /**\n   * For Node apps - Cluster mode\n   * It will wrap the code and enable load-balancing mode\n   * @method nodeApp\n   * @param {} env_copy\n   * @param {} cb\n   * @return Literal\n   */\n  God.nodeApp = function nodeApp(env_copy, cb){\n    var clu = null;\n\n    console.log(`App [${env_copy.name}:${env_copy.pm_id}] starting in -cluster mode-`)\n    if (env_copy.node_args && Array.isArray(env_copy.node_args)) {\n      cluster.settings.execArgv = env_copy.node_args;\n    }\n\n    env_copy._pm2_version = pkg.version;\n\n    try {\n      // node.js cluster clients can not receive deep-level objects or arrays in the forked process, e.g.:\n      // { \"args\": [\"foo\", \"bar\"], \"env\": { \"foo1\": \"bar1\" }} will be parsed to\n      // { \"args\": \"foo, bar\", \"env\": \"[object Object]\"}\n      // So we passing a stringified JSON here.\n      clu = cluster.fork({pm2_env: JSON.stringify(env_copy), windowsHide: true});\n    } catch(e) {\n      God.logAndGenerateError(e);\n      return cb(e);\n    }\n\n    clu.pm2_env = env_copy;\n\n    /**\n     * Broadcast message to God\n     */\n    clu.on('message', function cluMessage(msg) {\n      /*********************************\n       * If you edit this function\n       * Do the same in ForkMode.js !\n       *********************************/\n      if (msg.data && msg.type) {\n        return God.bus.emit(msg.type ? msg.type : 'process:msg', {\n          at      : Utility.getDate(),\n          data    : msg.data,\n          process :  {\n            pm_id      : clu.pm2_env.pm_id,\n            name       : clu.pm2_env.name,\n            rev        : (clu.pm2_env.versioning && clu.pm2_env.versioning.revision) ? clu.pm2_env.versioning.revision : null,\n            namespace  : clu.pm2_env.namespace\n          }\n        });\n      }\n      else {\n\n        if (typeof msg == 'object' && 'node_version' in msg) {\n          clu.pm2_env.node_version = msg.node_version;\n          return false;\n        }\n\n        return God.bus.emit('process:msg', {\n          at      : Utility.getDate(),\n          raw     : msg,\n          process :  {\n            pm_id      : clu.pm2_env.pm_id,\n            name       : clu.pm2_env.name,\n            namespace  : clu.pm2_env.namespace\n          }\n        });\n      }\n    });\n\n    return cb(null, clu);\n  };\n};\n\n```\n我们还可以看下cluster mode的测试用例\n### God.js的依赖\n```\nvar cluster       = require('cluster');\nvar numCPUs       = require('os').cpus() ? require('os').cpus().length : 1;\nvar path          = require('path');\nvar EventEmitter2 = require('eventemitter2').EventEmitter2;\nvar fs            = require('fs');\nvar vizion        = require('vizion');\nvar debug         = require('debug')('pm2:god');\nvar Utility       = require('./Utility');\nvar cst           = require('../constants.js');\nvar timesLimit    = require('async/timesLimit');\nvar Configuration = require('./Configuration.js');\nvar semver        = require('semver');\n```\n#### semver\n```\n/**\n * Override cluster module configuration\n */\nif (semver.lt(process.version, '10.0.0')) {\n  cluster.setupMaster({\n    windowsHide: true,\n    exec : path.resolve(path.dirname(module.filename), 'ProcessContainerLegacy.js')\n  });\n}\nelse {\n  cluster.setupMaster({\n    windowsHide: true,\n    exec : path.resolve(path.dirname(module.filename), 'ProcessContainer.js')\n  });\n}\n```\n显然，semver(1) -- The semantic versioner for npm，用作判断版本\n#### vizion\n- Git/Subversion/Mercurial repository metadata parser\n- Grab metadata for svn/git/hg repositories ```vizion.analyze```\n- Check if a local repository is up to date with its remote```vizion.isUpToDate```\n- Update the local repository to latest commit found on the remote for its current branch on fail it rollbacks to the latest commit```vizion.update```\n- Revert to a specified commit```revertTo```\n- ...等功能\nGod.js中用到了analyze, 目标是：Discovers if your app is a svn/git/hg repository and shows metadata about it\n\n```\n\n/**\n * Grab metadata for svn/git/hg repositories\n */\nvizion.analyze({\n  folder : '/tmp/folder'\n}, function(err, meta) {\n  if (err) throw new Error(err);\n\n  /**\n   *\n   * meta = {\n   *   type        : 'git',\n   *   ahead       : false,\n   *   unstaged    : false,\n   *   branch      : 'development',\n   *   remotes     : [ 'http', 'http ssl', 'origin' ],\n   *   remote      : 'origin',\n   *   commment    : 'This is a comment',\n   *   update_time : Tue Oct 28 2014 14:33:30 GMT+0100 (CET),\n   *   url         : 'https://github.com/keymetrics/vizion.git',\n   *   revision    : 'f0a1d45936cf7a3c969e4caba96546fd23255796',\n   *   next_rev    : null,  // null if its latest in the branch\n   *   prev_rev    : '6d6932dac9c82f8a29ff40c1d5300569c24aa2c8'\n   * }\n   *\n   */\n});\n```\n```\n// God.js\nvizion.analyze({folder : current_path}, function recur_path(err, meta){\n    var proc = God.clusters_db[proc_id];\n\n    if (err)\n      debug(err.stack || err);\n\n    if (!proc ||\n        !proc.pm2_env ||\n        proc.pm2_env.status == cst.STOPPED_STATUS ||\n        proc.pm2_env.status == cst.STOPPING_STATUS ||\n        proc.pm2_env.status == cst.ERRORED_STATUS) {\n      return console.error('Cancelling versioning data parsing');\n    }\n\n    proc.pm2_env.vizion_running = false;\n\n    if (!err) {\n      proc.pm2_env.versioning = meta;\n      proc.pm2_env.versioning.repo_path = current_path;\n      God.notify('online', proc);\n    }\n    else if (err && current_path === last_path) {\n      proc.pm2_env.versioning = null;\n      God.notify('online', proc);\n    }\n    else {\n      last_path = current_path;\n      current_path = path.dirname(current_path);\n      proc.pm2_env.vizion_running = true;\n      vizion.analyze({folder : current_path}, recur_path);\n    }\n    return false;\n  });\n```\n\n\n## 项目使用\n### 日志配置\n- ecosystem file \n - merge_logs | log | log_Date_format\n - pm2 install pm2-logrotate && pm2 set pm2-logrotate:retain 14\n - scripts: pm2 start ecosystem.config.js --env xxx (dev + --watch)\n\n\n ## basic 介绍\n ### pm2 list\n #### uptime\n 运行时间\n #### restarts\n 重启次数\n\n\n ## 监控\n ### pm2.IO\n - 官方：keymetrics, 有免费的配额（You can now connect up to 4 servers or Node.js processes for free.）\n - 免费的限制服务数量，且功能较少，里面还会有plus和enterprise版本的供选购\n - https://pm2.keymetrics.io/docs/usage/docker-pm2-nodejs/\n - https://app.pm2.io/\n ```\n # server\n pm2 link xxx-sec-key xxx-pub-key\n # docker\n RUN npm install pm2 -g\n ENV PM2_PUBLIC_KEY xxx\n ENV PM2_SECRET_KEY xxx\n\n CMD [\"pm2-runtime\", \"app.js\"]\n # pm2 link\n pm2 link -h\n\n  Usage: link [options] [secret] [public] [name]\n\n  link with the pm2 monitoring dashboard\n\n  Options:\n\n    --info-node [url]  set url info node\n    --ws               websocket mode\n    --axon             axon mode\n    -h, --help         output usage information\n ```\n\n ### Launch PM2 in no deamon\n\nMake sure you kill any PM2 instance before starting PM2 in no deamon mode (pm2 kill).\n\nLaunching PM2 without daemonizing itself:\n\npm2 start app.js --no-daemon\nThere is also the CLI pm2-runtime installed by default at PM2 installation, that is a drop-in replacement of the Node.js binary.\n\n## doc\n### options\n#### --watch\nRestart application on changes\n```\n\n```"},{"title":"dart使用感受","url":"/2021/06/25/dart使用感受/","content":"\n## overview\n\n### 最好的了解网站-官网\n\n- https://dart.cn/\n- https://dart.cn/guides\n\n> 讲，练，经验总结，风格指导为一体的官网，文档真的写的不错;\n\n### 生态发展很快\n\n- 官方全家桶提供，和两年前比起来，各方面生态迅速发展完备\n- 国内可看闲鱼团队的一系列文章（https://juejin.cn/team/6932366495007801348/posts）\n\n### 在线 repl\n\n- https://dartpad.cn/\n- https://replit.com/languages/dart\n\n## Tips\n\n### 通用概念\n- 以main函数作为执行的入口\n- 类型安全，所有类型都是对象类型（继承自顶层类型Object）\n- 未初始化变量的值为null\n\n\n### comparison with Javascript\n#### if | assert ，dart中不能使用非布尔类型的值传入\n### 特殊语法\n- ```..```\n```\n\n``` \n\n## 深入语言\n\n### baiscs\n#### 基本的一些类型\n- num (int | double) 都是64位，后者符合IEEE 754标准\n- String UTF-16\n- const 适用于定义编译常量\n- final 适用于定义运行时常量"},{"title":"flutter开发环境配置","url":"/2021/06/24/flutter开发环境配置/","content":"\n### 环境配置\n\n问题:\n\n1. 执行 flutter doctor 之后，出现这个\n\n```\n[!] Xcode - develop for iOS and macOS\n    ✗ CocoaPods installed but not working.\n        You appear to have CocoaPods installed but it is not working.\n        This can happen if the version of Ruby that CocoaPods was installed with is different from the one being used to invoke it.\n        This can usually be fixed by re-installing CocoaPods.\n      To re-install see https://guides.cocoapods.org/using/getting-started.html#installation for instructions.\n```\n\n```\n# 清理旧版本,Remove stale lock files and outdated downloads for all formulae and casks, and remove old versions of installed formulae. \nbrew cleanup -d -v\nbrew install cocoapods | brew upgrade cocoapods\n```\n\n如果提示 failed to link, brew link cocoapods\n\n2. IOS 设备开发调试\n\n- 普通调试，Xcode 登录开发者帐号，进入项目，双击 xxx/ios/Runner.xcworkspace , 在 Runner.xcodeproj Tab 下，Targets/Runner , Signing & Capabilities , 里面的 Signing ： 1.勾选 Automatically manage signing 2.Team 选择登录的帐号的 Team； 这样会自动给生成一个临时的签名； 设备插入电脑，就可以识别并安装了；\n- 记得关掉 iPhone 的同步功能，不然会显示设备 busy\n- 查 UDID\n  设备连接到 Mac 电脑上\n  点击设备，显示的信息最上方，可以点击内容切换信息；切到有 UDID 的，然后右键，选择拷贝 UDID 即可\n- `flutter run --release `,可以在 ios 设备上安装 release 包，这样不在连接情况下，也能使用\n\n3. android 设备开发调试\n\n#### Android\n\n- 连上 android 设备\n- 如果 flutter doctor 出现 android 方面的问题，可以打开 android studio，点击 preferences\n- 以 SDK 为关键词搜索，进入到 Android SDK 设置的面板，这个时候就可以安装没有安装的 SDK\n- 下面的问题，Android SDK 面板 - SDK platform 里面选择对应版本安装\n\n```\n[!] Android toolchain - develop for Android devices (Android SDK version 30.0.3)\n    ✗ Android SDK file not found:\n      /Users/kuangyimin/Library/Android/sdk/platforms/android-30/android.jar.\n```\n\n- 下面的问题，按提示，Run `flutter doctor --android-licenses`\n\n```\n[!] Android toolchain - develop for Android devices (Android SDK version 30.0.3)\n    ✗ Android license status unknown.\n      Run `flutter doctor --android-licenses` to accept the SDK licenses.\n      See https://flutter.dev/docs/get-started/install/macos#android-setup for\n      more details.\n```\n\n- 如果出现了这个问题，则可以在 Android SDK 面板设置 \"command line tools\",勾选，然后安装\n\n```\nflutter doctor --android-licenses\nException in thread \"main\" java.lang.NoClassDefFoundError: javax/xml/bind/annotation/XmlSchema\n\tat com.android.repository.api.SchemaModule$SchemaModuleVersion.<init>(SchemaModule.java:156)\n```\n\n- 如果 flutter run 的时候提示这个问题，则可以按提示，去 Android Studio，搜 SDK，下载对应缺少的 SDK\n\n```\nCould not determine the dependencies of task ':launch_review:compileDebugAidl'.\n> Failed to install the following SDK components:\n      platforms;android-28 Android SDK Platform 28\n  Install the missing components using the SDK manager in Android Studio.\n```\n\n- 阿里云镜像配置\n\n```\n// 对照表\n// https://developer.aliyun.com/mvn/guide\n//\nbuildscript {\n    repositories {\n        // google()\n        // jcenter()\n        maven {\n            url 'https://maven.aliyun.com/repository/google'\n        }\n        maven {\n            url 'https://maven.aliyun.com/repository/jcenter'\n        }\n        maven {\n            url 'https://maven.aliyun.com/nexus/content/groups/public'\n        }\n    }\n\n    dependencies {\n        classpath 'com.android.tools.build:gradle:3.5.4'\n    }\n}\n\n```\n- 开模拟器的时候，如果报\"The emulator process for AVD was killed\"\n原因：没有足够的空间，可以关掉别的占内存的软件；删除虚拟机，重新安装，启动；\nshow on Disk(可以看到安装的位置)\n### 命令查询\n\n`flutter --help`\n\n```\nAvailable commands:\n  analyze           Analyze the project's Dart code.\n  assemble          Assemble and build Flutter resources.\n  attach            Attach to a running app.\n  bash-completion   Output command line shell completion setup scripts.\n  build             Build an executable app or install bundle.\n  channel           List or switch Flutter channels.\n  clean             Delete the build/ and .dart_tool/ directories.\n  config            Configure Flutter settings.\n  create            Create a new Flutter project.\n  devices           List all connected devices.\n  doctor            Show information about the installed tooling.\n  downgrade         Downgrade Flutter to the last active version for the current channel.\n  drive             Run integration tests for the project on an attached device or emulator.\n  emulators         List, launch and create emulators.\n  format            Format one or more Dart files.\n  gen-l10n          Generate localizations for the current project.\n  install           Install a Flutter app on an attached device.\n  logs              Show log output for running Flutter apps.\n  precache          Populate the Flutter tool's cache of binary artifacts.\n  pub               Commands for managing Flutter packages.\n  run               Run your Flutter app on an attached device.\n  screenshot        Take a screenshot from a connected device.\n  symbolize         Symbolize a stack trace from an AOT-compiled Flutter app.\n  test              Run Flutter unit tests for the current project.\n  upgrade           Upgrade your copy of Flutter.\n\nRun \"flutter help <command>\" for more information about a command.\nRun \"flutter help -v\" for verbose help output, including less commonly used options.\n```\n\n```\nCreate a new Flutter project.\nIf run on a project that already exists, this will repair the project, recreating any files that are missing.\n如果想要生成对应iOS，android文件，可以 flutter create .\n```\n\n#### 调试问题\n\n```\nvm-service: Error: Unhandled exception:\nWebSocketException: Invalid WebSocket upgrade request\n[VERBOSE-2:dart_isolate.cc(1137)] Unhandled exception:\nWebSocketException: Invalid WebSocket upgrade request\nError connecting to the service protocol: failed to connect to http://127.0.0.1:55440/xxxxx=/\n```\n\n1. Error connecting to the service protocol: failed to connect to http://127.0.0.1:58661/xxxxx=/\n   \n2. 问题原因，电脑开了系统代理 | 设备和电脑不在一个网络；\n3. 解决方案，关掉系统代理，如果在当前 terminal 里面加了 export 语句，记得关掉，重新打开一个新的终端；如果是外接设备，可以把设备和电脑连接到同一个网络；\n\n#### IOS\n\n1. Specifies the platform for which a static library should be built.\n\n```\npodfile:\n# Uncomment this line to define a global platform for your project\nplatform :ios, '9.0'\nhttps://guides.cocoapods.org/syntax/podfile.html#platform\n```\n\n2. https://guides.cocoapods.org/syntax/podfile.html\n   podfile 的配置\n"},{"title":"vim-精读","url":"/2021/06/22/vim-精读/","content":"### 参考文档\nhttps://yianwillis.github.io/vimcdoc/doc/help.html\n\n> 设计理念 - 模式的转换 + 命令的组合 + 丰富的插件 ； 向后兼容较好； Bram Mooleanaar; Vi Imitation -> Vi IMproved; Bill Joy\n## 平时遇到的问题\n### swap file\n按提示做选择即可\n\n## basic - concept - command\n- normal模式 （ESC回到这个，命令在这个模式下输入）\n- insert模式 (insert - i |  append - a 可进入)\n- visual模式 (选择文本块 v)\n- command-line模式（: | /-搜索 | ?-搜索）\n\n\n\n#### tips\n- 如果用的远程终端软件 - 记得设置远程字符集为UTF-8\n- mac - which vim\n- mac - MacVim - 图形化界面 - homebrew\n- 启动中文教程 - LANG=zh_CN.UTF-8 vimtutor\n\n\n### Janus - 集成套件\n`curl -Lo- https://bit.ly/janus-bootstrap | bash`\n- ack.vim\n- ctrlp\n- nerdtree\n- supertab"},{"title":"函数签名","url":"/2021/06/22/函数签名/","content":"https://developer.mozilla.org/en-US/docs/Glossary/Signature/Function\nhttps://en.wikipedia.org/wiki/Type_signature\n\nA function signature (or type signature, or method signature) defines input and output of functions or methods.\n\n8.3 继承继承是面向对象编程中讨论最多的话题。很多面向对象语言都支持两种继承：接口继承和实现继承。前者只继承方法签名，后者继承实际的方法。接口继承在ECMAScript中是不可能的，因为函数没有签名。实现继承是ECMAScript唯一支持的继承方式，而这主要是通过原型链实现的。\n- JS高程第4版\n\n### 项目实例\n#### sentinel（https://github.com/alibaba/Sentinel/wiki/%E4%BB%8B%E7%BB%8D）\n- @SentinelResource 注解\n  - 属性：fallback/fallbackClass：fallback 函数名称，可选项，用于在抛出异常的时候提供 fallback 处理逻辑。fallback 函数可以针对所有类型的异常（除了exceptionsToIgnore里面排除掉的异常类型）进行处理。fallback 函数签名和位置要求：\n  返回值类型必须与原函数返回值类型一致；\n  方法参数列表需要和原函数一致，或者可以额外多一个 Throwable 类型的参数用于接收对应的异常。\n  fallback 函数默认需要和原方法在同一个类中。若希望使用其他类的函数，则可以指定 fallbackClass 为对应的类的 Class 对象，注意对应的函数必需为 static 函数，否则无法解析。"},{"title":"依赖管理","url":"/2021/06/22/依赖管理/","content":"### CocoaPods\nhttps://cocoapods.org/\n\nCocoaPods is a dependency manager for Swift and Objective-C Cocoa projects. It has over 83 thousand libraries and is used in over 3 million apps. CocoaPods can help you scale your projects elegantly.\n\n### podfile"},{"title":"parse-generator-语法解析生成器","url":"/2021/06/22/parse-generator-语法解析生成器/","content":"### antlr\nwiki:\nhttps://zh.wikipedia.org/wiki/ANTLR\n\ngithub:\nhttps://github.com/antlr/antlr4\n\n"},{"title":"前端开发趁手小工具","url":"/2021/06/22/前端开发趁手小工具/","content":"### chrome插件\nFeHelper(前端助手) - 可以方便格式化文本\nSourceGraph - 方便在线查看github项目结构\nbase64 - https://www.base64decode.org/ , https://www.base64encode.org/\n本质 - atob / btoa - https://developer.mozilla.org/zh-CN/docs/Web/API/atob - https://developer.mozilla.org/zh-CN/docs/Web/API/btoa\n```\nhttps://github.com/dankogai/js-base64\n.decode() vs .atob (and .encode() vs btoa())\nSuppose you have:\n\nvar pngBase64 = \n  \"iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=\";\nWhich is a Base64-encoded 1x1 transparent PNG, DO NOT USE Base64.decode(pngBase64).  Use Base64.atob(pngBase64) instead.  Base64.decode() decodes to UTF-8 string while Base64.atob() decodes to bytes, which is compatible to browser built-in atob() (Which is absent in node.js).  The same rule applies to the opposite direction.\n\nOr even better, Base64.toUint8Array(pngBase64).s\n```\nTalend API Tester - Free Edition - api测试工具\n\n### 平时随便看看\n#### 文档，规范\nMDN + WHATWG + W3C\nhttps://developer.mozilla.org/zh-CN/\nhttps://html.spec.whatwg.org/#window\nhttps://402.ecma-international.org/5.0/#Title\nhttps://tc39.es/ecma262/#sec-map.prototype.foreach\nhttps://www.w3.org/TR/XMLHttpRequest/\n\n#### 文章\nhttps://javascript.info/\nhttps://www.html.cn/30-seconds-of-code/#everynth\n\n#### 小练习小游戏\nhttps://jskatas.org/#bundle-es6-katas"},{"title":"iconfont使用经验总结","url":"/2021/06/22/iconfont使用经验总结/","content":"\n### 地址\n\nhttps://www.iconfont.cn/\n\nTips:\n\n- 做好权限管理，如果有人员变更，保证项目仓库的维护的及时\n- 写好操作指南-团队文档\n\n### 操作指南及原理说明\n#### why\n- 不同浏览器不同版本，支持的字体格式不一样；\n- 我们可以设计一些图标占字体的坑，从而可以像操作字一样操作图标（矢量的）\n- 使用 - 1.font-face声明字体 2.定义使用iconfont的样式 3. <i class=\"iconfont\">&#x0032</i> （unicode） 4.:before :after等伪元素 content:\"\\0032\"; （16进制）\n- 注意设备跨域问题的兼容\n- -webkit-font-smoothing: antialiased; （解决字体图标存在半个像素的锯齿，在浏览器渲染时为一个像素，从而看起来加粗）\n- ie使用16进制unicode的时候加；号\n\n#### 官方文档\n\nhttps://www.iconfont.cn/help/detail?spm=a313x.7781069.1998910419.d8cf4382a&helptype=code\n\n#### tips\n\n切记单色\n\n#### trick\n\n如果想要有渐变色什么的，可以背景色设置，然后字弄成透明的\n\n#### 操作指南\n\n1. 为开发成员增加项目权限\n\n2. 位置\n\n```\n项目中引用位置：\nsrc/main.js\n=> import '@/assets/font/iconfont.css'\n文件存放位置：\nsrc/assets/font\n```\n\n3. 修改方式：\n\n```\n1. 从iconfont下载代码（Font class=>下载至本地），替换原有src/assets/font文件夹\n2. 然后修改iconfont.css文件，在第18行增加下面代码：\n\n[class^=\"el-icon-third\"],\n[class*=\" el-icon-third\"]\n{\nfont-family: \"iconfont\" !important;\nfont-size: 16px;\nfont-style: normal;\n-webkit-font-smoothing: antialiased;\n-moz-osx-font-smoothing: grayscale;\n}\n```\n\n4. 使用方式：\n   直接在根据 class 名称(选择 Font Class,然后点复制代码)引用即可，名称可在 iconfont.css 查看，如果觉得名称有问题，可以在 iconfont 网站上面修改，然后更新 font 文件夹。\n   `<i class=\"el-icon-third-share\" />`\n\n## 同类平台\nFontAwesome（https://fontawesome.com/icons）\nionicons（https://ionicons.com/）\n\n\n"},{"title":"swagger","url":"/2021/06/22/swagger/","content":"### 接口文档：\n详细地描述了后端接口的访问方式和参数说明\n\n### 接口定义方式主要有两种：\n- Swagger等，RESTFUL API；\n- protobuf，跨语言的接口定义；\n  - （https://github.com/protocolbuffers/protobuf/tree/master/java）\n  - （https://developers.google.com/protocol-buffers/）\n  -  （https://opensource.com/article/19/10/protobuf-data-interchange）\n\n### 推荐阅读：\nhttps://swagger.io/\nhttps://swagger.io/tools/open-source/\n\nswagger：\n#### history\n- SmartBear Software\n- RESTFUL API工具\n- 设计，构建，记录，使用\n- openAPI Initiative\n\n#### uses\n- 项目中接口展现\n- 接口更新\n- 直接接口调用\n\n\n### 目前团队使用的API-Management工具——YAPI\n#### EasyYapi - 可以导出http,rpc，call api 调用 API\n- Java端用：http://easyyapi.com/documents/index.html\n- https://github.com/tangcent/easy-yapi/blob/master/README.md\n- 对代码0入侵\n- （https://github.com/diwand/YapiIdeaUploadPlugin/wiki/%E5%BF%AB%E9%80%9F%E4%BD%BF%E7%94%A8）可做替代\n- IDEA插件\n\n#### apimock\nswaggerconfig配置类集成到 api-mock组件中，swagger生成的接口文件可以通过数据导入，导入到yapi中\n\n### 其他\n- https://github.com/thx/rap2-delos 阿里妈妈出品，开源接口管理工具\n  - 接口文档管理\n  - Mock\n  - 导出"},{"title":"node-benchmark","url":"/2021/06/22/node-benchmark/","content":"\n### node\nnode的benchmark写的还是非常值得学习的\n\n\n### 项目经验\n- 会做redis的基准测试方案\n- ```redis-benchmark -h [目标机的IP] -p [目标机的redis端口号] -a [目标机redis密码,可省略] –q```\n- 精简测试｜pipeline测试｜随机key测试\n- QPS（request per second）的情况\n\n\n### 基础知识\n- QPS - 每秒查询率 fetches/sec 每秒响应的请求数，也就是最大吞吐能力\n- TPS - 吞吐量 - 单位时间内能处理的数量\n- 并发：一段时间访问的大量用户的请求\n- 并行：同一时刻的大量的用户请求\n- 峰值时间的每秒请求 / 单台的QPS = 机器数量\n\n### 微基准测试\n\n\n### 宏基准测试\n\n\n### reference\n- https://docs.deno.com/runtime/manual/tools/benchmarker"},{"title":"node-ReadableStream","url":"/2021/06/22/node-ReadableStream/","content":"\n### readablestream\n- 在 JavaScript 中, Streams API 的 ReadableStream 允许你在一段长时间内读取一段数据而不是一次性获取所有数据。这对于处理网络响应、文件读写等提供了极大的便利，特别是在处理大文件或者实时数据时，我们可以边读边处理，提高性能并提升用户体验。\n\nReadableStream 非常适合配合 `for await...of` 循环进行异步迭代。以下面这个从网络获取文本的例子来说明：\n\n```javascript\nasync function logChunks(readableStream) {\n  const reader = readableStream.getReader();\n  try {\n    for await (const chunk of reader) {\n      console.log(chunk);\n    }\n  } finally {\n    reader.releaseLock();\n  }\n}\n\nfetch('https://some.url/')\n.then((response) => logChunks(response.body));\n```\n\n在这个示例中，我们创建了一个 `ReadableStream` 的 reader，并在 `for await...of` 中异步迭代这个 reader。每个 chunk 是 `ReadableStream` 中的一部分数据。我们打印出每个 chunk，直到我们处理完所有的数据。\n\n注意，一旦我们处理完所有数据，或者发生错误，我们需要调用 `reader.releaseLock()` 来释放对 `ReadableStream` 的锁定，以便后续的代码可以继续使用这个 `ReadableStream`。\n\n上述例子中的 `for await...of` 会等待每次迭代的 promises 完成，所以我们会按照流中数据的顺序来处理数据。如果因为某种原因我们需要停止读取流，我们可以简单地 `break` 掉 `for await...of` 循环，这将会释放流的锁定。\n\n#### web\n- https://chromestatus.com/feature/5143121161879552?context=myfeatures\n\n### diff\n在 Node.js 和浏览器环境中，ReadableStream 的异步迭代处理会有些差异。\n\n1. 浏览器环境：\n\n在浏览器环境中，你可以直接利用 Streams API 的 ReadableStream 进行异步迭代。这是因为 Streams API 是 Web 平台的一部分，所以在浏览器原生支持。\n\n例如，当你从网络获取数据时，你可以如下操作：\n```javascript\nasync function processData(readableStream) {\n    const reader = readableStream.getReader();\n    try {\n        for await (const chunk of reader.read()) {\n            console.log(chunk);\n        }\n    } catch(err){\n        console.error(\"Error:\", err);\n    } finally {\n        reader.releaseLock();\n    }\n}\n\nfetch('https://example.com/')\n     .then(response => processData(response.body))\n     .catch(err => console.error(err));\n```\n这种方式的优势在于，你可以立即开始处理数据，而不必等到所有数据下载完成。\n\n2. Node.js 环境：\n\nNode.js 利用的是 Stream 模块，它与浏览器中的 Streams API 略有不同，但是设计的初衷是类似的。Node.js 中的 readable stream 也支持异步迭代。\n\n例如，如果你正在从文件中读取数据，你可以这样操作：\n\n```javascript\nconst fs = require('fs');\nasync function readStream() {\n  const readableStream = fs.createReadStream('example.txt', { encoding: 'utf8', highWaterMark: 1024 });\n  for await (const chunk of readableStream) {\n    console.log(chunk);\n  }\n}\nreadStream();\n```\n在这个示例中，我们使用 `fs.createReadStream` 创建了一个 readable stream，然后使用异步迭代进行读取。"},{"title":"CMake","url":"/2021/06/21/CMake/","content":"### 官方文档\nCMake is an open-source, cross-platform family of tools designed to build, test and package software. \n\nCMake is used to control the software compilation process using simple platform and compiler independent configuration files, and generate native makefiles and workspaces that can be used in the compiler environment of your choice. \n\nThe suite of CMake tools were created by Kitware in response to the need for a powerful, cross-platform build environment for open-source projects such as ITK and VTK.\n\nCMake is part of Kitware’s collection of commercially supported open-source platforms for software development.\n\n### 学习参考文档\nhttps://gist.github.com/mbinna/c61dbb39bca0e4fb7d1f73b0d66a4fd1\n\nhttps://github.com/ttroy50/cmake-examples\n\n### 实例：\nhttps://github.com/openkraken/kraken\n\nPrerequisites\n\nNode.js v12.0 or later\nFlutter version in the kraken/pubspec.yaml\nCMake v3.2.0 or later\nXcode (10.12) or later (Running on macOS or iOS)\nAndroid NDK version 21.4.7075529 (Running on Android)\n\n### harmonyOS已知问题\n- 如果makefile中的业务逻辑存在并发操作，由于CMake机制上通过多线程执行，在多CPU架构并发操作场景，会偶现编译失败。规避措施：建议排查并修改makefile中的业务逻辑，去除并发操作。\n- https://developer.harmonyos.com/cn/docs/documentation/doc-releases-V3/ide-known-issues-v3-1-0000001440852961-V3"},{"title":"electron新特性持续关注","url":"/2021/06/16/electron新特性持续关注/","content":"Electron13新特性\n\n## 基本架构\n### chromium-runtime\n- Browser Process - 一个\n- Renderer Process - 一个或多个\n\n### electron\n- Main Process - 增加了nodejs-runtime\n- Renderer Process\n\n- IPC通信（和Renderer Process）\n- electron API\n\n\n\n## 竞品\n- https://tauri.app/v1/guides/ - Rust\n\n### electron-to-chromium\n- This repository provides a mapping of Electron versions to the Chromium version that it uses.\n- 提供version Mapping\n- https://www.npmjs.com/package/electron-to-chromium\n\n\n### carlo\n- https://github.com/GoogleChromeLabs/carlo\n- 一个思路\n- Web rendering surface for Node applications\n- 不过已经不再maintain了\n\n\n### electron-modules\n- 一些实用的 Electron 模块\n- https://github.com/electron-modules\n\n### electron安装问题\n- .npmrc \n- electron_mirror=https://npm.taobao.org/mirrors/electron/\n- nrm 设置为https://registry.npm.taobao.org/\n\n现在安装的话，地址都会变成https://registry.npmmirror.com/binary.html?path=electron/\n(用CNPM/淘宝源的开发者们请注意，淘宝NPM 镜像站喊你切换新域名啦。新的Web 站点：https://npmmirror.com，Registry Endpoint：https://registry.npmmirror.com。随着新的域名已经正式启用，老 http://npm.taobao.org 和 http://registry.npm.taobao.org 域名将于 2022 年 05 月 31 日零时起停止服务。 )\n"},{"title":"ansible","url":"/2021/06/14/ansible/","content":"> 官网指路：https://www.ansible.com/\n\n- https://docs.ansible.com/\nDevops平台: 解决一线研发交付团队的实际问题\nGitlab/Github : 解决配置管理问题 - 代码管理平台\nJenkins： 解决集成打包问题 - 集成与编译系统\n\nAnsible —— 自动化运维管理工具,angentless(不需要在目标机器安装agent进程)\n\n（chef,puppet,salt）\n\n- 安装\n```\nsudo pip install Ansible\n```\n```\nyum install python-pip\npython -m pip --version\npip install --upgrade pip\n```\n\n### 运维老师对sudo版本升级\n\n\n### Fedora - 36\n```\nAnsible is updated to Ansible 5. Playbooks may behave differently. Users are encouraged to read the upstream Porting Guide for further information.\n\nAdditionally, Ansible is now shipped as multiple packages: ansible-core (the engine) and a curated set of Ansible collections (ansible-collection-*). The command dnf install ansible will install ansible-core as well as the Ansible collections included in the upstream Ansible releases. You can also choose to dnf install ansible-core and then manually install collections from the individual packages or with the ansible-galaxy command.\n```"},{"title":"perf","url":"/2021/06/11/perf/","content":"node的项目\n\n监控 && 压测\n客户端监控\n监控和日志，找出问题共性\n\n性能问题排查：\ncpu 负载 —— top\njava 的话，jstack 查看CPU使用率比较高的线程正在执行什么操作\npidstat,vmstat,mpstat查看CPU的运行队列，阻塞进程数，上下文切换的数量\nperf 排查哪些系统调用or操作消耗了更多的CPU时间\njmap dump 出内存信息，使用类似MAT工具来分析，排查内存泄漏问题\npmap ,GDB 查看堆外内存都有哪些数据，排查堆外内存泄漏的问题\n\nperf 对系统内核线程进行分析时，内核线程依然还在正常运行中，所以这种方法也被称为动态追踪技术。\n\n动态追踪技术，通过探针机制，来采集内核或者应用程序的运行信息，从而可以不用修改内核和应用程序的代码，就获得丰富的信息，帮你分析、定位想要排查的问题。\n\nperf 简单的静态跟踪机制; 可以通过 perf ，来自定义动态事件（perf probe），只关注真正感兴趣的事件\n\nMolnar\n\nhttps://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/tools/perf\n\ncentos\nyum install perf\n\nperf top 可以实时查看当前系统进程函数占用率情况\n\n### debug\n```\npython id\n\n获取的都不是真实内存\n\n\nid(object)\nReturn the “identity” of an object. This is an integer which is guaranteed to be unique and constant for this object during its lifetime. Two objects with non-overlapping lifetimes may have the same id() value.\nCPython implementation detail: This is the address of the object in memory.\nRaises an auditing event builtins.id with argument id.\n```\nhttps://medium.com/fhinkel/debug-v8-in-node-js-core-with-gdb-cc753f1f32\n\n\njs取不到的，用chrome的heap snapshot，能看到一个等价的地址，但不是真实的内存地址\n\njs不提供对内存的直接访问，debug工具也只提供到vm的虚拟内存空间，想要取到底层的进程虚拟内存空间，只有用gdb去调试引擎源代码\n\nhttps://www.v2ex.com/t/210556  -  JavaScript 堆内存分析新工具 OneHeap\n\nhttps://v8.dev/docs\n\njavascript heap snapshot\n\nhttps://developers.google.com/web/tools/chrome-devtools/memory-problems/heap-snapshots"},{"title":"wrk","url":"/2021/06/10/wrk/","content":"https://github.com/wg/wrk\n\nbenchmarks \n```\n#!/usr/bin/env bash\n\necho\nMW=$1 USE_ASYNC=$2 node $3 &\npid=$!\n\nsleep 2\n\nwrk 'http://localhost:3333/?foo[bar]=baz' \\\n  -d 3 \\\n  -c 50 \\\n  -t 8 \\\n  | grep 'Requests/sec' \\\n  | awk '{ print \"  \" $2 }'\n\nkill $pid\n\n```\n\n```\nbrew install wrk\nwrk -v\n```"},{"title":"deno","url":"/2021/06/10/deno/","content":"> 项目指路：https://github.com/denoland/deno ； 目前已有76k的star了;\n```\ngit log --format='%aN <%aE>' | sort -u | wc -l    \n660 // 660个贡献者\n```\n- https://burkeholland.dev/deno-first-look/"},{"title":"nodejsWeb应用开发-精读","url":"/2021/06/10/nodejsWeb应用开发-精读/","content":"## Koa:\n项目地址：\nhttps://github.com/koajs/koa\n\n一定要拉代码具体看，很适合看源码\n\n### Koa-源码\n#### Object.create() \nhttps://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create\n```\n// v1.x v2.x都使用了这种方式\nconst response = require('./response');\nconst context = require('./context');\nconst request = require('./request');\n  this.context = Object.create(context);\n  this.request = Object.create(request);\n  this.response = Object.create(response);\n```\n- JavaScript高级程序设计（第4版）_ 原型式继承\n```\n// 警告 Object.setPrototypeOf()可能会严重影响代码性能。\n// Mozilla文档说得很清楚：“在所有浏览器和JavaScript引擎中，修改继承关系的影响都是微妙且深远的。这种影响并不仅是执行Object.setPrototypeOf()语句那么简单，而是会涉及所有访问了那些修改过[[Prototype]]的对象的代码。”\n// 为避免使用Object.setPrototypeOf()可能造成的性能下降，可以通过Object.create()来创建一个新对象，同时为其指定原型\nlet biped = {\n  numLegs: 2\n}\nlet person = Object.create(biped)\nperson.name = 'Matt'\nconsole.log(person.name) // Matt\nconsole.log(person.numLegs) // 2\nconsole.log(person.getPrototypeOf(person) === biped) // true\n// ECMAScript 5通过增加Object.create()方法将原型式继承的概念规范化了。这个方法接收两个参数：作为新对象原型的对象，以及给新对象定义额外属性的对象（第二个可选）。在只有一个参数时，Object.create()与这里的object()方法效果相同\n// 原型式继承非常适合不需要单独创建构造函数，但仍然需要在对象间共享信息的场合。但要记住，属性中包含的引用值始终会在相关对象间共享，跟使用原型模式是一样的。\n```\n\n#### inspect\n```\n// util.inspect.custom support for node 6+\n    /* istanbul ignore else */\n    if (util.inspect.custom) {\n      this[util.inspect.custom] = this.inspect;\n    }\n```\n\n```\n// 看下node源码 v16.3.0 lib/internal/util/inspect.js\n/**\n * Echos the value of any input. Tries to print the value out\n * in the best way possible given the different types.\n *\n * @param {any} value The value to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* Legacy: value, showHidden, depth, colors */\nfunction inspect(value, opts) { ... }\ninspect.custom = customInspectSymbol;\n\n```\n\n#### nodemon\n基本介绍：nodemon用来监视node.js应用程序中的任何更改并自动重启服务\n- https://github.com/remy/nodemon\nnodemon is a tool that helps develop node.js based applications by automatically restarting the node application when file changes in the directory are detected.\n```\n\"dev\": \"./node_modules/.bin/nodemon bin/www\",\n\"prd\": \"pm2 start bin/www\",\n```\n开发阶段，依赖于nodemon监测代码变动，自动重启node.js应用；\n生产环境，通过pm2，cluster模式，按cpu核数启动对应进程数（The cluster mode allows networked Node.js applications (http(s)/tcp/udp server) to be scaled across all CPUs available, without any code modifications.）\nThe cluster module allows easy creation of child processes that all share server ports.\n#### koa-views\n```\n  \"dependencies\": {\n    \"consolidate\": \"0.15.1\",\n    \"debug\": \"^4.1.0\",\n    \"get-paths\": \"0.0.7\",\n    \"koa-send\": \"^5.0.0\",\n    \"mz\": \"^2.4.0\",\n    \"pretty\": \"^2.0.0\"\n  }\n```\n\n\n#### bin/www\n```\nvar server = http.createServer(app.callback());\n// app.js\nmodule.exports = app\n```\n\n#### app.js\n```\n// error handler\n// middlewares\nbodyparser | json | logger | koa-static | koa-views\nkoa-static _ Koa static file serving middleware, wrapper for [`koa-send`](https://github.com/koajs/send).\n// logger\n// routes\n// error-handling\n```\n#### koa-static\n```\napp.use(require('koa-static')(__dirname + '/public'))\n```\n如上，全局使用的\ntips:\nstatic中间件如果放到全局，就会对于每个请求判断一次是不是静态资源，影响QPS；\n1.结合koa-mount使用(Mount `koa-static` to a specific path)\n2.结合koa-router，按需挂载\n```\nrouter.get('/public/*, async (ctx, next) => {\n  ctx.url = path.basename(ctx.url)\n  await next()\n}, static(resolve('./public'), {gzip:true}))\n```\n#### 模版编译\n本身是耗时的，koa-views依赖consolidate提供缓存\n```\n// consolidate.js _ Template engine consolidation library.\n// koa-views\nfunction viewsMiddleware(\n  path,\n  { autoRender = true, engineSource = consolidate, extension = 'html', options = {}, map } = {}\n) ...\nconst render = engineSource[engineName]\n\n// 支持40多个，可以修改extensions\napp.use(views(__dirname + '/views', {\n  extension: 'pug'\n}))\n```\n#### 路由routes\n```\n// routes\napp.use(index.routes(), index.allowedMethods())\napp.use(users.routes(), users.allowedMethods())\n```\n没有指定请求路径\n```\n// koa lib/application.js use 的实现\n  /**\n   * Use the given middleware `fn`.\n   *\n   * Old-style middleware will be converted.\n   *\n   * @param {Function} fn\n   * @return {Application} self\n   * @api public\n   */\n\n  use(fn) {\n    if (typeof fn !== 'function') throw new TypeError('middleware must be a function!');\n    if (isGeneratorFunction(fn)) {\n      deprecate('Support for generators will be removed in v3. ' +\n                'See the documentation for examples of how to convert old middleware ' +\n                'https://github.com/koajs/koa/blob/master/docs/migration.md');\n      fn = convert(fn);\n    }\n    debug('use %s', fn._name || fn.name || '-');\n    this.middleware.push(fn);\n    return this;\n  }\n```\n```\n  \"dependencies\": {\n    \"debug\": \"^3.1.0\",\n    \"http-errors\": \"^1.3.1\",\n    \"koa-compose\": \"^3.0.0\",\n    \"methods\": \"^1.0.1\",\n    \"path-to-regexp\": \"^1.1.1\",\n    \"urijs\": \"^1.19.0\"\n  },\n  // path-to-regexp > Turn an Express-style path string such as `/user/:name` into a regular expression.\n  // 正则路由匹配模块 - 复杂且效率较高\n  // go / fastify(https://github.com/fastify/fastify) - find-my-way 基于基数树radix tree实现\n  // fastify\n  \"requires\": {\n        \"@fastify/ajv-compiler\": \"^1.0.0\",\n        \"abstract-logging\": \"^2.0.0\",\n        \"avvio\": \"^7.1.2\",\n        \"fast-json-stringify\": \"^2.5.2\",\n        \"fastify-error\": \"^0.3.0\",\n        \"fastify-warning\": \"^0.2.0\",\n        \"find-my-way\": \"^4.0.0\",\n        \"flatstr\": \"^1.0.12\",\n        \"light-my-request\": \"^4.2.0\",\n        \"pino\": \"^6.2.1\",\n        \"proxy-addr\": \"^2.0.7\",\n        \"readable-stream\": \"^3.4.0\",\n        \"rfdc\": \"^1.1.4\",\n        \"secure-json-parse\": \"^2.0.0\",\n        \"semver\": \"^7.3.2\",\n        \"tiny-lru\": \"^7.0.0\"\n      }\n    // find-my-way\n    A crazy fast HTTP router, internally uses an highly performant [Radix Tree](https://en.wikipedia.org/wiki/Radix_tree) (aka compact [Prefix Tree](https://en.wikipedia.org/wiki/Trie)), supports route params, wildcards, and it's framework independent.\n\n    If you want to see a benchmark comparison with the most commonly used routers, see [here](https://github.com/delvedor/router-benchmark).<br>\n    Do you need a real-world example that uses this router? Check out [Fastify](https://github.com/fastify/fastify) or [Restify](https://github.com/restify/node-restify).\n```\ntrek-router的基准测试\n\n#### debug\n```\n// 增加配置，针对这个项目 /bin/www\n    {\n      \"type\": \"node\",\n      \"request\": \"launch\",\n      \"name\": \"Launch Program\",\n      \"program\": \"${workspaceRoot}/bin/www\",\n    }\n// 启动调试\n// 打断点\n// 浏览器发起请求 127.0.0.1:3000 触发断点\n```\n\n### 框架演进\nkoa && connect 只提供中间件内核，不内置中间件\nexpress 绑定了必要的基础插件\n#### http\n#### connect（“编程时会区分可变状态和不可变状态，可变的抽取出去，不可变的固化下来。Connect提供了可变部分的插件化，对于Node.js Web应用开发来说，这是演进中必要的一步。” ）\n得考虑中间件的执行顺序\n#### express\napp.listen()\nserver.listen()\n#### koa\nkoa-router | koa-trie-router(快速检索多叉树)\n\n### 测试\n```\nava\n+\nsupertest => express 里经典测http api框架\n```\n-w 支持监控文件变动测试\n```\n    \"test\": \"./node_modules/.bin/ava -v -w\"\n```\n原子性测试:\n因为是ava是并行执行的，如果不加-s参数的话，所以要注意保证原子性\n\n```\n常用模块\nchai \nsinon\nzombie\ncucumber-js\nnightwatch\n```\n\n## 中间件\n\n## 框架介绍\n- https://eggjs.org/zh-cn/intro/index.html\n- 可以看看egg的设计原则\n\n### koa-compose\n- https://www.npmjs.com/package/koa-compose"},{"title":"esbuild-intro","url":"/2021/06/03/esbuild-intro/","content":"### doc\nhttps://github.com/evanw/esbuild\n\n被vite依赖\n\n```\nextremely fast JavaScript bundler\n- esbuild 0.33s\n- parcel 232.48s\n- rollup + terser 34.95s\n- webpack 541.53s\nAbove: the time to do a production bundle of 10 copies of the three.js library from scratch using default settings, including minification and source maps. More info here.\n```\n```\nMajor features:\n\n- Extreme speed without needing a cache\n- ES6 and CommonJS modules\n- Tree shaking of ES6 modules\n- An API for JavaScript and Go\n- TypeScript and JSX syntax\n- Source maps\n- Minification\n- Plugins\n```\n\n### "},{"title":"gitlab集成钉钉","url":"/2021/05/26/gitlab集成钉钉/","content":"- 利用webhook\n\n- 目标：评审comment，merge request，push tag的信息能通知到钉钉群里\n\n- 方法：\n\n1. 钉钉群：\n群主在群设置里面，选择智能群助手，机器人管理里面新增gitlab机器人，然后复制出webhook的地址\n\n2. gitlab:\n在gitlab项目的settings里面，选择intergations,URL即为钉钉里面复制出来的地址，在trigger里面选择需要的触发点，点击 “add webhook”即可\n\nTips:\n1. 如果想要进一步加强控制，可以起个服务，做控制和中转处理\n\n## gitlab 相关\n### changes\n- 2-up | swipe | onion skin "},{"title":"深入理解typescript","url":"/2021/05/25/深入理解typescript/","content":"### 编译原理\n- https://github.com/Microsoft/TypeScript/tree/main/src/compiler\n\n#### 编译流程\nscanner 扫描器（scanner.ts）\nparser 解析器（parser.ts）\nbinder 绑定器（binder.ts）\nchecker 检查器（checker.ts）\nemitter 发射器（emitter.ts）\n\nProgram（在编译开始时创建为一个名为 Program 编译上下文对象）- 帮助判定 AST 节点的语义上下文\nSymbol（Binder 会创建一个用来存储每个 AST 节点和对应符号 Symbol 的映射表）\n\n```\n// 1.解析代码生成AST对象\nSourceCode（源码）with 扫描器 -> Token 流 with 解析器 -> AST\n\n// 2.为AST节点绑定符号\nAST with 绑定器 -> Symbols\n\n// 3.语义检查，类型检查\nAST + Symbols with 检查器 -> 类型验证，语义上下文判断\n\n// 4.代码生成阶段（代码分析不需要关注这个阶段）\nAST + 检查器 with 发射器 -> JavaScript 代码 （无需关注）\n```\n### typescript 代码风格指南与代码约定\n\n## Usage\n- JavaScript - 动态弱类型 - 不会在变量的类型它们的调用者之间建立结构化的契约\n\n- before ES标准（静态类型检查）,TS 是解决问题的最佳方案\n\n- 静态类型检查器: Flow/Hegel（https://github.com/JSMonk/hegel）/Ternjs(2019停止更新-https://github.com/ternjs/tern)\n#### 强类型语言\n- Liskov,Zilles 1974 - 在强类型语言中，当一个对象从调用函数传递到被调用函数时，其类型必须与被调用函数中声明的类型兼容\n- 强类型语言不允许改变变量的数据类型，除非进行强制类型抓换\n- 不允许程序在发生错误后继续执行\n\n\n#### 弱类型语言\n- 变量可以被赋予不同的数据类型\n\n#### 静态 ｜ 动态 类型语言\n- 在什么阶段确定所有变了的类型\n- 编译阶段 ｜ 执行阶段\n\n#### typescript\n- 拥有类型系统的JavaScript的超集\n- 可以编译成pure JavaScript\n- 类型检查｜语言扩展｜工具属性\n\n#### advantage\n- 接口定义代替文档\n- IDE提效（开发）降本（维护）\n- 类型思维\n\n#### ts vs es6 数据类型\n- common - Boolean｜Number｜String|Array|Function|Object|Symbol|undefined|null\n- + void | any | never | 元祖 ｜ 枚举 ｜ 高级类型\n#### 类型注解\n- 相当于强类型语言中的类型声明\n- （变量/函数）:type\n\n#### 枚举\n- 解决if else (可读性和可维护性差的问题)\n- 一组有名字的常量集合\n#### 类与接口\n- interface （implements）class\n- class (extends - public|private|protected) interface\n- class（extends）class\n- interface （extends）interface\n### Class\n#### constructor\n- 见ES6的feature\n- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/constructor\n- 在类构造函数中，不能在调用super()之前引用this - cite  JavaScript高级程序设计（第四版）\n- 如果在派生类中显式定义了构造函数，则要么必须在其中调用super()，要么必须在其中返回一个对象 - cite  JavaScript高级程序设计（第四版）\n- Just as in JavaScript, if you have a base class, you’ll need to call super(); in your constructor body before using any this. members\n```\nconstructor关键字用于在类定义块内部创建类的构造函数。\n方法名constructor会告诉解释器在使用new操作符创建类的新实例时，应该调用这个函数。\n构造函数的定义不是必需的，不定义构造函数相当于将构造函数定义为空函数。 \n- cite  JavaScript高级程序设计（第四版）\n```\n#### TS \n- constructor\n```\n// 可以使用构造器来定义成员变量，即在类中拥有一个成员，并在构造器中初始化它\n// 本写法采用了展开参数的形式，如果需要检查参数或者处理参数，则更合适\nprivate start: number = 0\nprivate end: number = 0\nconstructor(start: number, end: number) {\n  this.start = start\n  this.end = end\n}\n\n// typescript为上面的处理方法提供了一个简写\n// 可以在成员中加一个修饰符前缀，它会在类上自动声明，并且从构造器中复制过去\n// 写法简洁，适用于只是为私有字段赋值的场景；\nconstructor(private start: number, private end: number)\n\n\n```\n#### 把类当做接口使用\n- 类定义会创建两个东西：类的实例类型和一个构造函数。 因为类可以创建出类型，所以你能够在允许使用接口的地方使用类。\n\n\n> 很多JavaScript框架（特别是React）已经抛弃混入模式，转向了组合模式（把方法提取到独立的类和辅助对象中，然后把它们组合起来，但不使用继承）。这反映了那个众所周知的软件设计原则：“组合胜过继承（composition over inheritance）。”这个设计原则被很多人遵循，在代码设计中能提供极大的灵活性。 __ JavaScript高级程序设计（第四版）\n\n### 联合类型\n- type | type\n- 确保使用typeof检查\n- 如果类型过多，考虑设计上是否可以分解为更小的函数\n\n### 交叉类型\n- 可以让我们安全的使用extends 模式\n- 适用于类，接口，泛型和基本类型\n\n### 类型别名\n- 语法技巧，提高代码可读性\n- 大型项目，提高代码一致性\n```\ntype Flags = PatchFlags | ShapeFlags\n```\n### ...\n- 使用展开运算符，可以对一个或多个输入类型的属性自动执行浅拷贝\n- 解构对象 - rest\n- rest参数 ｜ rest属性\n\n### 装饰器 && AOP\n\n### Mixin\n\n#### 泛型\n- 不预先确定的数据类型，具体的类型在使用的时候才能确定\n- 将相同的代码用于不同的类型\n- String Stack, Number Stack ... ?\n- TypeScript提供了创建泛型的能力\n- 泛型是一种类型，通过占位符来代表要使用的类型\n- 具体使用什么类型，要由调用该泛型的代码决定。泛型包含在< >内，出现在类名、方法名等的后面\n- <T>语法告诉TypeScript，这个类中任何地方出现的T都指代传入的类型\n- 当我们为泛型指定类型后，TypeScript会限制其不能改变\n\n#### 泛型优势\n- 可扩展性-函数或类可以轻松支持多种数据类型\n- 可读性 - 不用写多条函数重载｜冗长的联合类型声明\n- 灵活控制类型之间的约束\n\n#### 泛型约束\n\n#### 类型检查机制\n- TypeScript在做类型检查时，秉承的原则及表现出的行为\n- 作用（提高开发效率）\n- 类型推断（基础｜最佳通用｜上下文）\n- 类型兼容性（当一个类型A可以被赋值给另一个类型B的时候，我们可以说B兼容A）（B兼容A： B = A ）（结构之间兼容-成员少的兼容成员多的；函数之间兼容-参数多的兼容参数少的）\n- 类型保护（typescript能够在特定区块中保证变量属于某种确定的类型，可以在此区块中放心引用此类型的属性，或者调用此类型的方法）\n\n### 映射\n- 映射是一个泛型类，接受两种类型：为映射使用的键的类型，以及在映射中存储的对象的类型\n- Map - get | set\n\n## 工程\n- typescript模块解析策略（classic｜node）\n- awesome-typescirpt-loader(比ts-loader更适合与babel集成，使用babel的转义和缓存；不需要安装额外的插件，就可以把类型检查放在独立进程中进行）\n#### babel\n- babel7\n- 之前和之后是两个处理路径\n```\nts - tsc - js - babel - js\nts - babel - js (tsc - type checking)\n```\n#### 工具选择\n- 1.tsc + ts-loader\n- 2.babel + @babel/preset-typescript(可配合tsc做类型检查)\n- 1.2不要混用\n\n#### tslint vs eslint\n- typescript官方转eslint\n- why : 1.tslint执行规则的方式存在一些架构问题，从而影响了性能，而修复这些问题会破坏现有的规则 2.eslint的性能更好，并且社区用户通常有eslint的配置规则（Vue|react），没有tslint的规则\n- typescript（类型检查｜语言转换｜语法错误）\n- eslint(代码风格｜语法错误)\n\n#### babel-eslint vs typescript-eslint\n- 两者底层机制不一样，不要一起使用；babel体系使用babel-eslint,否则可以使用typescript-eslint\n- babel-eslint支持typescript没有额外的语法检查，抛弃typescript，不支持类型检查\n- typescript-eslint基于typescript的AST，支持创建基于类型信息的规则（tsconfig.json）\n\n#### 工具体系\n- 编译工具（ts-loader | @babel/preset-typescript）\n- 代码检查工具（eslint+typescript-eslint | babel-eslint）\n- 单元测试工具（ts-jest | babel-jest）"},{"title":"mongodb进阶与实战-精读","url":"/2021/05/25/mongodb进阶与实战-精读/","content":"## 入门\n\n### 系统-分层来描述现实中的模型\n  - 物理层-存储介质 ｜ 操作系统/FS-文件系统EXT4/XFS ｜ 数据库-数据表/行/文档 ｜ 应用程序-类/对象\n  - 自下而上，上层用更简单易表述的模型来隐藏下层的复杂性\n  - 数据库系统屏蔽来磁盘文件的存取压缩细节，给应用程序展示了一些通用的数据模型\n  - 处理SQL数据模型 - ORM框架（hibernate等）\n  - 基于JSON的文档模型更契合面向对象的设计准则\n\n### BSON（一种二进制版本的JSON扩展）\n  - 易用性扩展（增加日期，二进制的支持）\n\n### 动态模式\n  - 所有读写都是基于一种内部隐含的模式，模式采取按需变更而非提前声明\n\n### Feature\n#### 完备的索引\n- 设计思路和一般关系型数据库差不多\n- 特殊应用场景支持：地理空间，文本检索，TTL\n#### 跨平台\n- C++ write\n- 3.4之后不再支持32-bit X86\n- 提供了多种语言实现的驱动-Java/C/C++/C#/Python/NodeJS\n\n#### aggregation很强大\n- 以文档化模型为基础设计，适合非结构化数据\n- pipline/stage\n\n#### replication set 副本集\n- 类似MySQL的Master/Slave复制架构\n- 海量数据处理-原生支持分布式计算能力\n\n### Advantage\n#### 易用\n- 变更文档结构无需执行DDL变更语句，方便业务平滑升级\n\n#### 高性能\n- 3.0-WiredTiger存储引擎（基于内存的二级缓存提供了高速读取数据的能力，根据磁盘I/O特点做了缓冲式写入）\n\n#### 高可靠\n- 单个MongoDB节点-开启Journal机制实现断电保护\n- 集群节点-副本集架构（节点宕机，秒级切换）\n\n#### 高可扩展\n- 分片的集群架构\n\n#### 社区支持\n\n### Difficult\n- 关系型数据库思维转变，关注段放在系统未来的扩展能力，专注做好表设计，访问模式和性能的权衡\n- 事务-4.0之后支持（一致性要求高-金融交易类）\n\n### 类比SQL模型\n#### 类比\ndatabase（数据库）- 逻辑上名称的空间\ncollection （集合） - SQL中的表\ndocument（文档）- 相当于数据表中的一行\nfield（字段）- 文档中的一个属性，相当于column（列）\nindex（索引）- 独立的检索式数据结构\n_id - 相当于SQL中的primary key\nview（视图） - 看作虚拟的集合，3.4版本中开始提供，通过聚合管道技术实现\n$lookup（聚合操作）- 类似table join表链接的聚合操作符\n\n#### 差异\n- 半结构化（用的字段无需声明，支持多级嵌套，数组等灵活的数据类型）+弱关系（没有外键约束，也没有强大的表连接能力）\n\n#### 类SQL语句\n- ANSQL\n\n## 安装\n#### 包含的二进制程序\n- mongod-数据库服务启动程序\n- mongo-数据库客户端shell程序\n- mongostat-数据库性能监控工具\n- mongotop-热点表监控工具\n- mongodump-数据库逻辑备份工具\n- mongorestore-数据库逻辑恢复工具\n- mongoexport-数据库导出工具\n- mongoimport-数据库导入工具\n- bsondump-BSON格式转换工具\n- mongofiles-GridFS文件工具\n\n### mongo shell\n- mongodb是用来SpiderMonkey作为内部JavaScript引擎,3.2之前用的V8\n- --eval 非交互式\n\n\n## 操作\n可见另外一篇博文 - mongodb\n\n\n### 卸载\n```\nservice mongod stop\nyum erase $(rpm -qa | grep mongodb-org)\nrm -rf /var/log/mongodb\nrm -rf /var/lib/mongo\n```"},{"title":"系统之美-精读","url":"/2021/05/24/系统之美-精读/"},{"title":"第一本docker书-精读","url":"/2021/05/24/第一本docker书-精读/","content":"\n## docker hub 镜像加速\n- https://y0ngb1n.github.io/a/docker-registry-mirrors.html?js\n\n### history\n\n- 容器技术 - Linux的进程模型对于容器本身的重要意义； “控制器”模型对Kubernetes的作用\n- PasS - 提供了一套应用打包的功能 - 帮助用户大规模部署应用到集群里 - 但是也是一个问题\n- Docker 对 PasS，降维打击 -> 因为提供了非常方便的打包机制，直接打包了系统，保证了本地和云端环境的一致，减少“试错”成本\n- Fig 项目 - container orchestration - 容器编排\n- OCI -  将容器运行时和镜像的实现从Docker项目中剥离出来\n- CoreOS - Etcd\n- Docker公司 - 将开源项目和商业产品绑定 - 技术生态的封闭\n- Kubernetes - 开发者为核心 - 民主开放的容器生态\n\n### docker desktop\n- 可以帮助熟悉指令对应的操作，有个可视化的平台"},{"title":"重构-改善既有代码的设计-精读","url":"/2021/05/24/重构-改善既有代码的设计-精读/","content":"第 1 章　重构，第 一个示例 1\n1．1　起点 1\n1．2　对此起始程序的评价 3\n1．3　重构的第 一步 5\n1．4　分解statement 函数 6\n1．5　进展：大量嵌套函数 22\n1．6　拆分计算阶段与格式化阶段 24\n1．7　进展：分离到两个文件（和两个阶段） 31\n1．8　按类型重组计算过程 34\n1．9　进展：使用多态计算器来提供数据 41\n1．10　结语 43\n第 2 章　重构的原则 45\n2．1　何谓重构 45\n2．2　两顶帽子 46\n2．3　为何重构 47\n2．4　何时重构 50\n2．5　重构的挑战 55\n2．6　重构、架构和YAGNI 62\n2．7　重构与软件开发过程 63\n2．8　重构与性能 64\n2．9　重构起源何处 67\n2．10　自动化重构 68\n2．11　延展阅读 70\n第3 章　代码的坏味道 71\n3．1　神秘命名（Mysterious Name） 72\n3．2　重复代码（Duplicated Code） 72\n3．3　过长函数（Long Function） 73\n3．4　过长参数列表（Long Parameter List） 74\n3．5　全局数据（Global Data） 74\n3．6　可变数据（Mutable Data） 75\n3．7　发散式变化（Divergent Change） 76\n3．8　霰弹式修改（Shotgun Surgery） 76\n3．9　依恋情结（Feature Envy） 77\n3．10　数据泥团（Data Clumps） 78\n3．11　基本类型偏执（Primitive Obsession） 78\n3．12　重复的switch（Repeated Switches） 79\n3．13　循环语句（Loops） 79\n3．14　冗赘的元素（Lazy Element） 80\n3．15　夸夸其谈通用性（Speculative Generality） 80\n3．16　临时字段（Temporary Field） 80\n3．17　过长的消息链（Message Chains） 81\n3．18　中间人（Middle Man） 81\n3．19　内幕交易（Insider Trading） 82\n3．20　过大的类（Large Class） 82\n3．21　异曲同工的类（Alternative Classes with Different Interfaces） 83\n3．22　纯数据类（Data Class） 83\n3．23　被拒绝的遗赠（Refused Bequest） 83\n3．24　注释（Comments） 84\n第4 章　构筑测试体系 85\n4．1　自测试代码的价值 85\n4．2　待测试的示例代码 87\n4．3　第 一个测试 90\n4．4　再添加一个测试 93\n4．5　修改测试夹具 95\n4．6　探测边界条件 96\n4．7　测试远不止如此 99\n第5 章　介绍重构名录 101\n5．1　重构的记录格式 101\n5．2　挑选重构的依据 102\n第6 章　第 一组重构 105\n6．1　提炼函数（Extract Function） 106\n6．2　内联函数（Inline Function） 115\n6．3　提炼变量（Extract Variable） 119\n6．4　内联变量（Inline Variable） 123\n6．5　改变函数声明（Change Function Declaration） 124\n6．6　封装变量（Encapsulate Variable） 132\n6．7　变量改名（Rename Variable） 137\n6．8　引入参数对象（Introduce Parameter Object） 140\n6．9　函数组合成类（Combine Functions into Class） 144\n6．10　函数组合成变换（Combine Functions into Transform） 149\n6．11　拆分阶段（Split Phase） 154\n第7 章　封装 161\n7．1　封装记录（Encapsulate Record） 162\n7．2　封装集合（Encapsulate Collection） 170\n7．3　以对象取代基本类型（Replace Primitive with Object） 174\n7．4　以查询取代临时变量（Replace Temp with Query） 178\n7．5　提炼类（Extract Class） 182\n7．6　内联类（Inline Class） 186\n7．7　隐藏委托关系（Hide Delegate） 189\n7．8　移除中间人（Remove Middle Man） 192\n7．9　替换算法（Substitute Algorithm） 195\n第8 章　搬移特性 197\n8．1　搬移函数（Move Function） 198\n8．2　搬移字段（Move Field） 207\n8．3　搬移语句到函数（Move Statements into Function） 213\n8．4　搬移语句到调用者（Move Statements to Callers） 217\n8．5　以函数调用取代内联代码（Replace Inline Code with Function Call） 222\n8．6　移动语句（Slide Statements） 223\n8．7　拆分循环（Split Loop） 227\n8．8　以管道取代循环（Replace Loop with Pipeline） 231\n8．9　移除死代码（Remove Dead Code） 237\n第9 章　重新组织数据 239\n9．1　拆分变量（Split Variable） 240\n9．2　字段改名（Rename Field） 244\n9．3　以查询取代派生变量（Replace Derived Variable with Query） 248\n9．4　将引用对象改为值对象（Change Reference to Value） 252\n9．5　将值对象改为引用对象（Change Value to Reference） 256\n第 10 章　简化条件逻辑 259\n10．1　分解条件表达式（Decompose Conditional） 260\n10．2　合并条件表达式（Consolidate Conditional Expression） 263\n10．3　以卫语句取代嵌套条件表达式（Replace Nested Conditional with Guard Clauses） 266\n10．4　以多态取代条件表达式（Replace Conditional with Polymorphism） 272\n10．5　引入特例（Introduce Special Case） 289\n10．6　引入断言（Introduce Assertion） 302\n第 11 章　重构API 305\n11．1　将查询函数和修改函数分离（Separate Query from Modifier） 306\n11．2　函数参数化（Parameterize Function） 310\n11．3　移除标记参数（Remove Flag Argument） 314\n11．4　保持对象完整（Preserve Whole Object） 319\n11．5　以查询取代参数（Replace Parameter with Query） 324\n11．6　以参数取代查询（Replace Query with Parameter） 327\n11．7　移除设值函数（Remove Setting Method） 331\n11．8　以工厂函数取代构造函数（Replace Constructor with Factory Function） 334\n11．9　以命令取代函数（Replace Function with Command） 337\n11．10　以函数取代命令（Replace Command with Function） 344\n第 12 章　处理继承关系 349\n12．1　函数上移（Pull Up Method） 350\n12．2　字段上移（Pull Up Field） 353\n12．3　构造函数本体上移（Pull Up Constructor Body） 355\n12．4　函数下移（Push Down Method） 359\n12．5　字段下移（Push Down Field） 361\n12．6　以子类取代类型码（Replace Type Code with Subclasses） 362\n12．7　移除子类（Remove Subclass） 369\n12．8　提炼超类（Extract Superclass） 375\n12．9　折叠继承体系（Collapse Hierarchy） 380\n12．10　以委托取代子类（Replace Subclass with Delegate） 381\n12．11　以委托取代超类（Replace Superclass with Delegate） 399\n\n\n\n- 一个持续不断的过程，过程自动化（高效，高质量）"},{"title":"深入浅出Vuejs-精读","url":"/2021/05/24/深入浅出Vuejs-精读/","content":"## 序\n是我很喜欢的月影和松峰老师作序\n月影老师序：\n\"所谓元编程，简单来说，是指框架的作者使用一种编程语言固有的语言特性，创造出相对新的语言特性，使得最终使用者能够以新的语法和语义来构建他们的应用程序，从而在某些领域开发中获得更好的开发体验。\"\n\"jQuery仅仅通过巧妙设计API就能支持上述特性(链式语法和隐式迭代语义)，并不依赖于编程语言赋予的元编程能力\"\n\"JavaScript自身提供了许多元编程特性，比如从ES5就开始支持的属性访问器（property accessor），ES6支持的代理（proxy），还有标准提案已经处于Stage 3阶段的装饰器（decorator）\"\n\"如何设计API和如何使用元编程思想将新特性融入到框架中，是现代JavaScript框架设计的两个核心，Vue.js更侧重于后者\"\n要考虑的细节：\n- 向下兼容\n- 性能\n学习Vue.js，掌握设计应用程序框架的一般性技巧，还可以在实现应用程序时运用其中的具体设计思想和方法论。\n松峰老师序：\n\"当时我说，要想让技术书畅销，一是读者定位必须是新手，因为新手人数众多；二是要注重实用，书中的例子最好能立即照搬到项目上。\"\n\n## 前言\n\"Vue.js也是如此，它解决了什么问题？如何解决的？解决问题的同时都做了哪些权衡和取舍？\"\n\n- DOM操作 - 命令式 => 声明式\n- 渐进式 - Vue.js / +router / +vuex / +vue-cli\n  - Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架\n  - 渐进式框架 - 把框架分层 - 核心是视图层渲染 + 组件机制 + 路由机制 + 状态管理 + 构建工具\n- 单文件组件 - 很棒的一个feature（https://cn.vuejs.org/v2/guide/single-file-components.html）\n- The fate of destruction is also the joy of rebirth - 1.x\n- Your effort to remain what your are is what limits you - 2.x - Masamune Shirow, Ghost in the Shell\n  - 引入虚拟DOM\n  - 支持JSX和TS\n  - 支持流式服务端渲染\n  - 提供跨平台能力\n- Just a view layer library（Vue 的核心库只关注视图层）\n- 关于Vue.js\n  - 学习曲线和API设计 - 优雅，简单 -> 竞争力\n  - Chrome开发者插件使用情况\n  - 社区 - Nuxt,Quasar Framework, Element,iView,Muse-UI,Vux,Vuetify,Vue Material\n\n## 变化侦测\n> 理解原理帮助我们规避问题\n- reactive(feature)\n"},{"title":"nodejs来一打C++扩展-精读","url":"/2021/05/13/nodejs来一打C-扩展-精读/","content":"> nodejs来一打C++扩展-死月\n\n\n- Node.js 的模块机制\n  - CommonJS 的模块规范\n  - Node.js 的模块\n- Node.js 的包机制\n  - CommonJS 的包规范\n  - Node.js / NPM 下的包\n- NPM 与 CNPM(cnpm: npm client for China mirror of npm registry.npmmirror.com)\n- Node.js 依赖\n  - Chrome V8\n  - libuv\n  - 其他依赖\n- C++ 扩展开发的准备工作\n  - 编辑器 / IDE\n  - node-gyp (https://github.com/nodejs/node-gyp#installation)\n  - 其他构建工具\n- C++ 模块原理简析\n- 为什么要写 C++ 模块\n  - C++ 比 JavaScript 解释器高效\n  - 已有的 C++ 轮子\n- 什么是 C++ 扩展\n  - C++ 模块本质\n  - Node.js 模块加载原理\n- Chrome V8 基础\n  - Node.js 与 Chrome V8\n  - 基本概念(内存机制,隔离实例（Isolate）,上下文（Context）,脚本（Script）)\n  - 句柄（Handle）(本地句柄（Local）持久句柄（Persistent）永生句柄（Eternal）待实本地句柄（Maybe Local）)\n  - 句柄作用域(一般句柄作用域（Handle Scope）可逃句柄作用域（Escapable Handle Scope）)\n  - 上下文（Context）\n  - 模板（Template）\n  - 函数模板（Function Template）\n  - 对象模板（Object Template）\n  - 对象模板的访问器（Accessor）与拦截器（Interceptor）\n  - 对象模板的内置字段（Internal Field）\n  - 函数模板的继承（Inherit）\n  - 常用数据类型 \n  - 基值（Value） \n  - 字符串（String）\n  - 数值类型\n  - 布尔类型（Boolean）\n  - 对象（Object）\n  - 函数(Function)\n  - 数组（Array）\n  - JSON 解析器\n  - 函数回调信息（Function Callback Info）\n  - 函数返回值（Return Value）\n  - 隔离实例(Isolate)\n  - 异常机制\n  - try-catch\n  - 抛出异常\n  - 异常生成类（Exception）\n- C++ 扩展实战初探\n  - binding.gyp\n  - 惊鸿一瞥\n  - binding.gyp 基础结构\n  - GYP 文件\n  - 常用字段\n  - 牛刀小试\n  - 又是 Hello World\n  - 函数参数\n  - 回调函数\n  - 函数返回\n  - 循序渐进\n  - C++ 与 JavaScript 类封装\n  - 实例化 C++ 类封装对象的函数\n  - 将 C++ 类封装对象传来传去\n  - 进程退出钩子\n- Node.js 原生抽象——NAN\n  - Node.js 原生模块开发方式的变迁\n    - 以不变应万变\n    - 时代在召唤\n  - 基础开发\n    - 什么是 NAN\n    - 安装和配置\n    - 先睹为快——搭上NAN 的快车\n    - 基础帮助函数和宏\n    - 忽略 node_modules\n  - JavaScript 函数\n    - 函数参数类型\n    - 函数声明\n    - 函数设置\n  - 常用帮助类与函数\n    - 句柄相关\n    - 创建数据对象\n    - 与数据对象“玩耍”\n    - 封装一个类\n    - 异常处理\n  - NAN 中的异步机制\n    - Nan::AsyncQueueWorker\n    - Nan::Callback\n    - Nan::AsyncWorker\n    - Nan::AsyncProgressWorker\n- 异步之旅——libuv\n  - 基础概念\n    - 事件循环\n    - 句柄（Handle）与请求（Request）\n    - 尝尝甜头\n  - libuv 的跨线程编程基础\n    - libuv 的线程\n    - 同步原语（Synchronization Primitive）\n    - 工作队列\n  - 跨线程通信\n    - uv_async_t 句柄\n    - Watchdog 半成品实战解析\n    - Watchdog 试运行\n- 实战——文件监视器\n  - 准备工作\n    - 功能规划\n    - 文件系统监听库——efsw\n  - 核心设计\n    - API 设计\n    - EFSWCore 的血肉之躯\n    - EFSWCore 的灵魂\n  - 编写JavaScript 类\n    - 类的设计\n    - 核心逻辑\n    - 简单容错\n  - 进一步完善\n    - C++ 代码的完善\n    - JavaScript 代码的完善\n- 实战——现有包剖析\n  - 字符串哈希模块——Bling Hashes\n    - 文件设定\n    - C++ 源码剖析\n    - JavaScript 源码剖析\n  - 类 Proxy 包——Auto Object\n    - Proxy\n    - Auto Object 使用范例\n    - 代码剖析\n- N-API——下一代 Node.js C++ 扩展开发方式\n  - 浅尝辄止\n    - 实现一个 Echo 函数\n    - 尝试运行 N-API 扩展\n    - 向下兼容\n    - N-API Package——C++ 封装\n  - 基本数据类型与错误处理\n    - 基本数据类型\n    - 与作用域及生命周期相关的数据类型\n    - 回调数据类型\n    - 错误处理\n    - 模块注册\n  - 对象与函数\n    - 对象\n    - 函数\n    - 类的封装\n\n.cc和.cpp都是C++源文件的扩展名，它们在功能上是没有区别的，都是用于存放C++编程代码。\n\n这两种扩展名的使用主要取决于开发者的习惯或者团队的命名规范，以及所使用的编译器和开发环境。比如，GNU的C++编译器（g++）默认的源文件扩展名是.cc，而在很多Windows开发环境中，如Visual Studio，默认的扩展名是.cpp。\n\n无论使用.cc还是.cpp，都不会影响源代码的编译和运行。一个比较好的实践就是在一个项目或者团队内部保持一致的命名规范，这样可以帮助提高代码的可读性和可维护性。\n\nhttps://www.npmjs.com/package/node-addon-api\n\nNode-addon-api和N-API是 Node.js 在尝试链接到C++代码时使用的工具集。\n\n1. N-API：N-API是Node.js运行时提供的预构建的API，它能直接在JavaScript中调用，且无需重新编译，即使是在不同版本的Node.js上也可以使用。N-API的设计目标是消除在Node.js生态系统中的第三方扩展插件的维护负担和碎片化问题。通过这种方式，本地模块可以在不同版本和可能在未来的Node.js中无缝运行。\n\n2. Node-addon-api：Node-addon-api是N-API的包装器，它是一个更高级别、更易于使用的API，其基于C++，提供了针对N-API的面向对象的抽象。 在大多数情况下，你会使用这个比N-API更高阶的 API, 因为它更易于构建和管理代码。\n\nN-API的目标是提供稳定的Node API用于本地插件，而不受底层JavaScript运行时的改变影响，并且它对所有Node.js LTS版本提供支持。而Node-addon-api是为了简化C++版本的N-API的使用，提供了更友好和简洁的API。"},{"title":"接口设计","url":"/2021/05/08/接口设计/","content":"> 参考资料：阿里Java手册\n\n\n### 目标：设计方+调用方（理解一致）\n\n#### 接口的响应 => 明确表示接口的处理结果\n- 对外隐藏内部实现\n- \n\n## 网络异常\n- 基于whistle可以模拟接口异常，从而做一些兼容处理\n- https://segmentfault.com/a/1190000017525152"},{"title":"近期书籍阅读","url":"/2021/05/06/近期书籍阅读/","content":"> 持续更新中，工作相关的一些书籍，几句summary能说的说\n\n# A\n亚马逊unlimit会员免费的几本相关的书，书都比较老一点，13年到16年之间的\n\n## 超实用的node.js代码段\nbias:一般起这种名字的，基本上拼拼凑凑翻翻译译\n一看：果然如此\n书本身比较老了，15年出的，基于的node版本还是0.x的\n1.控制台模块应用\n2.\n\n## 编程大师访谈录\n\n\n# B - 英文相关\n## word power made easy\n- 笔记见 longman-expressions-and-words\n\n\n\n## blog\n- https://juejin.cn/team/6932010947578069006/posts - 网易云音乐  - juejin"},{"title":"ssh配置","url":"/2021/05/05/ssh配置/","content":"## ssh连接问题\nssh之后连接会断，可以在服务器上面做配置：\n```\nvim /etc/ssh/sshd_config\nClientAliveInterval 60\nClientAliveCountMax 60\n\nsystemctl restart sshd\n```\n\n客户端配置：\n```\nvim /etc/ssh/ssh_config\nServerAliveInterval 60\n```\n\nTIPS:\nsystemctl | service 命令\n\n华为云服务的帮助文档：\nhttps://support.huaweicloud.com/trouble-ecs/ecs_trouble_0306.html\n\nInit System\n\nTo run and manage your mongod process, you will be using your operating system’s built-in init system. Recent versions of Linux tend to use systemd (which uses the systemctl command), while older versions of Linux tend to use System V init (which uses the service command).\n\nIf you are unsure which init system your platform uses, run the following command:\n\nps --no-headers -o comm 1\n\nThen select the appropriate tab below based on the result:\n\nsystemd - select the systemd (systemctl) tab below.\ninit - select the System V Init (service) tab below.\n\n## 使用SSH连接到Github\n\n### github文档指南\nhttps://docs.github.com/cn/github/authenticating-to-github/connecting-to-github-with-ssh/about-ssh\n\n这个文档强烈推荐，对于项目管理中的问题，给出了建议和最佳实践指南；可以当作解决问题的参考手册；\n\n\n## screen和tmux实现会话恢复的机制\n\n\n\n## 后台运行进程\n`nohup`和`&`都是在Linux系统下用来在后台运行进程的工具，但他们的运行方式和具体功能有所不同。\n\n**&**：\n\n- `&` 是一个shell的内建命令，用来把命令放到后台执行。例如“command &”，该命令将在后台运行。\n- 如果你在命令行中执行一个程序，然后你关闭该命令行，这个程序会立即停止。如果你用 `&` 把这个程序放入后台，这个程序会继续在你的控制领域之下运行，直到完成。\n\n**nohup**：\n\n- `nohup` 是一个非内建命令，它不依赖于shell，即使shell终结也可以继续执行。\n- 如果你将一个程序用 `nohup` 和 `&` 运行，“nohup command &”，该命令就可以忽略所有来自shell的挂断（HUP）信号。即使你退出了shell，该命令也会在后台继续运行，直到完成。\n- 它还会把标准输出和标准错误输出重定向到名为 nohup.out 的文件中，因此不会因为关闭Shell会话而丢失信息。\n\n所以，`nohup`和`&`的主要区别在于，`nohup`保护进程不受Shell会话结束影响（甚至在用户注销之后也可以继续运行）,而 `&` 则只是简单地将进程放到后台运行。"},{"title":"node-项目应用","url":"/2021/04/30/node-项目应用/","content":"\n> 事件驱动学习; 很多东西，不同阶段再去听去看，会有不同收获，因为基础认知不同，才能理解到一些细节\n### 三句basic 说明\n- Node.js® is a JavaScript runtime built on Chrome's V8 JavaScript engine.\n- As an asynchronous event-driven JavaScript runtime, Node.js is designed to build scalable network applications. \n- Almost no function in Node.js directly performs I/O, so the process never blocks except when the I/O is performed using synchronous methods of Node.js standard library. \n\n### usage\n- web应用场景\n- SSR-搜索引擎优化，首屏速度\n- 前后端同构（PDF预览打印场景\n```\n前后端同构\n浏览器端 && nodejs端 => 同构代码\nReactDomServer.renderToString()\nVueServerRenderer.renderToString()\nR&V最大难题在于数据部分\n\n同构的core\n- 注重职责分离\n\n```\n- 构建工具（早期的 gulp,webpack，后面不用说了，奏是这个生态）\n- Backend for Frontend(HTTP, RPC调用)\n## basic\n\n### global\n- https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame\n- setImmediate\n\n### __filename | __dirname\n### Err\n#### EMFILE - Too many open files\n\n### Process\n- argv\n- env\n- kill \n- exit\n- hrtime\n- cpuUsage\n- memoryUsage\n\n### Module\n#### browser\n- <script />\n- 脚本加载顺序 \n- 脚本之间逻辑调用，借助全局变量\n\n#### commonJS\n- 也影响了browser端\n\n\n#### Doc\n- http://nodejs.cn/api/process.html\n#### Details\n- process 对象是 EventEmitter 的实例\n- doc\n```\n'beforeExit' 事件#\n中英对照\n\n新增于: v0.11.12\n当 Node.js 清空其事件循环并且没有额外的工作要安排时，则会触发 'beforeExit' 事件。 通常情况下，当没有工作要调度时，Node.js 进程会退出，但是注册在 'beforeExit' 事件上的监听器可以进行异步的调用，从而使 Node.js 进程继续。\n\n调用监听器回调函数时将 process.exitCode 的值作为唯一的参数传入。\n\n对于导致显式终止的条件，例如调用 process.exit() 或未捕获的异常，则不会触发 'beforeExit' 事件。\n\n'beforeExit' 不应用作 'exit' 事件的替代，除非打算安排额外的工作。\n\nimport process from 'process';\n\nprocess.on('beforeExit', (code) => {\n  console.log('Process beforeExit event with code: ', code);\n});\n\nprocess.on('exit', (code) => {\n  console.log('Process exit event with code: ', code);\n});\n\nconsole.log('This message is displayed first.');\n\n// 打印:\n// This message is displayed first.\n// Process beforeExit event with code: 0\n// Process exit event with code: 0\n```\n\n```\n'exit' 事件#\n中英对照\n\n新增于: v0.1.7\ncode <integer>\n当 Node.js 进程由于以下任一原因即将退出时，则会触发 'exit' 事件：\n\nprocess.exit() 方法被显式调用；\nNode.js 事件循环不再需要执行任何额外的工作。\n此时没有办法阻止事件循环的退出，一旦所有 'exit' 监听器都运行完毕，则 Node.js 进程将终止。\n\n监听器回调函数使用 process.exitCode 属性指定的退出码或传给 process.exit() 方法的 exitCode 参数调用。\n\nimport process from 'process';\n\nprocess.on('exit', (code) => {\n  console.log(`About to exit with code: ${code}`);\n});\n监听器函数必须只执行同步的操作。 Node.js 进程将在调用 'exit' 事件监听器之后立即退出，从而使任何仍在事件循环中排队的其他工作被丢弃。 例如，在以下示例中，超时永远不会发生：\n\nimport process from 'process';\n\nprocess.on('exit', (code) => {\n  setTimeout(() => {\n    console.log('This will not run');\n  }, 0);\n});\n```\n```\n- SIGINT       P1990      Term    Interrupt from keyboard\n- https://man7.org/linux/man-pages/man7/signal.7.html\n\n信号事件#\n中英对照\n\n当 Node.js 进程收到信号时，则将触发信号事件。 有关标准 POSIX 信号名称（例如 'SIGINT'、'SIGHUP' 等）的列表，请参阅 signal(7)。\n\n信号在 Worker 线程上不可用。\n\n信号句柄将接收信号的名称（'SIGINT'、'SIGTERM' 等）作为第一个参数。\n\n每个事件的名称将是信号的大写通用名称（例如 'SIGINT' 表示 SIGINT 信号）。\n\nimport process from 'process';\n\n// 从标准输入开始读取，因此进程不会退出。\nprocess.stdin.resume();\n\nprocess.on('SIGINT', () => {\n  console.log('Received SIGINT. Press Control-D to exit.');\n});\n\n// 使用单个函数处理多个信号\nfunction handle(signal) {\n  console.log(`Received ${signal}`);\n}\n\nprocess.on('SIGINT', handle);\nprocess.on('SIGTERM', handle);\n'SIGUSR1' 由 Node.js 预留以启动调试器。 可以安装监听器，但这样做可能会干扰调试器。\n'SIGTERM' 和 'SIGINT' 在非 Windows 平台上具有默认的句柄，其在使用代码 128 + signal number 退出之前重置终端模式。 如果这些信号之一安装了监听器，则其默认行为将被删除（Node.js 将不再退出）。\n'SIGPIPE' 默认情况下忽略。 它可以安装监听器。\n'SIGHUP' 在 Windows 上是在关闭控制台窗口时生成，在其他平台上是在各种类似条件下生成。 参见 signal(7)。 它可以安装监听器，但是 Node.js 将在大约 10 秒后被 Windows 无条件地终止。 在非 Windows 平台上，SIGHUP 的默认行为是终止 Node.js，但一旦安装了监听器，则其默认行为将被删除。\n'SIGTERM' Windows 上不支持，可以监听。\n所有平台都支持来自终端的 'SIGINT'，通常可以使用 Ctrl+C 生成（但是这是可配置的）。 当启用终端原始模式并使用 Ctrl+C 时不会生成它。\n'SIGBREAK' 在 Windows 上，当按下 Ctrl+Break 时会发送。 在非 Windows 平台上，它可以被监听，但无法发送或生成它。\n'SIGWINCH' 当调整控制台大小时会发送。 在 Windows 上，这只会发生在当光标移动时写入控制台，或者当在原始模式下使用可读的终端时。\n'SIGKILL' 不能安装监听器，它会无条件地终止所有平台上的 Node.js。\n'SIGSTOP' 不能安装监听器。\n'SIGBUS'、'SIGFPE'、'SIGSEGV' 和 'SIGILL'，当没有使用 kill(2) 人为引发时，本质上会使进程处于调用 JS 监听器不安全的状态。 这样做可能会导致进程停止响应。\n0 可以发送来测试进程是否存在，如果进程存在则没影响，如果进程不存在则抛出错误。\nWindows 不支持信号，因此没有等价的使用信号来终止，但 Node.js 提供了一些对 process.kill() 和 subprocess.kill() 的模拟：\n\n发送 SIGINT、SIGTERM、和 SIGKILL 会导致目标进程无条件的终止，之后子进程会报告进程被信号终止。\n发送信号 0 可以作为独立于平台的方式来测试进程是否存在。\n\n\n```\n\n\n## recommend\n- https://zhuanlan.zhihu.com/p/101917567 - 语雀\n\n### chalk\n- https://www.npmjs.com/package/chalk\n- 调试时候可以用，这样比较显眼\n\n### 网关\n- https://mp.weixin.qq.com/s/nWKCX1INkP7uKGONzW7CPg\n- 大规模 Node.js 网关的架构设计与工程实践\n\n### 服务间接口调用\n- consul 测试环境 ip+端口号\n- cluster IP + 80 线上环境\n- 没有用域名做代理，当然会存在cluster ip更换的问题，不过相对稳定\n- \n\n### windows \n系统属性里面的环境变量设置\n\n## node - test框架推荐\n- ava这个框架\n\n## preventing-sql-injection-in-node-js\n- https://stackoverflow.com/questions/15778572/preventing-sql-injection-in-node-js\n- https://github.com/mysqljs/mysql#escaping-query-values\n\n\n## problems - BFF\n\n\n## cases\n### BFF\n- Java服务提供数据 - RPC通信\n- 模版渲染\n- API服务 - restful（易读，快速启动，数据聚合劣势）- github的v3 API的实现\n- API服务 - GraphQL（专注数据聚合，返回前端需要的）\n\n### config\n- https://github.com/node-config/node-config\n- https://www.npmjs.com/package/yaml\n- package.json - config - process.env.npm_package_config_port - npm config set aaa:xxx 80\n\n\n### 钩子\n- 在node_modules/.hooks/{eventname}中放置一个可执行文件，所有根目录下的package.json文件在运行到该生命周期节点时都会被执行\n- husky\n\n### 端口冲突问题\n- lsof -i:3000 | xargs killall\n- npm i -g kp  -  kp 3000\n\n### node-demo\n- https://github.com/hua1995116/node-demo\n```\nnode文件上传详解\nnode-rpc调用详解\n跨域 demo\n重拾css[一]伪元素、包含块和高度坍塌\nReact Hooks中这样写HTTP请求可以避免内存泄漏\n```\n\n### node-jiti\n\"Node-jiti\"是一个Node.js库，可在运行时（JIT）转译并加载ECMAScript模块。以下是使用\"node-jiti\"的一些最佳实践：\n\n1. **选择正确的环境**：“node-jiti”是一个在Node.js环境中运行的库，因此你应该确保你的项目是在Node.js环境中运行的。\n\n2. **使用包管理器**： 使用npm或者yarn这种包管理器来安装和管理“node-jiti”，这样可以确保你总是使用最新、最稳定的版本。\n\n3. **适当的错误处理**：“node-jiti”在加载或解析JS文件时可能会出现错误，因此应该适当地使用try...catch语句来处理可能采食的错误。\n\n4. **理解ESM和CJS的区别**：“node-jiti”旨在使那些在运用时还不支持ESM的Node.js版本能够使用ESM，因此你需要对ESM和CJS两种模块系统有所了解。\n\n5. **合理使用动态导入**：“node-jiti”允许你动态地导入JS文件，这是一种有用但需要谨慎使用的工具。因为过度使用动态导入可能会使代码难以理解和保持。\n\n举例：简单的使用 `node-jiti` 加载一个模块：\n\n```javascript\n// 导入 node-jiti\nconst jiti = require('jiti')(__dirname)\n// 使用 node-jiti 加载模块\nconst myModule = jiti('./myModule')\n```\n\n这是一个简单的示例，`jiti` 将加载并处理名为 `myModule.js` 的文件，此文件应该位于您的项目的根目录中。"},{"title":"intro-to-nodejs-精读","url":"/2021/04/30/intro-to-nodejs-精读/","content":"- nvm - 没有permission问题 - 推荐使用这个\n- 我用n(n不支持Windows平台)\n```\nn is supported on macOS, Linux, including with Windows Subsystem for Linux, and various other unix-like systems. It is written as a BASH script but does not require you to use BASH as your command shell.\n\nn does not work in native shells on Microsoft Windows (like PowerShell), or Git for Windows BASH, or with the Cygwin DLL.\n```\n- REPL - 快速验证\n- "},{"title":"JavaScript引擎V8-精读","url":"/2021/04/30/JavaScript引擎V8-精读/","content":"- https://v8.dev/docs\n为什么要？\n知其然知其所以然，对知识本身的理解，越往后走，走过的前面的内容就越简单\n\n工作中，一些性能调优，问题解决负责团队的项目涉及(browser,node,electron)\n\n\n#### github\n- https://github.com/v8/v8.git\n\n需要比较长解释的，就单独新一个链接\n#### Event-Loop事件循环\n- 异步\n#### 垃圾回收\n\n\nhttps://v8.dev/blog/math-random\n\n### 率先引入\n- V8之前，JS的虚拟机都是解释执行，V8率先引入JIT的双轮驱动设计 - 权衡策略 （混合编译执行和解释执行两种手段）\n- 惰性编译（加速代码启动速度）、内联缓存、隐藏类（Hide Class，将动态类型转换为静态类型，消除动态类型语言执行速度过慢点问题）\n### V8的编译流水线\n\n### others\n- Any application that can be written in JavaScript, will eventually be written in JavaScript. - Jeff Atwood\n- The strength of JavaScript is that you can do anything. The weakness is that you will. - Reg Braithwaite"},{"title":"digging-into-node-KyleSimpson-精读","url":"/2021/04/30/digging-into-node-KyleSimpson-精读/","content":"### 介绍\n08,09年的时候Kyle Simpson已经做了10来年的程序员了，用过不同的语言，他最喜欢的还是JavaScript。\n那个时候，他后端用别的语言写；前端用JS写；他想专注于JavaScript领域。\nThe Middle End的概念——基于他之前的工作经历(这样可以把后端当成一个黑盒，我们用JSON来交互，传递信息) - 2008年左右的想法\n- Rhino\n- bite chain - pre Node - Kyle\n- Ryan - Node \n\n### Node Perspective\n- node - 用途，优点\n- 异步事件循环 - asynchronous event Loop\n- "},{"title":"样式与交互解决方案-持续更新中","url":"/2021/04/29/样式与交互解决方案-持续更新中/","content":"### 吸顶\n```position\b:sticky```\nhttps://www.zhangxinxu.com/wordpress/2018/12/css-position-sticky/\n"},{"title":"REST-API","url":"/2021/04/27/REST-API/","content":"\n### basic\n- 表述性状态转移\n- 一切看作资源\n- 资源 - CURD\n- 使用URI来定位资源\n- 使用HTTP动词来操作资源\n- 视图函数的URI不应该包含动词\n\n### 理论/实践\n- 内部API - 业务逻辑负责\n- 开放API - 标准REST\n\n\n### 面临的挑战\n（David Mckenna）REST 面临的挑战：\n- 反向 API\n  - Webhooks | WebSocket | SSE(服务器发送事件)\n- 事件驱动\n  - Kafka | RabbitMQ\n- gRPC\n- GraphQL(Facebook)\n- OData(Microsoft)\n- IoT\n  - MQTT\n  - AMQP\n\n具体见下面文章：\nhttps://dzone.com/articles/api-is-dead-long-live-the-apis\n中文翻译：https://time.geekbang.org/column/article/192032\n\n\n\n\n### 各家API查询\nAPI directory | programmableweb\nhttps://www.programmableweb.com/apis/directory\n\n\n## 接口设计\n\n### MECE\n- 分析问题时\n- Mutually Exclusive and Collectively Exhaustive\n- 无依赖关系，相互独立\n- 穷举\n- 避免需求膨胀和过度设计\n\n### 命名明确，语义\n\n### 接口的职责 - 每个接口要做的事 => 单一，独立，完整\n\n### 依赖 （减少，如果有，得做好声明）\n\n### Robust （即使没按约定规范来，也不容易出错）\n\n### 面向对象设计5原则\n- SOLID\n\n\n## Django\n\n### 蓝图分离视图函数的缺陷\n\n\n"},{"title":"消息队列","url":"/2021/04/27/消息队列/","content":"\n> 系统间通信的需求 -> 消息队列； 最早的中间件之一； 官方文档都很不错；\n## 开源/Popular\n### rabbitmq\n我们这边用的是私有化部署的rabbitmq\n文档指路：https://www.rabbitmq.com/getstarted.html\n\n比较传统的消息中间件：\n- 处理和响应消息的方式是destructive的，一旦消息被成功处理，就会从broker上删除\n\n#### rabbitmq服务器上查看\n```\nwhereis rabbitmq\nrabbitmq-plugins list\nrabbitmqctl list_users\n```\n#### web 管理端 \n- admin-Users 配置对应的user - Can access virtual hosts\n\n#### nacos 对rabbitmq的配置\n```\n  rabbitmq:\n    host: ${rabbitmq.host}\n    port: ${rabbitmq.port}\n    username: ${rabbitmq.username}\n    password: ${rabbitmq.password}\n    virtual-host: homework\n    listener:\n      direct:\n        acknowledge-mode: auto\n        retry:\n          enabled: true\n          max-attempts: 5\n          initial-interval: 2000\n      simple:\n        retry:\n          enabled: true\n          max-attempts: 4\n          initial-interval: 2000\n        prefetch: 1\n        acknowledge-mode: auto\n```\n#### 自己的消息中心也集成到了内部管理端\n\n#### 集成RabbitMQ统一发送接收方案\n- rabbitmq - 支持非常灵活的路由配置 - 在生产者producer和队列queue之间增加了一个exchange模块\n#### 项目团队使用情况\n- nest(https://github.com/nestjs/nest) \n  - https://github.com/nestjsx/nestjs-amqp \n  - https://docs.nestjs.com/microservices/rabbitmq\n\n\n- java团队\n  - 利用rabbitmq提供相关离线操作，及高并发削峰\n  - skywalking - skywalking/agent/config/apm-trace-ignore-plugin.config + trace.ignore_path=RabbitMQ/**\n\n\n### Kafka\nJava团队也用这个\n- Partition（分区）\n### rocketmq\n之前被推过一个内部的微服务开发框架，用的是rocketMQ\n文档指路：http://rocketmq.apache.org/docs/quick-start/\n- 每个Topic包含多个队列，通过多个队列来实现多实例并行生产和消费\n- Subscriber-Consumer Group\n\n## 基于异步消息提升性能\n### wiki指路\nhttps://zh.wikipedia.org/wiki/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97\n\n\n### 名词解释-设计/演进\n#### 主题\n#### 队列模型\n- Queue(FIFO-Linear List,具体实现-链表or数组)\n- Producer-Consumer\n#### 发布-订阅模型（publish-subscribe pattern）\n- Publisher发布者（消息的发送方）-Subscriber订阅者（消息的接收方）\n- Topic(服务端存放消息的容器)\n- 发布者将消息发送到主题中，订阅者在接收消息之前需要先“订阅主题”\n- 订阅既是一个动作，也是主题在消费时的一个逻辑副本\n- 每份订阅中，订阅者都可以接收到主题的所有消息\n\n- RabbitMQ用的是队列模型，但是可以实现发布订阅功能（解决了多个消费者的问题-Exchange模块）\n- RocketMQ和Kafka用是发布-订阅模型（业务模型比较像，但是具体实现不一样）\n\n#### 使用锁保护共享数据，协调异步线程\n## Pulsar\n- 最早yahoo开发\n- 存储计算分离设计（设计思路）\n### pulsar - node - 坑一个\n\n- https://pulsar.apache.org/docs/en/client-libraries-cpp/#install-rpm\n- https://pulsar.apache.org/docs/en/client-libraries-node/\n- 安装pulsar-client之前需要安装C++的client library\n#### Errors\n但是呢，我们现在安装`$ npm install pulsar-client`的时候，报错\n```\ninstall response status 404 Not Found on https://pulsar.apache.org/docs/en/client-libraries-cpp/libpulsar-v1.6.2-node-v72-linux-x64.tar.gz\n```\nnode-pre-gyp下载二进制文件的路径，优先来源于对应模块的镜像地址，该镜像地址通过配置'npm_config_' + 模块名 + '_binary_host_mirror'来实现自定义；在没有定义镜像地址的情况下，读取模块package.json中的binary属性信息。\n\n这个时候如果有libpulsar-v1.6.2-node-v72-linux-x64.tar.gz这个文件，就可以配置个host，打到自己服务器，提供这个资源，如果没有，就看看之前安装过的，图快的话node_modules弄过来；\n\n```\n# node_modules如果物理机上有，压缩下，拿过来就行\ntar -czvf node_modules.tar.gz node_modules\ntar -xvf node_modules.tar.gz\n中间的周转是用cos进行存储的，wget拿\n# 如果在image里面，可以\ndocker images # 拿到id\ndocker run -it --entrypoint sh \"id\"\nyum install lrzsz\nsz node_modules.tar.gz\n# 也同样用cos进行存储的，wget拿\n```\n\n这个报错是因为找不到libpulsar.so.2.8.1文件，所以按这个https://pulsar.apache.org/docs/en/client-libraries-cpp/#install-rpm安装下对应版本的即可；\nfind -name libpulsar.so.2.8.1\n看看能不能找到，找到了位置不对的话，`ln -s  /path/to/lib**.so   /usr/lib` ,`sudo ldconfig`\n`Note\nIf you get the error that libpulsar.so: cannot open shared object file: No such file or directory when starting Pulsar client, you may need to run ldconfig first.`\nfind \n```\nError: libpulsar.so.2.8.1: cannot open shared object file: No such file or directory\n26|htmlToSvg  |     at Object.Module._extensions..node (internal/modules/cjs/loader.js:1208:18)\n26|htmlToSvg  |     at Module.load (internal/modules/cjs/loader.js:1002:32)\n26|htmlToSvg  |     at Function.Module._load (internal/modules/cjs/loader.js:901:14)\n26|htmlToSvg  |     at Module.require (internal/modules/cjs/loader.js:1044:19)\n26|htmlToSvg  |     at Module.Hook._require.Module.require (/usr/local/lib/node_modules/pm2/node_modules/require-in-the-middle/index.js:80:39)\n26|htmlToSvg  |     at require (internal/modules/cjs/helpers.js:77:18)\n26|htmlToSvg  |     at bindings (/neworiental/nodejs/seal_svg_server-1/node_modules/bindings/bindings.js:112:48)\n26|htmlToSvg  |     at Object.<anonymous> (/neworiental/nodejs/seal_svg_server-1/node_modules/pulsar-client/index.js:20:42)\n26|htmlToSvg  |     at Module._compile (internal/modules/cjs/loader.js:1158:30)\n26|htmlToSvg  |     at Module._compile (/neworiental/nodejs/seal_svg_server-1/node_modules/pirates/lib/index.js:99:24)\nPM2           | App name:htmlToSvg id:26 disconnected\nPM2           | App [htmlToSvg:26] exited with code [0] via signal [SIGINT]\nPM2           | App [htmlToSvg:26] starting in -cluster mode-\nPM2           | App [htmlToSvg:26] online\n```\n上面的是想办法弄编好的，如果实在没有，就走node-gyp去编了，根据报错一步步解决即可\n- https://zhuanlan.zhihu.com/p/330468774\n\n#### 根本解决ERROR，把centos的环境处理好\n```\n1.就node-pre-gyp不行的话，因为找不到已经预编译好的符合要求的版本嘛，就走本地编译\n2.node-gyp本地编译的时候,mac注意配置下PULSAR_CPP_DIR 即可\n- export PULSAR_CPP_DIR=\"/usr/local/Cellar/libpulsar/2.9.1_1\"\n- brew安装的，也是注意下环境变量的配置，保证位置找对了\nexport CPLUS_INCLUDE_PATH=\"$(brew --prefix)/include\"\\nexport LIBRARY_PATH=\"$(brew --prefix)/lib\"\nexport CPLUS_INCLUDE_PATH=\"$CPLUS_INCLUDE_PATH:$(brew --prefix)/include\"\nexport LIBRARY_PATH=\"$LIBRARY_PATH:$(brew --prefix)/lib\"\n3.node-gyp本地编译的时候,linux服务器注意准备好文档中写的requirement,然后就可以编译了，看报什么错，就解决什么错就行 (https://pulsar.apache.org/docs/zh-CN/next/client-libraries-cpp/#%E5%AE%89%E8%A3%85-rpm - 这个里面提示了nodejs需要预先安装什么)\n注意点1：yum -y install gcc automake autoconf libtool make\nyum -y install gcc-c++\n注意点2:\nclient-devel\nclient\n这两个都要安装，rpm -ivh apache-pulsar-client*.rpm 一个一个的，运行两遍就行；确保都安装了；\n```\n\n- 如果确定了要的预编译包，也可以自己编译好了，然后打gz的包，发布到我们自己的文档对象存储上，然后在pulsar-client的安装脚本里面，把地址改下就行\n### consumer\n#### There are two main ways of using the consumer:\n- Blocking style: synchronously calling receive(msg).\n- Non-blocking (event based) style: using a message listener.\n\n- 但是这部分node的封装有点问题，listener模式下，如果把receiverQueueSize设置为0，会报错，提示应该更明确的，让非阻塞模式下就不要使用这个了；\n- receiverQueueSize\t设置 consumer 接收队列的大小，即在应用程序调用 receive 之前允许堆积的消息数。 A value higher than the default of 1000 could increase consumer throughput, though at the expense of more memory utilization.\n\n\n#### https://github.com/apache/pulsar-client-node/issues/308\n- consumer listener does not respect receiver queue size #308\n- 这个问题，在23.04.10修复了 https://github.com/apache/pulsar-client-node/commit/c59f8801a1093831ef354e02e0692c4ce5b8dcc0"},{"title":"vue-next项目实践总结","url":"/2021/04/27/vue-next项目实践总结/","content":"> 起源Nov.2018 VueConf TO (Evan You) - Vue 3.0 Updates (faster,smaller,more maintainable,easier to target native)\n```\n尽可能兼容2.0 的API\n之前Virtual DOM会有蛮多运行时开销的\n生成更易被JS引擎优化的代码\n\n判断原生还是组件\nComponent path fast\n\n生成虚拟node的时候，函数尽量一致\n优化slots生成\n2.0 基于ES5的 getter，setter 进行 \n\nLazy by default\n直接暴露给用户this \nAPI不动\n\nVue本身runtime更小\n\n按需引入\n\n最最基本的代码在10KB左右\n降低源码阅读难度\n\nVetur\nVue hooks\n\n框架做js计算-》浏览器主线程block-》无法响应用户事件\n\n16ms（一frames）\n明年下半年发布\n```\n\n> 在一个业务简单，逻辑清晰的项目里面，Vue-next作为开发框架\nhttps://v3.cn.vuejs.org/guide/introduction.html\n\n### devtools\n商店里面下载Vue devtools 的 beta 版本，然后把之前的版本卸载掉\n这个时候重新打开之前的Vue3的页面即可\n\n项目里面配置：\n```\n// 打开浏览器工具\nif (process.env.NODE_ENV === 'development') {\n  if ('__VUE_DEVTOOLS_GLOBAL_HOOK__' in window) {\n    // 这里__VUE_DEVTOOLS_GLOBAL_HOOK__.Vue赋值一个createApp实例\n    ;(window as any).__VUE_DEVTOOLS_GLOBAL_HOOK__.Vue = app\n  }\n  const config: any = app.config\n  config.devtools = true\n}\n```\n这个是cli初始化项目时候带的\n\n## basic\n> 其实都是文档上写了的\n#### 单文件组件<script setup>\n- 普通的 <script> 只在组件被首次引入的时候执行一次\n- <script setup> 中的代码会在每次组件实例被创建的时候执行\n- 顶层的绑定会被暴露给模版\n\nv3\n1-7 12 14\n\n\n## 其他\n- 字体问题\n- https://www.zhangxinxu.com/wordpress/2018/02/js-detect-suppot-font-family/\n- 检测系统是否带目标字体，如果不带，引导用户安装\n\n\n## 样式相关\n`::v-deep`作为组合器的使用在Vue.js 3.0.0-beta.1之后就被弃用了。这是因为这种使用方式与CSS伪元素冲突，可能会引发不必要的混淆和错误。\n\n就像在Vue.js的RFCS中所建议的那样，以前的`::v-deep`、`/deep/`、`>>>`现在都推荐使用`:deep()`进行替代。新的`:deep()`修饰符提供了一种更明确、更直观的方式来控制后代组件的样式。例如，`.a :deep(.b) { color: red }`这段代码将会被处理为`.a .b { color: red }`。\n\n而以前的`::v-deep`、`/deep/`或`>>>`可能会让开发者误认为他们在使用一个真正的CSS压缩器，但实际上它们并不能在所有的CSS预处理器中正常工作。而新的`:deep()`修饰符将会更准确地描述其行为：它不是一个真正的CSS组合器，而是Vue的一个scoped CSS特性。"},{"title":"协议和端口号","url":"/2021/04/27/协议和端口号/","content":"### ssh 22\n关于为什么是22以及怎么拿到22的端口号，协议作者在官网上还讲述了下过程～\nhttps://www.ssh.com/academy/ssh/port\n\nhttps://linux.cn/article-8476-1.html —— 中文翻译\n\n### ftp 21\n\n推荐客户端工具\nhttps://cyberduck.io/"},{"title":"数据展示","url":"/2021/04/27/数据展示/","content":"\n## 平台推荐\n### grafana\n> 去年和别的部门有合作项目，提供给我们看pod数据的的平台是基于grafana私有化部署的(pandora上面也能看)\n- https://grafana.com/grafana/\n\n#### grafana 安装\n- https://grafana.com/docs/grafana/next/setup-grafana/installation/rpm/\n```\nyum -y install urw-fonts\nrpm -ivh grafana-6.6.2-1.x86_64.rpm\nsystemctl start grafana-server\nsystemctl status grafana-server\n# 默认端口3000\n# 配置数据源，dashboard - 按引导添加即可\n# 修改配置\nvim grafana.ini\nsystemctl restart grafana-server.service\n# set to true if you want to allow browsers to render Grafana in a <frame>, <iframe>, <embed> or <object>. default is false.   allow_embedding = true\n\n```\n\n#### 接入的模块\n- feign监控 （API监控 ｜ roc feign监控）\n- gateway （业务监控-API ｜ 共享内存使用情况 ｜ 流量监控 ｜ 网关监控）\n- 业务逻辑健康"},{"title":"mongodb","url":"/2021/04/23/mongodb/","content":"> 精读-学习笔记 - 在集群架构拥有十分高的扩展性，高可用的实现对运维的要求比较高\n## Basic\n\n### docs\n- https://docs.mongodb.com/guides/\n- https://university.mongodb.com/?tck=docs_landing\n- 中文社区-https://mongoing.com/\n- 中文版手册-https://docs.mongoing.com/\n\n### intro\n- DB-Engines 排名\n- 重新定义OLTP数据库 - （tips:OLAP）\n- JSON Document 以JSON为数据模型的文档数据库\n- MongoDB Inc.\n- 建模可选/横向扩展可以支撑很大的数据量和并发\n- 社区版（SSPL）/企业版（商业协议）\n- 数据容量-理论上没有上限\n\n### history\n0.x 2008\n1.x 2010 - 支持复制集（高可用）和分片集\n2.x 2012 - 数据库功能\n3.x 2014 - WiredTiger + 生态\n4.x 2018 - 分布式事务支持\n\n#### 闲话\n- 竞品：\n14年，微软推出了DocumentDB预览版，17年5月升级为Cosmos DB（包含多个数据模型，文档模型成为子集）\nMongoDB-易用性！ 稳定性（丢数据，安全，分布式处理能力）？\nDocumentDB-Leslie Lamport(对事务的处理，自动索引，PaaS服务)\n做成了Windows Azure的一个服务\n17年，提供了兼容MongoDB的API\n（17年1月，黑客大量袭击了默认安装的MongoDB）\n\n- 人\nDoubleCLick原创始人（Dwight Merriman, Kevin Ryan, Eliot Horowitz）\n原先想做一个云计算的服务的\n然后先搭一个数据库\n\nmongo - humongous - 海量数据库 - 面向集合，模式自由，文档型数据库（Accelerate development, address diverse data sets, and adapt quickly to change with a proven application data platform built around the database most wanted by developers 4 years running.）\n\nPS：SQL是IBM出来的\n\n10gen 在 2009年2月正式开源MongoDB的第一个版本\n\n商业上-资助用户组，对社区的支持，技术支持团队-nice（用户体验）\n\n13年更名 MongoDB公司\n\n\n\n### advantage\n- 面向开发者的易用&&高效数据库\n- 对象模型（Objects=>Database）—— 传统关系数据库，复杂的关系模型\n- 快速响应业务变化（可动态增加新字段）\n  - 多形性:同一个集合中，可以包含不同字段的文档对象\n  - 动态性：线上修改数据模式，修改时应用与数据库均无需下线\n  - 数据治理：支持使用JSON Schema来规范数据模式。在保证模式灵活动态的前提下，提供数据治理能力\n- JSON模型（快速灵活）\n  - 数据库引擎只需要在一个存储区读写（对物理存储有优势，节约了定位时间）\n  - 反范式，无关联的组织极大优化查询速度\n  - 程序API自然，开发快速（API查询）\n- 分布式（原生的高可用）\n  - Replica Set 复制集（2-50个成员）3个节点以上\n  - 自动恢复\n  - 多中心容灾\n  - 滚动服务-最小化服务终端（无需下线）\n- 横向扩展能力\n  - 需要的时候无缝扩展\n  - 对应用全透明\n  - 多种数据分布策略\n  - 支持TB-PB数量级\n  \n### install\n- 企业/社区\n- 偶数版\n- version/os/package\n- https://docs.mongodb.com/manual/administration/install-community/\n```\n\n# centos - 本地安装\n# 新建一个/etc/yum.repos.d/mongodb-org-4.2.repo，这样我们可以用yum来安装\n[mongodb-org-4.2]\nname=MongoDB Repository\nbaseurl=https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/4.2/x86_64/\ngpgcheck=1\nenabled=1\ngpgkey=https://www.mongodb.org/static/pgp/server-4.2.asc\n\n# 然后安装最近的稳定版本\nsudo yum install -y mongodb-org\n\n# 启动社区版\n# 默认会在/var/lib/mongo(data) /var/log/mongodb(log)，如果想要改到自己创建的目录，可以修改/etc/mongod.conf文件\nsudo chown -R mongod:mongod <directory> # 注意权限问题\n\n# 看用systemctl（较新版本Linux） 还是 service （较老版本），可以用\"ps --no-headers -o comm 1\"查，我这边centos7，用的是systemctl\nsystemctl start mongod\n\n# 如果报错“Failed to start mongod.service: Unit mongod.service not found.”\nsystemctl daemon-reload\n\n# 查看是否成功启动\nsystemctl status mongod\n\n# 如果想随着系统reboot开启\nsystemctl enable mongod\n\n# 关\nsystemctl stop mongod\n\n# 重启\nsystemctl restart mongod\n\n# 使用\nmongo\n\n# MacOS - 自己下载安装\n# https://docs.mongoing.com/install-mongodb/install-mongodb-community-edition/install-on-macos\nxcode-select --install\nbrew tap mongodb/brew\nbrew install mongodb-community@4.4 \n# 本质上也是下载下面的文件Updating Homebrew...\n==> Installing mongodb-community from mongodb/brew\n==> Downloading https://fastdl.mongodb.org/tools/db/mongodb-database-tools-macos-x86_64-100.3.1.zip\n==> Downloading https://fastdl.mongodb.org/osx/mongodb-macos-x86_64-4.4.5.tgz\n==> Installing dependencies for mongodb/brew/mongodb-community: mongodb-database-tools\n==> Installing mongodb/brew/mongodb-community dependency: mongodb-database-tools\n\n# 如果有报错，```brew uninstall mongodb```之后再安装\nbrew services start mongodb/brew/mongodb-community\n\n# 云部署\nAtlas免费测试账号：\n可以cloud.mongodb.com,注册登录之后就可以免费创建集群了（白名单ip+用户名密码）\n然后用命令行连接集群\n```\n\n```\n# mongorestore \ncurl -O -k https://xxx.xxx.com/dump.tar.gz\ntar -xvf dump.tar.gz\nmongorestore /dump\n```\n\n### 查看工具\n- studio3T\n- NoSQL Booster\n\ngrafana:\nhttps://grafana.com/grafana/dashboards/8339\n\n- mongoDB compass(官方，免费，好用)\n  - mongodb compass,左下角，点击 _MONGOSH BETA 也能进入shell模式\n  - documents 切换view的模式,Interactive Document Editor.Modify existing documents with greater confidence using the intuitive visual editor, or insert new documents and clone or delete existing ones in just a few clicks.\n  - schema 子文档的字段也能看，分析，compass特有功能;Visualize your Schema.MongoDB Compass analyzes your documents and displays rich structures within your collections through an intuitive GUI. It allows you to quickly visualize and explore your schema to understand the frequency, types and ranges of fields in your data set.\n  - 执行查询的时候;Visual Explain Plans.Know how queries are running through an easy-to-understand GUI that helps you identify and resolve performance issues.\n  - Performance Charts.Real-time server statistics let you view key server metrics and database operations. Drill down into database operations easily and understand your most active collections.\n  - Schema Validation.Create schema validation rules with a smart editor that auto-suggests rule components. See immediate results with a live preview and revise rules as needed. See Schema Validation in the MongoDB documentation for more information.\n  - Deployment Awareness;Replica set aware connections allow for continued use during replica set configuration changes and provides additional information of the connected cluster.\n  - Query History;Easily access and manage executed queries and save favorites for often executed queries.\n\n### 操作\n- find - 查询，类似于SELECT；返回的是游标；```$and:[] $or:[] ;正则 /^B/；```\n  - 使用游标对象的API可以对全部结果进行遍历\n  - DBQuery.shellBatchSize\n  - 查询条件和SQL的对照 ```a <= 1  {a:{$lte:1}}  ，a = 1 AND b = 1 {$and: [{a:1},{b:1}]}```\n  - $ 是mongo里面特殊的符号 查询逻辑运算符 $lt ，因为在mongo里面，需要要key:value\n  - 支持使用```field.sub_field   db.barcode.find({\"volumes.pdfUrl\": \"www.baidu.com\"}) ``` \n  - 使用find搜索数组(注意存的类型是数组，还是数组stringfy之后的字符串)，数组子文档也可以搜 . $elemMatch\n  - 可以返回指定字段 Projection 投影\n  - .pretty()\n- remove \n  - 需要配合查询条件使用\n- update\n  - 查询条件，更新字段\n  - {$set:} 各种操作方法\n- drop\n  - db.<collection>.drop() 集合中的全部文档和索引都会被删除\n  - 不要在生产上轻易操作\n  - db.dropDatabase() 数据库就删了\n\n### 程序访问mongodb\n- python ```pip install pymongo```\n- mongoDB连接串 比如有—— mongodb://数据库服务器主机地址:端口号\n- 我们可以进行一系列操作（按文档），mongo-无模式\n- 更新用户 update_one 我们没有去数据库修改表结构\n- 代码量少\n\n\n### 聚合 \n- 做的是sql里面as ，groupby , leftjoin 的操作\n- aggregation framework - 计算框架\n- pipeline = [$stage1,$stage2, ...$stageN]\n- db.<COLLECTION>.aggregate(pipeline,{ options })\n- $match -过滤 WHERE | $ project -投影 SELECT AS | $sort -排序 ORDER BY | $group -分组 GROUP BY | $skip/$limit -结果限制 SKIP/LIMIT | $lookup -左外连接（关联） LEFT OUTER JOIN\n- 常见步骤中的运算符\n- 非常见步骤，mongo特有 $unwind - 展开数组 | $graphLookup - 图搜索 | $facet/$bucket - 分面搜索（电商常用）\n- OLTP | OLAP\n- \n\n##  Client-Side Field Level Encryption\n- MongoDB 的客户端字段级加密功能\n- https://mp.weixin.qq.com/s/X7JKiK59iu9i7iacWnjsJg\n\n### js脚本执行\n- mongodb compass 的命令行暂时不支持load\n- mongosh 可以，执行load()"},{"title":"intro-to-linux-and-cli","url":"/2021/04/21/intro-to-linux-and-cli/","content":"https://btholt.github.io/complete-intro-to-linux-and-the-cli/\n\nnotes from 《complete-intro-to-linux-and-the-cli》\n\n## 文档精读：\n\n\n### Cron\nLinux有cron的功能，可以定时跑任务\n\n#### cron folders\n放在以下任何一个文件夹中的任何脚本都将按时间表运行\n\n/etc/cron.daily\n/etc/cron.hourly\n/etc/cron.monthly\n/etc/cron.weekly\n\n确保有权限就行，可以通过```sudo chmod +x <file>```\n这里面的内容以root身份运行\n#### crontab\n如果你需要一个更明确的时间表（比如每五分钟，每隔一个星期四，每六个月，等等），那么可以使用crontab。用crontab可以定义一个cron时间表来执行脚本。\n```\nmkdir -p ~/temp-files # 在home目录下\ncd ~/temp-files\ntouch file-$(date +%s).txt \n```\n$(date +%s)，从1970到现在，过去了多少秒\n\n- crontab - maintains crontab files for individual users\n<pre>\n-e     Edits the current crontab using the editor specified by the VISUAL or EDITOR environment variables.   After  you\n              exit from the editor, the modified crontab will be installed automatically.\n</pre>\n```\ncrontab -e\ncrontab -e ubuntu -e\n```\n\nhttps://crontab.guru/\n规则记起来也不是很好记，可以借助上面的网站进行参考\n\n定时任务的处理记得保证逻辑完备"},{"title":"ES进化史","url":"/2021/04/18/ES进化史/","content":"### 学习资料:\nhttps://babeljs.io/docs/en/learn\n\nhttps://developers.google.com/web/shows/ttt/series-2/es2015\n\n### 进化方法论：\n- ES3(1999)-ES5(2009)\n- 标准和浏览器实现之间的博弈\n- 被IE耽误的那些年\n- ES2015（formally ES6）之后，ES20XX\n- 更新模式的变更\n- 不得不说的Babel\n\n### ES6总结\n- 模块化的基本语法\n- 开发环境配置\n- 关于JS众多模块化标准\n- Class 和普通构造函数有何区别\n- Promise 的基本使用和原理\n- ES6 常用功能\n\n#### Set\n- https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Set\n- 可以模拟并|交|差|子 集\n\n###\nhttps://caniuse.com/?search=Object.fromEntries"},{"title":"软件版本","url":"/2021/04/17/软件版本/","content":"### 软件版本意思\nwiki:\nhttps://en.wikipedia.org/wiki/Software_release_life_cycle\n\n<pre>\n开发期\nPre-alpha\n有时候软体会在Alpha或Beta版本前先释出Pre-alpha版本。一般而言相对于Alpha或Beta版本，Pre-alpha版本是一个功能不完整的版本。\n\nAlpha\nAlpha版本仍然需要测试，其功能亦未完善，因为它是整个软体释出周期中的第一个阶段，所以它的名称是「Alpha」，希腊字母中的第一个字母「α」。\n\nAlpha版本通常会送到开发软体的组织或某群体中的软体测试者作内部测试。在市场上，越来越多公司会邀请外部客户或合作伙伴参与其测试。这令软体在此阶段有更大的可用性测试。\n\n在测试的第一个阶段中，开发者通常会进行白盒测试。其他测试会在稍后时间由其他测试团体以黑盒或灰盒技术进行，不过有时会同时进行。\n\nBeta\nBeta版本是软件最早对外公开的软体版本，由公众（通常为公司外的第三方开发者和业馀玩家）参与测试。 因为是Alpha的下一个阶段，所以为希腊字母的第二个字Beta (β)。 一般来说，Beta包含所有功能，但可能有一些已知问题和较轻微的程序错误（BUG），要进行除错（debug）。Beta版本的测试者通常是开发软体的组织的客户，他们会以免费或优惠价钱得到软体。Beta版本亦作为测试产品的支援和市场反应等。\n\n其他情况不同企业有不同的称法，例如微软曾以Community Technology Preview（简称CTP，中文称为「社群技术预览」）为发佈软体的测试版本之一，微软将这个阶段的软体散佈给有需要先行试用的使用者或厂商，并收集这些人的使用经验，以便作为进一步修正软体的参考。\n\nRelease Candidate\nRelease Candidate（简称RC）指可能成为最终产品的候选版本，如果未出现问题则可释出成为正式版本。在此阶段的产品通常包含所有功能、或接近完整，亦不会出现严重问题。\n\n多数开源软件会推出两个RC版本，最后的RC2则成为正式版本。闭源软件较少公开使用，微软公司在Windows 7上应用此名称。苹果公司把在这阶段的产品称为「Golden Master Candidate」（简称GM Candidate），而最后的GM即成为正式版本。\n</pre>\n\n## semver\n- Semantic Versioning\n- 主版本号 ｜ 次版本号 ｜ 修订号\n- 不兼容API ｜ 向下兼容更新 ｜ 问题修复\n- https://semver.org/lang/zh-CN/\n- 语义化版本控制规范（SemVer）\n- https://www.npmjs.com/package/semver"},{"title":"工作学习生活-方法论","url":"/2021/04/17/工作学习生活-方法论/","content":"\n> 靡不有初，鲜克有终 All are good at first, but few prove themselves to be so at the last\n> 思想放松，行动紧张\n> 不需要和别人比，每天让自己变强一点点（每天问自己，有没有收获哩～其实所有的经历，都会给我们带来成长，不用着急\n> 知道要什么最重要，快乐最重要\n> 不放过碰到的疑问\n\n### 反馈\n工作中：\n带团队：让每个人能得到反馈（通过代码评审，有效的绩效制定及反馈）\n快速反馈能够建立信任（消除信息不对称-The intolerance of uncertainty-Freeston）\n\n### coding && studying\n1.问题的收敛（问题在整个领域中所处的位置，问题背后的最大的问题）\n2.think big and think deep\n- 团队代码要求： 正确性 > 可读性 > performance\n#### 源码阅读\n- 继承学习方法论，但工作和进入社会前的学习，目标不同，因而要达到目标所优先采取的路径也不同——这是进入工作时，老大让我明白的第一课\n\n- 为什么（背景），做什么（功能），怎么做\n\n- 磨刀不误砍柴功，配置好具体的项目阅读的IDE环境（Vscode基础配置，对应插件）\n\n- 抓大放小（2/8原则）—— 先掌握结构框架（在不断的阅读及反哺工作的过程中，自己的框架构建方法论也会不断成熟）\n\n- 模块分析/归类/类比/总结 && 自底向上/自顶向下 && 抽象与验证 && 可以适当借助工具，自己画结构图 && 最后可以换个维度，比如从功能维度再进行串联\n\n- 核心代码-即使复杂，也要吃透\n\n- 阅读\n  - redis/tomcat\n  - react/\n  - dubbo（RPC）/guava\n\n- 最重要，去做\n\n#### 团队\n1.愿意怎么样去影响团队？\n2.应该怎么样去影响团队？\n3.如何建立一个新的团队？\n\n#### 技术预研\n- 分析需求，找出重点难点\n- part1- demo跑通核心难点\n- part2- trade-on!!!，投入收益，人才积累，团队架构，公司已购服务情况，运维团队\n\n\n## 产品\n- 当用户想要的功能越多，它的使用成本也会逐渐上升\n- Hick's Law\n\n- word -  桌面出版-desktop publishing - 在线上还原与印刷一致的效果，有很多印刷相关的设计和逻辑\n- container - size - 2560(24寸高清)|1920(24寸)|1440(15寸)|1366(13寸)|683(分屏)\n```\n价值论 -> 趋利避害（人）\n成本 vs 收益 （性价比）\n戴明环（PDCA循环）plan规划 do执行 check检查 action调整\ndont't make me think \n1.no阅读 yes扫描\n2.满意即可\n3.勉强应对\n群体行为严格遵守价值论，产品是一种价值交换，用户体验影响价值的传输率（收益）\n```\n- 定义 -> 开发 -> 运营 -> 迭代 （小步快跑）\n\n## 深阅读\n- raymond mar | keith oatley\n\n- 数据的容器 - 数据的加工 - 加工流程的控制 - 流程的重用\n\n### 思考 ｜ 表达\n- 思考过程 - 自下而上 - 建造X\n- 表达过程 - 自上而下 - 描述X\n\n### 框架和库选择\n- 前提（成本和效率-实现目标+团队协作+后续迭代）\n- 可学习性 + 满足需求\n- 后续迭代-长效价值\n- 设计代码比编写代码更重要\n- 模式｜体量｜性能｜前景｜普及度｜局限性｜活跃度｜契合度｜成熟度｜学习成本｜周边资源｜文档质量\n- 开发痛点，项目瓶颈\n\n#### 选择的原则\n- 不同特点的项目，要求不同 - 判断思路要有\n- 妥适性原则\n- 库（缩小依赖范围和向稳定方向依赖｜轻，简，实｜可替代性）\n- 主框架（没有不二法则｜拥抱未来｜经验价值高｜架构上的优势为重）- code review\n\n#### 熵增\n\n#### book reading\n"},{"title":"数据管理","url":"/2021/04/17/数据管理/","content":"- history\n  终端性能+网速\n\n- MVC\n  backbone(路由在前端)—— https://github.com/jashkenas/backbone\n\n- MVVM(由state决定UI)\n  - UI层和数据层的绑定\n\n- 组件间数据通讯\n  - 业务数据｜状态数据（和UI相关）\n  - react - 木偶组件 - Element/AntDesign\n  - 跨组件的状态数据 - 三级联动 - 机制=>父子和兄弟通信\n  - 父子=>props 子父=>react(处理函数)  兄弟 => 父子，子父问题的结合\n\n- 组件间数据通信加强版（eventbus）\n  - 额外的全局对象(可以加一些事件，log)\n\n- 单向数据流(redux & vuex)\n  - 组件是树状结构，但是eventbus是网状结构\n  - flux => 核心是store（状态管理方法论）=> 单向数据流方案\n  - redux => state应该被保存在单个store中 && state不能被直接更改，只能通过触发action改变 && pure function(reducer来处理数据修改逻辑，不依赖于全局变量，只依赖于传入的参数，不修改传入的参数，返回的是一个全新的对象)\n  - 严格，限制\n  - immutable\n  - 使用一定有场景=>解决问题\n  - 中间件（大逻辑的拆分）—— 异步放在了中间件处理\n  - https://cn.vuejs.org/v2/guide/state-management.html#%E7%AE%80%E5%8D%95%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E8%B5%B7%E6%AD%A5%E4%BD%BF%E7%94%A8\n\n- MobX —— https://mobx.js.org/README.html\n  - Reactive，响应式数据流方案，MobX是代表\n  - observable state / actions / computeds / reactions\n  - 面向事件的设计｜面向数据的设计\n  \n- 异步数据和rxjs\n  - teambition(https://www.teambition.com/)\n  - 大量相互依赖的异步数据 => 对复杂的部分抽个中间层处理 => 也没有根本解决问题\n  - https://zhuanlan.zhihu.com/p/23305264\n  - https://www.lilnong.top/static/pdf/B-4-RxJS%E5%9C%A8React%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8-%E9%BE%99%E9%80%B8%E6%A5%A0_.pdf\n  - 期望长期稳定的异步流程\n  - reactive/lodash for events/observable/stream-based\n  - rxjs - 钉钉桌面端 - 用rxjs 的Observable可以更好的描述（渐进式业务及需要cancel的异步API），减少复杂的异步API调用中少犯错\n  - 渐进式业务（搜索｜文件上传下载｜profile详情-基本->完整）\n\n> 应用场景=>需要优化的问题（imperative?no => more 流程化）   \n> 组件间/组件对端/组件对数据层/数据层和端  关系处理\n\n- 很多实时更新的数据？\n  - 做个截流层（node/前端框架）\n  - 保证进入缓存层的数据可控\n\n- 模块的拆分 => 基于工程实践，逐步抽象\n\n- 数据管理：前端/后端 差异\n\n- token可以本地持久化存，数据前端肯定不能明文存\n\n### 参考阅读：\n- dva(React应用框架) = React-Router + Redux + Redux-saga(将这三个React工具库保证在一起，简化了API)\n\n- dva之入门课：\n  - React没有解决的问题\n  - 通信问题\n  - 数据流问题\n  - 目前流行的数据流方案\n- 地址：https://dvajs.com/guide/introduce-class.html#react-%E6%B2%A1%E6%9C%89%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98\n\n- 文档还是值得读一读的，讲了为什么，怎么实现的\n\n### 方法论总结：\n补：最近又熟悉了一门语言和对应的应用的生态，当然，也离不开状态的管理；对于第三方或者官方提供的状态管理工具，了解的时候可以分为一下几个方面：\n- 解决了什么问题，应用的场景是什么\n- 横向比较，和同类比起来，好处和坏处\n- 基本机制，核心思想\n- 关注下作者和库的动态（如果觉得还不错的话）\n- 跑下demo，用一用，能解决的问题会产生的问题也就都出来了；\n\n\n### zustand\n\n\n\n\n### useSyncExternalStore\nreact18 中新提供的api useSyncExternalStore，它用来帮助库的开发和维护者更好地管理外部状态。"},{"title":"从flipboard谈谈移动端设计和开发","url":"/2021/04/16/从flipboard谈谈移动端设计和开发/","content":"### 项目\n嵌入小程序的PC端业务同构\n小程序端\n\n### history-flipboard\nhttps://engineering.flipboard.com/\n（到17年已经不更新了）\n不管是PC端，还是移动端的设计和阅读体验，都可以给人启发\n\n### github-flipboard\nhttps://github.com/Flipboard\n\nhttps://engineering.flipboard.com/2015/02/mobile-web\n虽然文章6年前的了，但是解决问题的思路值得思考\n\n### imgcook\n- 由设计稿一键职能生成代码\n- imgcook.com"},{"title":"react-intro","url":"/2021/04/15/react-intro/","content":"- 参考文档：\nhttps://btholt.github.io/complete-intro-to-react-v4/\nhttps://btholt.github.io/complete-intro-to-react-v5/\n\n## basic\n- 声明式UI，组件化\n- 解决应用的主要问题|用户界面的问题（工作量）\n- 2015.8 - facebook F8\n- react - UI库\n- 定义（代码偏向声明式）一次用户界面，用在多个地方\n- 状态（state） => 自动反应，更新界面\n- 只维护应用的状态\n\n## 实践项目中遇到的一些问题\n> 因为react相关项目是另外一个组负责，组间评审的时候，会看下项目，下面为遇到的一些问题\n### creat-react-app\n#### versions\n\n#### problems\nhttps://github.com/facebook/create-react-app/issues/10161\n关于eslintcache文件产生的位置问题(4.0.1)\n\neslint --cache false可以本地起效，但是不是解决方案\n\nmove .eslintcache into node_modules/.cache\nhttps://github.com/facebook/create-react-app/pull/10346\nreact team 的哥们回复\nhttps://github.com/facebook/create-react-app/pull/9977\n\n\n\neslint: {\n    cache: false,\n  },\n\n4.0.2\n\n\nto ignore a file already tracked you also need to run git rm --cached .eslintcache\ngitignore\n\n\n### 修改PORT，HOST\n直接\n.env\nPORT = 3003\nHOST = '127.0.0.1'\n\n\n## Framework\n### ice\n- 可视化页面构建\n- https://github.com/alibaba/ice\n- 时效性较强页面\n- 后端路由服务\n- 产出 - 当前布局与内容的DSL（JSON）\n- 组件间的通信 - 将不同组件通过自定义的钩子hook起来\n```\nclass FetchData extends Components {\n  state = {\n    data: {},\n  }\n  componentDidMount() {\n    const { componentApi } = this.props\n    api.get(componentApi)\n      .then((response) => {\n        this.setState({\n          data: response,\n        })\n      })\n  }\n  render() {\n    return <WrappedComponent {..props} data={this.state.data} />\n  }\n}\n```\n## lazy loadable\nReact.lazy and Suspense are not yet available for server-side rendering. If you want to do code-splitting in a server rendered app, we recommend Loadable Components. It has a nice guide for bundle splitting with server-side rendering.\n\n## stric mode\n- Suggested: We strongly suggest you enable Strict Mode in your Next.js application to better prepare your application for the future of React.\n- 还是建议使用的，如果是新项目的话，能更好的适应React后续的发展\n- 16.3引入的，且对生产环境毫无影响，能在console中打印有用的警告信息\n- https://github.com/facebook/react/issues/17786 - 一个有意思的issue\n\n\n## reportWebVitals\n- web-vitals\n- https://www.npmjs.com/package/web-vitals\n- https://zhuanlan.zhihu.com/p/149662237\n- https://blog.chromium.org/2020/05/introducing-web-vitals-essential-metrics.html\n- essential metrics for a healthy site\n- https://create-react-app.dev/docs/measuring-performance/\n\n### conf\n```\nReact conf 2018\n\nSophie Alpert\n\n1.25M developer\n\nRenewable energy\n\nMake it easier to build great UIs.\n\nCode splitting\n\n1.simplify hard stuff(suspense)\n2.performance(time slicing)\n2.developer tooling(profiler)\n\nWhat still sucks\nReusing logic--Wrapper hell\nGiant components\nConfusing classes(hard for humans,machines,hot roloading)\n```\n\n#### readings\n- https://blog.oyanglul.us/javascript/react-cookbook-mini\n- https://blog.oyanglul.us/javascript/understand-prototype\n\n## 原理\n"},{"title":"编解码","url":"/2021/04/15/编解码/","content":"## declaration\n- https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent\n```\n/**\n * Gets the unencoded version of an encoded Uniform Resource Identifier (URI).\n * @param encodedURI A value representing an encoded URI.\n */\ndeclare function decodeURI(encodedURI: string): string;\n\n/**\n * Gets the unencoded version of an encoded component of a Uniform Resource Identifier (URI).\n * @param encodedURIComponent A value representing an encoded URI component.\n */\ndeclare function decodeURIComponent(encodedURIComponent: string): string;\n\n/**\n * Encodes a text string as a valid Uniform Resource Identifier (URI)\n * @param uri A value representing an encoded URI.\n */\ndeclare function encodeURI(uri: string): string;\n\n/**\n * Encodes a text string as a valid component of a Uniform Resource Identifier (URI).\n * @param uriComponent A value representing an encoded URI component.\n */\ndeclare function encodeURIComponent(uriComponent: string | number | boolean): string;\n\n# encodeURIComponent 转义除了如下所示外的所有字符：\n\n# 不转义的字符：\n# A-Z a-z 0-9 - _ . ! ~ * ' ( )\n\n# 为了避免服务器收到不可预知的请求，对任何用户输入的作为URI部分的内容你都需要用encodeURIComponent进行转义\n\n```\n\n### encodedURI vs encodedURIComponent\n- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURI\n```\nNote that encodeURI() by itself cannot form proper HTTP GET and POST requests, such as for XMLHttpRequest, because \"&\", \"+\", and \"=\" are not encoded, which are treated as special characters in GET and POST requests. encodeURIComponent(), however, does encode these characters.\n```\n\n\n\n#### ASCII\n- American Standard Code for Information Interchange\n- https://en.wikipedia.org/wiki/ASCII\n- 2^8\n- 美国 - 服务于英文字符\n"},{"title":"yarn","url":"/2021/04/14/yarn/","content":"### overview\n- Yarn 是一款兼具项目管理功能的软件包管理器。无论您从事的是简单项目还是工业单体项目，无论您是开源开发者还是企业用户，Yarn 都能为您提供支持。\n\n\n\n### 文档指路\nhttps://classic.yarnpkg.com/en/docs/usage\nhttps://www.yarnpkg.cn/\n\n1.对node的版本有需求，如果node版本不对，就直接报错了"},{"title":"几个ip地址的含义","url":"/2021/04/14/几个ip地址的含义/","content":"\n对于监听地址， :: 等同于IPV4的0.0.0.0 （全0）\n而 ::1 则等同于 127.0.0.1 （本机地址）\n\n在IP地址范围内，一部分地址将保留作为私人IP地址空间，专门用于内部局域网使用，这些地址如下表：\n\n  A类 10.0.0.0-10.255.255.255 网络数：1\n  B类 172.16.0.0-172.31.255.255 网络数：16\n  C类 192.168.0.0-192.168.255.255 网络数：255\n\n  这些地址是不会被Internet分配的，它们在Internet上也不会被路由，虽然它们不能直接和Internet网连接，但通过技术手段仍旧可以和Internet通讯。我们可以根据需要来选择适当的地址类，在内部局域网中将这些地址像公用IP地址一样地使用。在Internet上，有些不需要与Internet通讯的设备，如打印机、可管理集线器等也可以使用这些地址，以节省IP地址资源。\n\n// Various Dev Server settings\n    host: '10.200.166.65', // can be overwritten by process.env.HOST\n    port: 8887, // can be overwritten by process.env.PORT, if port is in use\n\n\n起服务的时候：\n用本机ip,或者0.0.0.0\n这样子局域网的别的机器才能访问(局域网地址)到\n\nhttps://applegazette.com/mac/what-is-localhost-and-how-is-it-different-from-127-0-0-1/\n\n\nhttps://stackoverflow.com/questions/20778771/what-is-the-difference-between-0-0-0-0-127-0-0-1-and-localhost/20778887#20778887\n\n127.0.0.1 is normally the IP address assigned to the \"loopback\" or local-only interface. This is a \"fake\" network adapter that can only communicate within the same host. It's often used when you want a network-capable application to only serve clients on the same host. A process that is listening on 127.0.0.1 for connections will only receive local connections on that socket.\n\n\"localhost\" is normally the hostname for the 127.0.0.1 IP address. It's usually set in /etc/hosts (or the Windows equivalent named \"hosts\" somewhere under %WINDIR%). You can use it just like any other hostname - try \"ping localhost\" to see how it resolves to 127.0.0.1.\n\n0.0.0.0 has a couple of different meanings, but in this context, when a server is told to listen on 0.0.0.0 that means \"listen on every available network interface\". The loopback adapter with IP address 127.0.0.1 from the perspective of the server process looks just like any other network adapter on the machine, so a server told to listen on 0.0.0.0 will accept connections on that interface too.\n\nAt least in Windows, localhost behaves as 0.0.0.0 (not 127.0.0.1) by default\n\n\nhttps://gist.github.com/zxhfighter/b9f4b4ef328cd8b433b0e9dc2f4af26d\n\n实际测试：\n均为Mac\n\n127.0.0.1 起服务，同局域网的另外一台Mac无法访问-ERR_CONNECTION_REFUSED\n0.0.0.0 起服务，同局域网的另外一台Mac可以访问 # 注意，开启VPN的情况下，可能会导致访问出问题；\n\n\n### mongo 安全事件\nhttps://www.jianshu.com/p/d34ff415fbb4\n\n\n### 一个有趣的小白用户讨论\nhttps://github.com/gruntjs/grunt-contrib-connect/issues/164\n"},{"title":"端口号处理","url":"/2021/04/13/端口号处理/","content":"有时候我们起服务，端口号发现不是写的，而是在上面自增了一两个数字，那是因为端口号被占用了；\n我们可以找到正在运行的进程并将其kill。\n```\n# Mac/Linux: \nlsof -i tcp:8886 # 找到process id \nkill <process id>\n\n# Windows(对于Windows，必须以管理员身份运行命令提示符(the Command Prompt))\nnetstat -ano | findstr :8886  # 找到process id \ntaskkill /PID typeyourPIDhere /F\n```\n\n21 ftp\n22 ssh\n25 smtp\n80 http\n110 pop3\n139 smb\n143 imap\n443 https\n3306 mysql\n3389 rdp\n6379 redis\n8080 proxy\n\n```\n打开你的Terminal应用。\n键入下列指令，把「pid」替换为你的进程ID。例如，如果你要查询的进程ID是57508，你就应输入：lsof -i -P -n | grep 57508\n这段命令行的意义是：\n\nlsof代表“list open files”的意思，它会列出所有当前打开的文件描述符。\n-i只显示那些具有因特网地址的文件。\n-P让lsof以端口号的方式显示网络服务，而非服务名称（如http或ssh）。\n-n阻止lsof将网络数字地址转化成主机名。这会使得lsof运行得更快，因为它不用查找创建DNS请求了。\n```"},{"title":"组件库选型与设计","url":"/2021/04/13/组件库选型与设计/","content":"\n- 推荐阅读文档：\n聊聊 React 组件库的技术选型与设计\n原文链接： https://www.infoq.cn/article/DVOVMbTZ47DZMPFDXJ3y"},{"title":"事件处理面面观-逻辑需完备","url":"/2021/04/13/事件处理面面观-逻辑需完备/","content":"Once\n\n函数装饰器\n\n通过实例解释为什么是节流和防抖的中文含义\n\n本质上，利用定时器，来决定回调函数执行的时机\n\n\n\n节流（once的抽象）\n比如频繁给服务器发送请求，这是个很消耗资源流量的事，我们限制一个时间间隔发送，这就是节流啦\n\n防抖\n我们频繁触发某个事件的回调函数，比如canvas随着pi\n\n\n\n\n### 事件参考\nhttps://developer.mozilla.org/zh-CN/docs/Web/Events\n\n\n### 装饰器\n- https://medium.com/google-developers/exploring-es7-decorators-76ecb65fb841\n```\nAn ES2016 decorator is an expression which returns a function and can take a target, name and property descriptor as arguments. You apply it by prefixing the decorator with an @ character and placing this at the very top of what you are trying to decorate. Decorators can be defined for either a class, a method or a property.\n```\n装饰器（Decorator）是一种用于修改类、方法、属性或参数的语法糖。\n1. **Angular**：Angular 装饰器包括 `@Component`、`@NgModule`、`@Directive`、`@Input`、`@Output` 和 `@Injectable`。\n\n2. **MobX**：使用装饰器（如 `@observable`、`@action`、`@computed` 和 `@autorun`）轻松实现状态管理。通过使用这些装饰器，可以实现高效的响应式编程，使组件和状态更容易应对变化。\n\n3. **Nest.js**：大量使用装饰器，包括 `@Controller`、`@Get`、`@Post`、`@Inject` 和 `@Param` 等。\n\n\n装饰器目前仍处于实验性阶段，尚未成为 JavaScript 的正式特性。要在项目中使用装饰器，需要通过 Babel 或 TypeScript 进行转译。对于 Babel，安装相应的插件（如：`@babel/plugin-proposal-decorators` 和 `@babel/plugin-proposal-class-properties`）。对于 TypeScript，需要在 `tsconfig.json` 文件中设置 `\"experimentalDecorators\": true`。\n\n- https://github.com/tc39/proposal-decorators - stage:3 了 22.03\n- https://github.com/tc39/proposals\n\n截至目前（2022年1月），装饰器语法在 ECMAScript 提案流程中处于第二阶段（Stage 2）。在 ECMAScript 的提案过程中，共有四个阶段：\n\n1. Stage 0：策展阶段 - 提案的起点，任何人可以提交新功能或更改。\n2. Stage 1：征求意见阶段 - 此阶段需要一个正式的描述，并由至少一位成员支持。\n3. Stage 2：草案阶段 - 提案需要有一个规范的初稿，进入此阶段意味着该功能很有可能被纳入未来的 ECMAScript 版本。\n4. Stage 3：候选阶段 - 对规范进行详尽审查和实现。对提案进行微调，并完善规范的细节。\n5. Stage 4：完成阶段 - 提案已在多个引擎中得到实现并通过了测试。该提案将作为下一个 ECMAScript 版本的一部分，并正式发布。\n\n目前，装饰器语法处于草案阶段，这意味着该功能很有可能会被纳入未来的 ECMAScript 版本。但是，在提交到正式规范之前，它可能仍会发生变化。因此，建议在使用装饰器语法时利用 Babel 等工具来确保代码的兼容性。\n\n### 高阶函数\nVue 3.x 源码中充分利用了高阶函数（Higher-Order Functions，HOFs）的概念。高阶函数是指接受函数作为参数并/或返回函数作为结果的函数。\n\n以下是 Vue 3.x 源代码中一些使用高阶函数的例子。\n\n1. `computed` 函数（位于 `packages/reactivity/src/computed.ts` 文件中）\n\n   `computed` 函数接受一个函数作为参数，并返回一个具有响应式特性的新函数。这是一个很典型的将普通函数转换为响应式的高阶函数应用。\n\n2. `watch` 和 `watchEffect` 函数（位于 `packages/runtime-core/src/apiWatch.ts` 文件中）\n\n   这两个函数都接受函数作为参数，并且根据这些函数的结果来观察响应式数据的变化。这是一个非常常见的使用高阶函数进行数据观察的例子。\n\n3. `onBeforeMount`, `onMounted`, `onBeforeUpdate`, `onUpdated`, `onBeforeUnmount`, `onUnmounted` 生命周期方法（位于 `packages/runtime-core/src/apiLifecycle.ts` 文件中）\n\n   这些生命周期方法接受一个函数作为参数，这些函数会在对应的 Vue 组件生命周期阶段被执行。这是使用高阶函数管理组件生命周期的例子。\n"},{"title":"database开源学习之complete-intro-to-databases","url":"/2021/04/12/database开源学习之complete-intro-to-databases/","content":"## 网站指路\nhttps://btholt.github.io/complete-intro-to-databases/\n(这种开源资源，可以过一遍之后，当成search的参考资料来用)\n## Welcome\n1. Introduction\n2. Installation Notes\n3. Terminology\n## NoSQL\n1. NoSQL\nmongodb是基于文档对象模型的，曾经有段时间因为丢数据的问题，饱受争议，但是现在是相对稳定的啦\n2. MongoDB\n```\ndocker run --name test-mongo -dit -p 27017:27017 --rm mongo:4.4.1\ndocker exec -it test-mongo mongo\n\nshow dbs\nuse adoption\ndb.pets.insertOne({name: \"Luna\", type: \"dog\", breed: \"Havanese\", age: 8})\ndb.pets.help()\ndb.pets.findOne()\ndb.pets.count()\ndb.pets.insertMany(\n  Array.from({ length: 10000 }).map((_, index) => ({\n    name: [\n      \"Luna\",\n      \"Fido\",\n      \"Fluffy\",\n      \"Carina\",\n      \"Spot\",\n      \"Beethoven\",\n      \"Baxter\",\n      \"Dug\",\n      \"Zero\",\n      \"Santa's Little Helper\",\n      \"Snoopy\",\n    ][index % 9],\n    type: [\"dog\", \"cat\", \"bird\", \"reptile\"][index % 4],\n    age: (index % 18) + 1,\n    breed: [\n      \"Havanese\",\n      \"Bichon Frise\",\n      \"Beagle\",\n      \"Cockatoo\",\n      \"African Gray\",\n      \"Tabby\",\n      \"Iguana\",\n    ][index % 7],\n    index: index,\n  }))\n);\n```\n\n3. Querying MongoDB\n<pre>\n$gt - greater than\n$gte - greater than or equal to\n$lt - less than\n$lte - less than or equal to\n$eq - equals (usually not necessary)\n$ne - not equals\n$in - has the value in the array (MongoDB can store arrays and objects too!)\n$nin - does not have the value in the array\n</pre>\n```\n# findone\ndb.pets.findOne()\ndb.pets.findOne({ index: 1337 });\n# find\ndb.pets.find({ type: \"dog\" });\nit\nit\n# count , limit , and toArray\ndb.pets.count({ type: \"dog\" }); // probably pretty big number\ndb.pets.find({ type: \"dog\" }).limit(40);\nit; // after this the cursor will end\ndb.pets.find({ type: \"dog\" }).limit(40).toArray();\n# query operators\ndb.pets.count({ type: \"cat\", age: { $gt: 12 } });\ndb.pets.find({\n  type: { $ne: \"dog\" },\n  name: \"Fido\",\n});\n# logical operators\ndb.pets.find({\n  type: \"bird\",\n  $and: [{ age: { $gte: 4 } }, { age: { $lte: 8 } }],\n});\n# special operators , like $type $exists\n# sorts 1:ascending -1: descending\ndb.pets.find({ type: \"dog\" }).sort({ age: -1 });\n# projections\ndb.pets.find({ type: \"dog\" }, { name: 1, breed: 1 });\ndb.pets.find({ type: \"dog\" }, { name: 1, breed: 1, _id: 0 });\ndb.pets.find({ type: \"dog\" }, { name: true, breed: true, _id: false }); // note that true and false work too\ndb.pets.find({ type: \"dog\" }, { _id: 0 });\n```\n\n4. Updating MongoDB\n- insert本质上是做了（insertOne,insertMany）的工作；但是one/many的好处是，如果我们给了错误的输入，他会报错并让我们修正\n- delete deleteMany deleteOne / update updateMany/updateOne 也同上\n- replaceOne 会删除在更新对象中省略的，但存在与原有文档中但任何字段\n```\n# updates 第一个对象是查询，第二个对象是更新对象\ndb.pets.updateOne(\n  { type: \"dog\", name: \"Luna\", breed: \"Havanese\" },\n  { $set: { owner: \"Brian Holt\" } }\n);\n# 可用的更新操作符 https://docs.mongodb.com/manual/reference/operator/update/#id1\ndb.pets.updateMany({ type: \"dog\" }, { $inc: { age: 1 } }); \n# upsert - option 如果存在就更新，如果不存在，就创建一个新记录\ndb.pets.updateOne(\n  {\n    type: \"dog\",\n    name: \"Sudo\",\n    breed: \"Wheaten\",\n  },\n  {\n    $set: {\n      type: \"dog\",\n      name: \"Sudo\",\n      breed: \"Wheaten\",\n      age: 5,\n      index: 10000,\n      owner: \"Sarah Drasner\",\n    },\n  },\n  {\n    upsert: true,\n  }\n);\n# deletes 工作原理和查找类似\ndb.pets.deleteMany({ type: \"reptile\", breed: \"Havanese\" });\n# findAnd* （Update/Replace/Delete） \n# bulkWrite 大规模写入\n\n```\n\n5. Indexes in MongoDB\n```\n\n```\n\n6. Aggregation\n7. Write a Node.js app with MongoDB\n8. MongoDB Ops\n\n## SQL\n1. Intro to SQL Database\n2. PostgreSQL\n3. Querying PostgreSQL\n4. Complex SQL Queries\n5. JSON in PostgreSQL\n6. Indexes in PostgreSQL\n7. Node.js App with PostgreSQL\n8. Hasura\n9. PostgreSQL Ops\n\n## Graph\n1. Graph Databases\n2. 12Neo4j\n3. Neo4j Browser\n4. Complex Neo4j Queries\n5. Indexes in Neo4j\n6. Node.js App with Neo4j\n7. Neo4j Ops\n## Key-Value Store\n1. Key-Value Store\n2. Redis\n3. Redis Command Options\n4. Redis Data Types\n5. More Redis Concepts\n6. Node.js App with Redis\n7. Redis Ops\n## Conclusion\n1. Conclusion\n\n\n\n\n\n## PostgreSQL vs mysql\n\npostgis\ninstagram - python + PostgreSQL\n\n\n## PostgreSQL vs oracle"},{"title":"项目及信息安全","url":"/2021/04/12/项目及信息安全/","content":"\n1.库的安全性\n\n上传鉴权（接口部分对内容鉴权）\n\n2.客户端代码/库数据脱敏处理\n\n(客户敏感数据监控-手机号，敏感词)\n\n3.终端安全保护—— mcafee兼容\n\n4.客户端安全扫描集成到CI，dev ops 构建，更新代码，构建流程，做安全检测\n\n5.公有云API Key泄露\n\n6.新增SQL执行效率审计\n\n7.接口脱敏（掩码在服务端处理）\n\n8.不要上传公司相关的代码到github,百度网盘，语雀公开\n（可以通过扫描关键词，github接口）\n\n9.iast\n\n### API - 认证 授权 凭证\n- HMAC（AK/SK）认证方式，微信小程序-据code获取openid 的时候需要 appid appSecret\n- token 凭证\n- JWT 凭证的一种，复杂的token\n\n### 等保测评\n- https://baike.baidu.com/item/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%AD%89%E7%BA%A7%E4%BF%9D%E6%8A%A4/\n- 信息安全等级保护\n- 找第三方的公司进行\n### 浏览器安全\n- https://microsoftedge.github.io/edgevr/posts/bug-bounty-hunter-to-working-at-microsoft/\n\n### snyk\n- https://security.snyk.io/\n- 依赖vulnerable package"},{"title":"sentry实践","url":"/2021/04/12/sentry实践/","content":"\n### 部署\n\n#### sentry 私有化部署\n\n1.使用 docker 做私有化部署，依赖于官方的（https://github.com/getsentry/onpremise）\nOfficial bootstrap for running your own Sentry with Docker.\n\n2.环境需求：\nDocker 19.03.6+\nCompose 1.24.1+\n4 CPU Cores\n8 GB RAM\n20 GB Free Disk Space\n\n3.具体操作可见官方文档：https://github.com/getsentry/onpremise\n简单一句话：如果使用默认值的配置，只需要克隆项目，然后在本地运行 ./install.sh 就可以了\n\n4.具体配置：The recommended way to customize your configuration is using the files below, in that order:\n\nsentry 目录下 ——\n\nconfig.yml\nsentry.conf.py\n.env w/ environment variables\n\nconfig.example.yml ——\n\n如要修改时区\n\n```\ndocker ps\nlocate sentry.conf\nvim sentry.conf.py\n增加 SENTRY_DEFAULT_TIME_ZONE = 'Asia/Shanghai'\ndocker restart sentry_onpremise_web_1\n```\n#### update - https://github.com/getsentry/self-hosted\n- self-hosted 私有化部署已更新为这个项目\n# Mail Server\n\n这里面需要申请一个公司的邮箱，配置到 mail.username 里面\n\n# System Settings\n\nsystem.internal-url-prefix: '申请个外网域名'\nsystem.url-prefix: '同上'\n\nrequirements.example.txt ——\n如果需要集成 dingding,可以在这个里面添加 plugin\n(https://github.com/anshengme/sentry-dingding)\n\n#### 私有化部署的几个小坑\n\n- 推荐阅读案例：https://segmentfault.com/a/1190000038839629 ， https://xupeiyao.github.io/2020/01/24/deploy_sentry/\n\n1. 及时关注修复的 bug\n   https://github.com/getsentry/onpremise/issues/635\n\n比如 10 年上半年部署的项目，查出来，如果修改了 nginx/nginx.conf 里面的配置的\n\n```\n\tlog_format main '$remote_addr - $remote_user [$time_local] \"$request\" '\n\t'$status $body_bytes_sent \"$http_referer\" '\n\t'\"$http_user_agent\" \"$http_x_forwarded_for\"';\n```\n\n查 docker logs 的时候，并不会有新增的 x_forwarded_for 的输出（如果 nginx.conf 里面写了会导致报错的配置，报错是立刻的）\n需要再加下\n\n```\n\taccess_log /var/log/nginx/access.log main;\n```\n\n官方文档参考：http://nginx.org/en/docs/http/ngx_http_log_module.html\n\n2.取真实 IP，需要在部署的 sentry.xxx.xx.cn 的 nginx 里面，增加对信息的透传\n\n```\nproxy_set_header X-Forwarded-Proto  $scheme;\nproxy_set_header X-Real-IP $remote_addr;\nproxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n```\n\n3.部署的 onpremise，查各种问题，日志就可以用 docker 了\n\n```\ndocker ps\ndocker inspect\ndocker restart\n```\n\n### 项目应用\n\n#### 文档指南\n\nhttps://docs.sentry.io/\n\n#### sourcemap 上传\n\nsentry 上传 sourcemap 配置\n\n- 可以用@sentry/webpack-plugin\n- sentry cli(https://docs.sentry.io/platforms/javascript/sourcemaps/uploading/)\n- .sentryclic - release | urlPrefix\n\n- auth token\n\n#### web 项目\n\n- @sentry/browser\n- @sentry/integrations 如果是 Vue 项目\n\n```\nimport * as Sentry from '@sentry/browser'\nimport * as Integrations from '@sentry/integrations'\nSentry.init({\n  release: ,\n  environment: ,\n  dsn: \"\",\n  integrations: [new Integrations.Vue({\n      Vue,\n      attachProps: true\n    })]\n})\n```\n\n不同版本的 sentry 也提供了不同的方式，按照文档说明选择和更新即可\n\n- sourcemap 上传配置\n\n#### electron 项目\n\n- @sentry/electron(https://docs.sentry.io/platforms/javascript/guides/electron/)\n  - @sentry/electron is the official Sentry SDK for Electron applications. It can capture JavaScript exceptions in the main process and renderers, as well as collect native crash reports (Minidumps).\n  - 可以捕获主进程和渲染器中的 JavaScript 异常，也可以收集本地崩溃报告（Minidumps）。\n- crashReporter\n\n```\nimport * as Sentry from '@sentry/electron';\nimport { crashReporter } from 'electron';\nSentry.init({ dsn: '' });\ncrashReporter.start({\n        companyName: '',\n        submitURL: 'sentry的',\n        uploadToServer: true,\n        ignoreSystemCrashHandler: true\n    });\n```\n\n#### 小程序原生项目\n\n前置：需要在管理后台配置 sentry 的域名\n\n开源封装的库：\n\n- https://github.com/lizhiyao/sentry-miniapp\n\n- https://github.com/youzan/raven-weapp (旧)\n\n- 可以直接接JS的sentry SDK\n\n- 现在基本上文档上面都有 migration （从 raven-xxx 到 sentry-xxx）\n### 基本操作\n\nDSN 查询：\nproject => settings => client keys\n\n1.定义日志异常上报方法 2.区分环境（开发，测试，生产）\n\n### 手动上报\n- .captureException\n- .captureMessage\n\n### 更多信息\n- .configScope\n- scope.setUser | scope.setExtra\n```\nsentryConfigureScope({\n\ttags: { xxx: xxx }\n})\n```\n### 目前配置工作流\n- new Alert - 邮件提醒 （这部分如果想连钉钉也可以，原来要dingding插件，现在直接配置里面都能关联）\n- 我这边看问题 - 提 issue ，link  到gitlab, gitlab issue 走 webhooks 到钉钉群里\n## 问题处理\n### Vue\n\n```\n# 这段如果不加的话，写在.Vue文件里面的错误，就抛不到sentry上；但是写在.js文件里面抛的错误能到sentry上(当引用的是sentry/browser这个SDK的时候)\n  Vue.config.errorHandler = err => {\n    Sentry.captureException(err)\n  }\n# 直接引用 sentry/vue的话，就可以不需要再引用上面的了，因为已经处理了\n```\n\n### Flutter\n- 调试不要用ios模拟器，网络上面不会请求也不会报错\n    - 解决网络问题：Mac的网络偏好设置-->高级-->代理-->把网页代理和安全网页代理前面的勾去掉\n- android调试网络没有问题，可以直接调试\n- 真机调试，允许网络(局域网+蜂窝)+查找并连接到本地的网络设备（好），就可以了\n- https - DSN\n- 确保sentry初始化走通了\n\n\n### Linux\n- 服务器上下载sentry-cli包：\n- ```info sentry-cli Downloading from https://npm.taobao.org/mirrors/sentry-cli/1.69.1/sentry-cli-Linux-x86_64```有问题的话，则可以配置淘宝镜像的源\n- npm config set sentrycli_cdnurl https://npm.taobao.org/mirrors/sentry-cli\n\n# basic 原理\n\n- issues\n- event - fingerprint\n\n## python\n- 可购买服务\n- 可私有化部署\n## search\n- https://docs.sentry.io/product/discover-queries/query-builder/\n- https://docs.sentry.io/product/sentry-basics/search/\n- 支持wildcard匹配\n\n## clickhouse\n- https://github.com/ClickHouse/ClickHouse\n\n### react-native\n- https://docs.sentry.io/platforms/react-native/"},{"title":"node-ffi-napi","url":"/2021/04/12/node-ffi-napi/","content":"### 文档指南\nhttps://github.com/node-ffi-napi/node-ffi-napi\n\n### 历史进展\n- ffi\n- ffi-napi - A foreign function interface (FFI) for Node.js, N-API style\n1、ffi（不支持node12及以上）这个项目太老了。NODE_MODULE_VERSION只支持到64,超过编译就报错，不管是node-gyp或者electron rebuild。\n也就是说只要nodejs超过v12，则node-ffi编译就会报错，提示各种函数类型参数等不正确，只能node<v12来编译。。。\n2、node：https://nodejs.org/zh-cn/download/releases/\nelectron:https://github.com/nodejs/node/blob/master/doc/abi_version_registry.json\n对应两者的NODE_MODULE_VERSION,版本不相等则无法在electron调用node-ffi。\n3、c模式的dll可以使用node-ffi，缺点nodejs不支持v12及以上，停更了\n4、c++模式的dll，node-ffi-napi， 支持到nodejs v14.x - 可以看提交记录message\n\n### 概述\n<pre>\nNode.js Foreign Function Interface for N-API\n\nnode-ffi-napi is a Node.js addon for loading and calling dynamic libraries using pure JavaScript. It can be used to create bindings to native libraries without writing any C++ code.\n\nnode-ffi-napi是一个Node.js插件，用于使用JavaScript加载和调用动态库。它可以用来创建与本地库的绑定，而无需编写任何C++代码。\n\nIt also simplifies the augmentation of node.js with C code as it takes care of handling the translation of types across JavaScript and C, which can add reams(大量) of boilerplate code to your otherwise simple C. See the example/factorial for an example of this use case.\n它还简化了用C代码的拓展node.js，因为它负责处理跨JavaScript和C的类型转换，这可能会给你原本简单的C语言增加大量的模板代码。\n\nWARNING: node-ffi-napi assumes you know what you're doing. You can pretty easily create situations where you will segfault the interpreter and unless you've got C debugger skills, you probably won't know what's going on.\n警告：除非get C debugger的技能，不然谨慎操作，因为很容易造成解释器崩溃的情况。\n\nWARNING: The original API of node-ffi is left mostly untouched in the N-API wrapper. However, the API did not have very well-defined properties in the context of garbage collection and multi-threaded execution. It is recommended to avoid any multi-threading usage of this library if possible.\n\n警告：在N-API包装器中，node-ffi的原始API大部分没有被触动。然而，在垃圾收集和多线程执行的情况下，该API并没有非常明确的属性。建议尽可能避免对该库进行任何多线程使用。\n\n</pre>\n\n\n### 名词解释\n- A segmentation fault (aka segfault) is a common condition that causes programs to crash; they are often associated with a file named core . Segfaults are caused by a program trying to read or write an illegal memory location\n\n- https://en.wikipedia.org/wiki/Segmentation_fault\n\n\n### N-API\n"},{"title":"benchmark","url":"/2021/04/12/benchmark/","content":"\n### benchmark 概念\n\nhttps://en.wikipedia.org/wiki/Benchmark_(computing)\n\n### npm-benchmark\n\nhttps://www.npmjs.com/package/benchmark\n\n### 文档说明\n\nhttps://benchmarkjs.com/docs\n\n### 框架推荐\n\nhttps://github.com/caderek/benny\n\n很简单的 benchmark 的框架\n\n```\nBenny builds on top of the excellent (but complex) benchmark package.\n\nBenny provides an improved API that allows you to:\n\neasily prepare benchmarks for synchronous, as well as async code,\nprepare local setup (sync or async) for each case,\nskip or run only selected cases,\nsave results to a JSON / CSV / HTML (table or chart) file,\npretty-print results without additional setup,\nuse suite results as Promises.\nAdditionally, it provides sound defaults suitable for most use cases (that you can tweak if you need) and excellent IDE support with built-in type definitions.\n```\n"},{"title":"缓存面面观","url":"/2021/04/06/缓存面面观/","content":"> 相关文章“浏览器基础梳理”\n\n## basic\n### HTTP缓存\n#### 失效策略划分\n```\n强缓存\n协商缓存\n```\n#### 文档\n- https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching\n- https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching\n- https://web.dev/http-cache/\n- https://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html\n### 浏览器缓存\n#### 按照缓存位置:\n```\nService Worker Cache\nMemory Cache\nDisk Cache\nPush Cache\n```\n#### 存储型缓存\n```\nCookie\nWeb Storage\nIndexedDB\n```\n### 问题解决\n参考链接：\nhttps://mp.weixin.qq.com/s?__biz=MjM5ODYwMjI2MA==&mid=2649747766&idx=1&sn=4850153cd1664f79915d00b1791de5c0&chksm=bed3624d89a4eb5bdb228808e44941a538c635528a67bfeb8b8be36e39d2a2c22e10aa2db28b&mpshare=1&scene=1&srcid=0716mA1OP9VZdNF0Zq3hSscz&sharer_sharetime=1594887512158&sharer_shareid=7125c06b0fe98b972a022497973e5fc5&key=e7bdc15d285ac0a93882c4919aa1bed8f1e686207f3e7877441b3471d89ac61967ecf2a599a619fa59e86f83ccfe19bad1d8aec829b993e354415c1dc788cfda66af09b42b510554144b91685231d8f5&ascene=0&uin=MjY2OTI1MDMyOQ%3D%3D&devicetype=iMac+MacBookAir6%2C1+OSX+OSX+10.13.4+build(17E199)&version=11020012&lang=zh_CN&exportkey=A%2FN7Zh6M%2B4H4dmKmzcRcgyk%3D&pass_ticket=W%2BABhlERzXA5PqTmfy2KtphIUZPCtutAm8G9hQotQsGVIZOdyO%2BwRISlM4qrnv20&wx_header=0\n\n\nHTTP 协议针对这个问题的解决方案，就是客户端缓存。从 HTTP/1.0 到 1.1、再到 2.0 版本的演进中，逐步形成了现在被称为“状态缓存”、“强制缓存”（或简称为“强缓存”）和“协商缓存”这三种 HTTP 缓存机制。这其中的状态缓存，是指不经过服务器，客户端直接根据缓存信息来判断目标网站的状态。以前只有 301/Moved Permanently（永久重定向）这一种；后来在RFC6797中增加了HSTS（HTTP Strict Transport Security）机制，用来避免依赖 301/302 跳转 HTTPS 时，可能产生的降级中间人劫持问题\n\n\n"},{"title":"sessionStorage使用","url":"/2021/04/06/sessionStorage使用/","content":"文档指路：https://developer.mozilla.org/zh-CN/docs/Web/API/Window/sessionStorage\n书籍参考：高程=>23章 离线应用与客户端存储 => 23.3 数据存储 => 23.3.3 web存储机制\n\n### Web Storage:\n<pre>\nWebStorage的目的是克服由cookie带来的一些限制，当数据需要被严格控制在客户端上时，无须持续地将数据发回服务器。\nWebStorage的两个主要目标是：\n提供一种在cookie之外存储会话数据的途径；\n提供一种存储大量可以跨会话存在的数据的机制。\n\n泽卡斯(Zakas. Nicholas C.). JavaScript高级程序设计(第3版) (图灵程序设计丛书) (Chinese Edition) (Kindle 位置 22327-22330). 人民邮电出版社. Kindle 版本. \n\n</pre>\n\n!!!Storage类型只能存储字符串。非字符串的数据在存储之前会被转换成字符串。\n\nsessionStorage对象是Storage的一个实例\n\nsessionStorage对象应该主要用于仅针对会话的小段数据的存储。如果需要跨越会话存储数据，那么globalStorage或者localStorage更为合适。\n\n\n应用场景：\n1.对网页的崩溃进行监控\nwindow对象：load && beforeunlaod事件\nsessionStorage\n\n\nwindow.addEventListener('load', () => {    sessionStorage.setItem('good_exit', 'pending') })\nwindow.addEventListener('beforeunload', () => {    sessionStorage.setItem('good_exit', 'true') })\nif(sessionStorage.getItem('good_exit') &&    sessionStorage.getItem('good_exit') !== 'true') {    // 捕 获 到⻚⾯崩溃 }\n\n\n代码很 简单，思路 是 ⾸先 在⽹⻚ load 事件的回调 ⾥：利 ⽤ sessionStorage 记录 good_exit 值为 pending；接下来，在⻚⾯⽆异常退出前，即 beforeunload 事 件回调中，修改 sessionStorage 记录的 good_exit 值为 true。因此，如果⻚⾯ 没有崩溃的话，good_exit 值都会在离开前设置为 true，否则就可以通过 sessionStorage.getItem('good_exit') && sessionStorage.getItem('good_exit') !== 'true' 判断出⻚⾯崩溃，并进⾏处理。\n框架的错误处理\n\n如果你的应⽤部署了 PWA，那么便可以享受 service worker 带来的福利！在这 ⾥，可以通过 service worker 来完成⽹⻚崩溃的处理⼯作。基本原理在于： service worker 和⽹⻚的主线程独⽴。因此，即便⽹⻚发⽣了崩溃现象，也不会 影响 service worker 所在线程的⼯作。我们在监控⽹⻚的状态时，通过 navigator.serviceWorker.controller.postMessage API 来进⾏信息的获取和记 录。\n\n\nHTML5 提供了两种在客户端存储数据的新方法：\n\t•\tlocalStorage - 没有时间限制的数据存储\n\t•\tsessionStorage - 针对一个 session 的数据存储\n\n\nlocalStorage is similar to sessionStorage, except that while data stored in localStorage has no expiration time, data stored in sessionStorage gets cleared when the page session ends — that is, when the page is closed.\n\n\nIt should be noted that data stored in either localStorage or sessionStorage is specific to the protocol of the page.\n\n\n1. Host\n描述请求将被发送的目的地，包括，且仅仅包括域名和端口号。在任何类型请求中，request都会包含此header信息。\n2. Origin\n用来说明请求从哪里发起的，包括，且仅仅包括协议和域名。这个参数一般只存在于CORS跨域请求中，可以看到response有对应的header：Access-Control-Allow-Origin。\n3. Referer\n告知服务器请求的原始资源的URI，其用于所有类型的请求，并且包括：协议+域名+查询参数（注意，不包含锚点信息）。\n因为原始的URI中的查询参数可能包含ID或密码等敏感信息，如果写入referer，则可能导致信息泄露。\n\n\nA Storage object which can be used to access the current origin's local storage space.\n\nThe following snippet accesses the current domain's local Storage object and adds a data item to it using Storage.setItem().\nlocalStorage.setItem('myCat', 'Tom');\n\nThe syntax for reading the localStorage item is as follows:\nvar cat = localStorage.getItem('myCat');\n\nThe syntax for removing the localStorage item is as follows:\nlocalStorage.removeItem('myCat');\n\nThe syntax for removing all the localStorage items is as follows:\n// clear all items\nlocalStorage.clear();\n\n#### localStorage 的封装lib\n- store.js\n - https://github.com/marcuswestin/store.js\n - 浏览器兼容\n - 对字符串的处理（项目里面，如果不系统处理，在直接使用API的时候，每个人需要都处理一遍）\n\n#### 移动端\n- Note: 从iOS 5.1之后，移动端的Safari将localStorage数据存储在cache文件中，在操作系统的要求下，会偶尔进行清除，特别是空间不足时。\n- http://dev-test.nemikor.com/web-storage/support-test/\n\n\n#### localstorage\n- 同域跨页面通信可以借助localstorage的storage事件的监听，做一些处理；\n- https://html.spec.whatwg.org/multipage/webstorage.html#the-localstorage-attribute"},{"title":"wps开放平台","url":"/2021/04/06/wps开放平台/","content":"https://open.wps.cn/docs/cloud/cloudfile-ability/manage/api-list\n\n### 文档在线预览编辑服务\n参考示例：https://blog.csdn.net/qq_23501739/article/details/103032741\n\nhttps://wwo.wps.cn/docs/\n\n- 前端接入：\nhttps://wwo.wps.cn/docs/front-end/introduction/quick-start\n\n前端部分参考：https://gitee.com/mose-x/wps-view-vue\nJava部分参考：https://gitee.com/mose-x/wps-view-java.git\n\n### 中台系统\n商业化其实还有待进一步深化\n\n开发对接的时候能明显感受到这个状况\n\n### 其他服务提供商\n- https://cloud.tencent.com/document/product/460/52518\n- 数据万象- 文档转html"},{"title":"open-source-开源-study","url":"/2021/04/04/open-source-开源-study/","content":"### 推荐站点\nhttps://snyk.io/advisor/\n\n### Workshop\n- https://slides.com/kentcdodds/write-oss\n- 有如何写一个open source software 相关资源\n### CI(持续继承)\n- https://www.travis-ci.org/\n- circleci.com\n\n#### 提交(precommmit,aftercommit)\n#### 构建部署（Jenkins，travis-ci）\n#### 测试（构建前-单测，构建后-功能）\n#### 版本控制（新增，备份，回滚）\n\n### 单测\n- 覆盖率\ncodecov.io\ncoveralls.io\n\n### 文档\ngithub.io\ngitee.io（网络问题，可以作为镜像站点试试）\nwww.netlify.com\nvuepress\n\n### issue （bug or feature需求）\n- 让用户按照模版提issue\n- 利用插件提高issue管理效率：\n  - github.com/apps/close-issue-app\n  - issue-helper\n    - https://github.com/vuejs/vue-issue-helper\n    - (https://vuecomponent.github.io/issue-helper/?lang=zh)——ant-design-vue提供的提issue的模版界面\n  - https://github.com/dessant/lock-threads —— 锁死不活跃的issue，用户不能再回复了\n\n\n### 前端开源项目分类\n  - CMS/blog Framework (hexo, ghost)\n  - JavaScript Library/Framework (vue, react, jquery)\n  - Plugin (bootstrap, vuex, vue-router)\n  - utility(lodash, commander.js, underscore)\n\n### 自由软件（若为自由故）\n\n### 项目结构组织\n#### 授权协议 \n- LGPL/GPL/BSD/MIT/Apache\n\n#### 环境\n> 让开发者能快速上手\n> 提供docker环境\n- 开发者环境\n- 依赖环境\n- 部署环境\n\n#### Example\n类似于ElementUI，example就很完整全面\n- API演示\n- 扩展演示\n- 基本用法/高级用法\n\n#### 版本控制\n开发/Beta/Release\n详细可见博文：软件版本\n\n#### 社区\n- bug反馈\n- 特性讨论\n- 扩展插件\n\n#### 自动集成\n- 自动部署\n- 自动测试\n- 环境检查\n- 跨浏览器测试\n\n#### 构建\n> 脚本 + 这一套工具也需要开放给开发者\n- 编译工具\n- 冗余文件清理\n- 格式化\n- 版本文档更新\n- 合并压缩优化\n- 发布\n\n#### 文档\n- API说明\n- README\n- 多语言支持\n- 快速上手\n- 最佳实践\n- 开发者文档\n- 注释doc工具\n  \n\n#### 源码\n- 模块组织方式\n- 代码规范 - code of conduct\n- 提交格式\n- 语法检查 - lint工具\n\n#### 测试\n- 命令行测试\n- 浏览器测试\n- 测试覆盖率\n\n### 结构设计原则\n\n#### 分离原则\n- 源码\n- 调试编译-debug\n- 编译部署\n\n#### 子系统\n- git submodule\n- 包管理工具\n- 协助分组（organization，child project）\n```\n/ 下载子模块\n$ git submodule update --init --recursive\n```\n```\n.gitmodules\n[submodule \"XXXX\"]\n\tpath = XXXX\n\turl = https://github.com/xxx/XXXX.git\n```\n\n\n\n### 推广\n#### 官网\n- 在线站点\n- 友情链接赞助\n\n#### 论坛社区\n- BBS\n- 问答社区\n\n### 解决反馈和处理PR\n\n\n#### 技术会议\n\n#### 文档沉淀\n- wiki/issues/pages\n\n#### blog/专栏\n\n#### 投稿\n公众号/技术社区\n\n\n### opensource-guide-summary"},{"title":"vue-daily-notes","url":"/2021/04/04/vue-daily-notes/","content":"\n## 文档概览\n\n### 安装\nhttps://cn.vuejs.org/v2/guide/installation.html\n- 注意不同版本最合适用的场景（开发，生产）\n\n### 模版语法\n- 数据绑定最常见的形式就是使用“Mustache”语法 (双大括号) 的文本插值（https://mustache.github.io/）\n\n### 指令\n- 可以简单不严谨的理解为有点像标志位，Vue底层根据标记做对应处理\n- https://cn.vuejs.org/v2/guide/syntax.html#%E6%8C%87%E4%BB%A4\n- v-if/v-else/v-for（因为模版语法只能表达式，无法语句，所以提供这些指令）\n\n### 组件\n- https://cn.vuejs.org/v2/guide/components.html#%E7%BB%84%E4%BB%B6%E7%9A%84%E7%BB%84%E7%BB%87\n- 解决的问题：复用\n- 页面抽象成组件树\n- Vue.component()，如果通过这个注册组件，name要唯一的\n- 注意组件中的data(function返回的对象)，vm中的data(对象) —— 因为组件要复用，一个组件的 data 选项必须是一个函数，因此每个实例可以维护一份被返回对象的独立的拷贝\n- template —— 模版字符串\n- Prop 是你可以在组件上注册的一些自定义 attribute。当一个值传递给一个 prop attribute 的时候，它就变成了那个组件实例的一个 property。\n- 如果没有props声明的一些属性，会默认挂在template的最外层（根）结点上\n- why\n  - 当method里面逻辑过多，相似逻辑 => 拆分成独立的方法\n  - 当html类似，重复 => 拆分html\n  - 同上，样式\n  \n\n### 事件\n- https://cn.vuejs.org/v2/guide/events.html\n- ```v-on:click=\"statement\"```\n- 事件修饰符：在事件处理程序中调用 event.preventDefault() 或 event.stopPropagation() 是非常常见的需求。尽管我们可以在方法中轻松实现这点，但更好的方式是：方法只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。为了解决这个问题，Vue.js 为 v-on 提供了事件修饰符。（https://cn.vuejs.org/v2/guide/events.html#%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6）\n- 按键修饰符，按键码\n- 自定义事件：https://cn.vuejs.org/v2/guide/components-custom-events.html\n- 鼠标事件，移动端的事件\n\n### 插槽\n- https://cn.vuejs.org/v2/guide/components-slots.html\n- Vue 实现了一套内容分发的 API，这套 API 的设计灵感源自 Web Components 规范草案，将 <slot> 元素作为承载分发内容的出口。\n- 注意2.6语法：v-slot\n- 可以当成较为复杂的属性来看，复杂的属性没法直接写在传递信息里面，所以利用插槽的方式传递复杂内容\n- 具名插槽\n- 作用域插槽：本质上是传递的是返回组件的函数\n\n### 单文件组件(在guide的工具类别下)\n- https://cn.vuejs.org/v2/guide/single-file-components.html\n- @vue/cli \n  - vue --version\n  - vue create test\n  - Vue 3 => @vue/cli v4.5 => vue updrage --next\n  - 可以自己设置选项\n- components => 注册，作用域只在这个文件\n- scoped，会在样式上面带上hash [data-xxxx]\n- v-model 语法糖，简写 :value=\"message\" @input=\"handleChange\",本质上还是单向数据流(https://cn.vuejs.org/v2/guide/components-custom-events.html#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6%E7%9A%84-v-model)\n- .sync(可关注Vue3的差异)\n\n### 虚拟DOM\n- jquery(事件，DOM => 随着逻辑的复杂，会比较乱)\n- vue(事件，state，DOM) => Virtual DOM(state+template=>DOM树) => Virtual DOM Diff(时间复杂度) \n- 算法 => 时间复杂度，通用性\n- 同层级节点比较 => 移动节点 ｜ 删除新建 | 更新删除新建(无key) | 移动(有key) | 插入(有key) => 有key就有唯一标识符了，就可以把一些更新删除新建的问题改成了移动和插入的问题 => index的问题：如果是自定义的组件，简单的展示问题不大，但是list如果有删除添加排序，就会有问题\n\n### 组件更新的触发\n- 数据驱动\n- 没有特殊情况不要操作DOM！！！=> review代码的时候经常发现这个问题\n- 数据来源(单向的)\n  - 来自父元素的```属性```-外部数据(https://cn.vuejs.org/v2/guide/components-props.html#%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81)\n  - 来自组件自身的```状态```data-内部数据(https://cn.vuejs.org/v2/api/#data)\n  - 来自状态管理器-vuex|Vue.observable(https://cn.vuejs.org/v2/api/#Vue-observable)\n\nTIPS：\n- 调试\n<pre>\n开发中，我们可以用console里面\nvar vm = new Vue({...})\n修改 vm.testdata.testattr \n对实例进行修改调试\n</pre>\n\n\n### \n\n## API\n\n### 组件基础\n#### 动态组件\n- 有的需求会想要在两个组件间来回切换，比如 Tab 界面\n- 当使用 <component :is=\"...\"> 来在多个组件间作切换时，组件会在被切换掉后卸载。我们可以通过 <KeepAlive> 组件强制不活跃的组件仍然保持“存活”的状态\n### options API\n#### options: State\n- 一个返回组件实例初始响应式状态的函数\n- data : A function that returns the initial reactive state for the component instance.\n- 定义为一个函数而不是对象 => 因为对象会互相影响\n- https://staging-cn.vuejs.org/api/options-state.html#data\n```\ninterface ComponentOptions {\n  data?(\n    this: ComponentPublicInstance,\n    vm: ComponentPublicInstance\n  ): object\n}\n```\n\n\n### 内置组件\n#### KeepAlive\n- https://staging-cn.vuejs.org/guide/built-ins/keep-alive.html#basic-usage\n- 可以用include正则匹配"},{"title":"vue-workshop-notes","url":"/2021/04/03/vue-workshop-notes/","content":"> 以前听的Evan You的一个workshop的笔记\n\n### Reactivity \n- imperative/declarative\n  <pre>\n  命令式和声明式\n  我们先把命令式的行为转为声明式的，可以通过函数（声明关系），再进一步抽象，抽象成模版语言\n  view = render(state)是视图渲染系统都用的高度抽象的模式\n  我们不允许用户任意操控状态，而是让他们总是来调用一个函数来操控状态\n  对于这个函数，react中就是setState, 但是在Vue和Angualr中，我们不需要调用setState，angularJS用dirty checking实现（比较旧的版本了），拦截实践，然后执行一个digest cyle, 就不管有没有变化，都会检查；但是Vue要做得更精细一点，会把state 对象变成响应式的\n  用ES5 的 object.defineProperty API来将所有property都变成getters and setters\n  刚刚的方法，其实是一个很基本的依赖追踪的形式，knockout.js,meteor tracker,vue,mobx中都是这样的\n  </pre>\n\n- getters and setters\n  <pre>\n  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty\n  </pre>\n\n\n  ## Words\n  ## intro\n- ins and outs 来龙去脉\n- our agenda comprises of 议程包括\n- resemble 类似\n- under the hood 在底层\n- field them with Vue.use, the API.\n- And kind of walk you through how to use render functions in the Vue context 并指导你如何在Vue上下文中使用渲染函数\n\n### reactivity\n- is like streams and stuff 像流之类的东西\n- when you change the state and how the state reflects in the update of the entire system.\n- So this is a very naive imperative solution right? 所以这是一个很幼稚的命令式解决方案吧？\n- procedural 程序性的\n- the b1 cell is always kept in sync per(按照-in accordance with) the requirements of the spreadsheet\n- So this internal representation, view = render(state) is the very high level abstraction of how all the view rendering systems work.\n- So we'll not really bother with the details in here because it involves detailed DOM, DOM implementations, virtual DOM implementations and all that.所以我们就不去管这里面的细节了，因为这涉及到详细的DOM，DOM实现，虚拟DOM实现等等。\n- look into 研究\n- in a nutshell 简而言之\n- granular adj.含颗粒的，颗粒状的； 粗糙的；\n- in the sense that \n  - \"In the sense that\" is correctly used to distinguish between two possible senses (approximately meanings) of a word or phrase. So:\"This fact is funny, in the sense that it makes me laugh\" or \"This fact is funny, in the sense that it is strange\".\n  - This phrase is an explanatory linking phrase, used to link two parts of a sentence together so that it is clear that the first statement is being explained by or contrasted with the second part.\n- This is essentially a basic form of dependency tracking that's commonly shared in Knockout.js, Meteor Tracker, and Vue.js and MobX. MobX is a state management pattern for React.\n\n### getters and setters\n\n- essentially 本质上\n- arbitrary values 任意值\n- to assert whether your current implementation is correct 以确定您当前的实现是否正确\n- access and assignments 访问和赋值\n- And this class will have two methods, depend and notify 这个类会有两个方法，依赖和通知\n- associate 关联\n- go half through the time 时间过半\n- So the catch here is 所以这里的问题是\n- So this variable will always point to something that references this 所以这个变量将始终指向引用这个变量的东西\n\n### dependency tracker\n- That's the whole point, right? 这就是重点，对吧？\n- so we can just take the subscriber function and just invoke it 所以我们可以直接使用订阅者函数并调用它\n- That's pretty much it 这就差不多了\n- this wrapped update 封装的更新\n- we need to clean up stale dependencies 我们需要清理过时的依赖关系\n- This is not accounted for 没有考虑到的\n\n### mini observer\n- mutate a property 改变一个属性\n- fill in the blanks 填空\n- to this point 到此为止\n\n\n\n## intro writing plugins\n\n\n\n\n### writing a simple plugin\n\n\n\n### render functions\n\n\n\n\n### \n(Essentially) A lightweight JavaScript data format to represent what the actual DOM should look like at a given point in time (本质上)一个轻量级的JavaScript数据格式来表示实际的DOM在一个给定的时间点应该是什么样子的。"},{"title":"container相关","url":"/2021/04/03/container相关/","content":"## 概念\n### OOM Killer \n\n## 进程\n### kill 1 ｜ kill -9 1\n"},{"title":"docker-node-k8s项目实践总结","url":"/2021/04/03/docker-node-k8s项目实践总结/","content":"> docker - 容器技术 - 在当前操作系统内运行一个专用的操作系统环境\n> 保持环境的一致性（开发，生产）\n> kubernetes - 容器编排系统 - 管理多个Docker容器（管理Docker的生命周期和扩展Docker容器的规模）\n> 特性和API会过时，但通用的概念不会;概念及特定语言的相关框架的实现;对内核的扩展，包含一些现成的模块和功能\n### 项目介绍\n```\n#FROM xxx.xxx.xxx.cn/pub/nodejs:12.2.0_new\nFROM xxx.xxx.xxx.cn/pub/nodejs:12.2.0_update\nARG VERSION\nWORKDIR /xxx/xxx_target\nCOPY $VERSION/xxx_target.zip /xxxx/xxx_target\n\nRUN  yum -y install  unzip ;  unzip xxx_target.zip ; /usr/bin/cp -r ./dependency/* /usr/share/fonts/ ; rm -f xxx_target.zip.zip \nENTRYPOINT pm2 start ecosystem.config.js --env production --no-daemon\n```\n- unzip xxx_target.zip生成的流水线是：拉取gitlab代码，git pull && npm i && npm run ts:build\n- 私有仓库是容器化部门构建的私有化仓库，基于harbor（https://github.com/goharbor）\n- 日志落到集团kibana上面(https://github.com/elastic/kibana)\n- 容器的性能和情况监控是在集团的grafana上面（https://github.com/grafana/grafana）\n- mq,rabbitmq - 上部署的web管理端可以查看情况\n- 最开始消费者是虚拟机和pod都有，我们根据ip段区分\n- https://github.com/puppeteer/puppeteer/blob/main/docs/troubleshooting.md\n- `pm2 --no-daemon`命令表示以非守护进程的方式启动pm2进程。在这种方式下，pm2进程会被启动在前台，并会将日志输出到控制台，同时终端窗口关闭后pm2进程也会随之退出。这种方式通常用于调试以及在Docker等容器环境下运行pm2进程。如果要停止以非守护进程的方式启动的pm2进程，只需要在终端窗口中按下 `Ctrl+C` 即可\n- Docker 要求内部服务进程在前台模式下运行\n```\n- 如果在进程管理器中运行 Node.js 应用程序而不使用前台模式，进程管理器会不断启动新的进程。这是因为进程管理器无法监控后台进程的运行状况，因此它无法保证在某个进程失败时立即启动另一个进程。相反，在前台模式下，进程管理器可以检测到进程是否崩溃并立即启动另一个进程，从而保持应用程序的可用性。因此，在使用 systemd、supervisord 等进程管理器时，建议始终将 Node.js 应用程序配置为前台模式运行。\n- 在使用 pm2 进行 Node.js 应用程序的进程管理时，并不要求应用程序必须以前台模式运行。相反，pm2 会将 Node.js 应用程序从前台模式转换为后台模式并启动进程，以便进程管理器可以在应用程序崩溃时根据需要自动重启应用程序。这样，即使某个进程崩溃，pm2 也可以自动将其重启，从而保持应用程序的可用性。因此，在使用 pm2 时，可以将 Node.js 应用程序设置为后台模式运行，以提高系统的稳定性。\n```\n```\nDocker 在运行容器时会启动一个 init 进程，这个进程负责容器内的进程管理和信号转发，这个 init 进程的子进程就是我们在容器内启动的服务进程。在默认情况下，Docker 要求容器内的服务进程必须以前台模式运行，也就是说，服务进程必须在前台运行，并将进程的标准输入、标准输出和标准错误输出流与 Docker 主机的标准输入输出流进行绑定。这样，Docker 主机就可以通过控制台来进行服务进程的操作和监控，比如查看进程输出信息、向服务进程发送中断信号等。\n\n如果服务进程以后台模式运行，也就是不在前台运行，那么这个服务进程的标准输入、标准输出和标准错误输出流就无法与 Docker 主机的标准输入输出流绑定在一起，这样 Docker 主机就无法进行服务进程的管理和监控，也就无法对服务进程进行重启、停止等操作，这对于容器的运维和管理带来了很大的挑战，因此 Docker 要求服务进程必须在前台模式下运行。\n```\n### 前台和后台模式\n- 后台守护进程和前台进程\nNode.js 在 Linux/Unix 系统中可以运行在前台和后台两种模式下。在前台模式下，Node.js 进程直接运行在当前终端会话中，并且输出日志信息到终端。在后台模式下，Node.js 进程运行在后台，并且它的输出通常被重定向到文件或其他设备上。\n下面是一个使用两种模式运行 Node.js 的示例：\n在前台模式下运行 Node.js：\n```\n$ node app.js\n```\n在后台模式下运行 Node.js：\n```\n$ nohup node app.js > app.log &\n```\n在以上的命令中，使用了 `nohup` 命令来运行 Node.js 进程，并且将输出日志到命名为 `app.log` 的文件中。同时，使用 `&` 符号使 Node.js 进程在后台运行。\n需要注意的是，在生产环境中，通常会使用像 PM2 或者 Supervisord 这样的进程管理工具来管理 Node.js 应用程序，并确保它们在后台运行时能够自动重启、监控和处理错误。\n### 存在问题\n\n\n\n### 做的优化\n\n\n\n### 随便聊聊\n之前看了阿里巴巴云原生的一篇访谈博文（https://juejin.cn/post/6951283312824418311）：\n里面Nacos联合创始人做了一个类比：Nacos之于微服务的地位，就跟Etcd之于k8s的地位一样\n\n\n翻译内容笔记来自于下面开源链接：\nhttps://btholt.github.io/complete-intro-to-containers/\n\n\n## Others\n### harbor\n#### projects\n- 项目 ｜ 镜像仓库\n- docker pull xxx.xxx.xxx.cn/project-x/xxxserver:202107071844\n- 运维对我们项目的包优化了一个版本，增加了镜像大小 700M->1.12G，减少了下载的时间\n#### API 控制中心 devcenter\n\n\n## baiscs\n#### cluster ip\n- https://kubernetes.io/docs/concepts/services-networking/service/\n```\nKubernetes assigns this Service an IP address (sometimes called the \"cluster IP\"), which is used by the Service proxies (see Virtual IPs and service proxies below).\n```\n- https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies\n> ClusterIP: Exposes the Service on a cluster-internal IP. Choosing this value makes the Service only reachable from within the cluster. This is the default ServiceType.\n```\n举个例子，考虑一个图片处理后端，它运行了 3 个副本。这些副本是可互换的 —— 前端不需要关心它们调用了哪个后端副本。 然而组成这一组后端程序的 Pod 实际上可能会发生变化， 前端客户端不应该也没必要知道，而且也不需要跟踪这一组后端的状态。\n\nService 定义的抽象能够解耦这种关联。\n\nKubernetes 为该服务分配一个 IP 地址（有时称为 “集群 IP”），该 IP 地址由服务代理使用。\n```\n```\n发布服务（服务类型)\n对一些应用的某些部分（如前端），可能希望将其暴露给 Kubernetes 集群外部的 IP 地址。\n\nKubernetes ServiceTypes 允许指定你所需要的 Service 类型，默认是 ClusterIP。\n\nType 的取值以及行为如下：\n\nClusterIP：通过集群的内部 IP 暴露服务，选择该值时服务只能够在集群内部访问。 这也是默认的 ServiceType。\n\nNodePort：通过每个节点上的 IP 和静态端口（NodePort）暴露服务。 NodePort 服务会路由到自动创建的 ClusterIP 服务。 通过请求 <节点 IP>:<节点端口>，你可以从集群的外部访问一个 NodePort 服务。\n\nLoadBalancer：使用云提供商的负载均衡器向外部暴露服务。 外部负载均衡器可以将流量路由到自动创建的 NodePort 服务和 ClusterIP 服务上。\n\nExternalName：通过返回 CNAME 和对应值，可以将服务映射到 externalName 字段的内容（例如，foo.bar.example.com）。 无需创建任何类型代理。\n```\n#### Pod对象\n- 凡是调度，网络，存储，以及安全相关的属性基本上都是Pod级别的\n\n#### 容器 - 隔离与限制\n- 容器是一个“单进程”模型\n## Others\n```\n把eBay的一些核心应用从物理机迁移到容器\n1，对于应用，它容器化之后，发布和部署更加方便，特别是在扩容的时候更快了。\n2. 对于平台，我们用一套平台kubernetes来管理所有的应用，对于硬件资源的利用率得以提高。\n所以容器化后，带来的好处是，开发效率的提高，资源利用率的提高。\n```\n\n### aws配置\n- https://github.com/docker/hub-feedback/issues/1318#issuecomment-396429154 pull images的时候如果403\n\n\n### 系统资源监控工具\nbrew install htop\n\n### dumb-init\ndumb-init是一个简单的init系统，用于管理容器内的多个进程。它主要解决了在Docker和Kubernetes等容器环境中管理进程的问题。\n\n在容器中，通常会运行多个进程，例如一个Web服务器和一个后台守护进程。如果不使用dumb-init这样的init系统，当容器的入口点进程（entrypoint）退出时，容器中的所有进程都将被杀死，而无法进行正常的清理操作。\n\ndumb-init可以作为容器中的入口点进程，并作为所有其他进程的父进程。当子进程退出时，dumb-init会重新注册SIGTERM和SIGINT信号，并将其发送给所有子进程，以便它们能够优雅地退出。\n\ndumb-init还可以设置最大进程数、ulimit参数等，以帮助管理容器内的进程。\n\nDockerfile\n```\nRUN curl -L -o /usr/local/bin/dumb-init https://github.com/Yelp/dumb-init/releases/download/v1.2.2/dumb-init_1.2.2_amd64\nRUN chmod +x /usr/local/bin/dumb-init\nENTRYPOINT [\"dumb-init\", \"--\"]\nCMD [\"/path/to/your/program\", \"-arg1\", \"-arg2\", ...]\n```\n\n### 使用外部代理进行监测和缓存\n- 虽然nodejs服务器可以作为 HTTP服务器或 HTTP2服务器使用，但建议 将你的服务器放在 HTTP代理（如 Nginx）或 HTTP2代理（如 Envoy）后面。这样你就可以管理缓存，将日志文件集中化、标准化，并与你的监控系 统集成，以监测nodejs应用的健康和性能。\n\n### child_process\n\n\n\n\n### cluster\n\n### 项目实践\n运行在Kubernetes环境中的容器化项目，不推荐使用pm2等进程管理器，主要原因包括以下几点：\n\n1. 单一责任原则：在容器化环境中，每个容器通常只运行一个应用进程。这是因为容器设计为短暂的，并且当主进程（PID 1）退出时，Kubernetes或Docker将停止并可能重新启动容器。因此，如果你使用pm2在一个容器中运行多个Node.js进程，当其中一个进程崩溃并需要重启时，而其它进程尚在运行，那容器就不能被停止并重新启动。\n\n2. 日志管理：Kubernetes提供了统一的日志管理。所有从进程中输出到 `stdout` 或 `stderr` 的信息都会被 Kubernetes 捕获并存在日志中。而PM2自带日志管理，它会将日志存储在文件中，这可能与 Kubernetes 的日志管理功能冲突。\n\n3. 负载均衡：Kubernetes提供了内建的负载均衡器，可以自动将请求分配到各个pod中的容器。另一方面，PM2也提供了负载均衡机制，可以将请求分配到单个容器中的多个进程。这两者很可能产生冲突，使得负载均衡功能失效。\n\n4. 自动扩容和自愈：Kubernetes具有自动扩容和自愈的能力，当检测到容器/应用负载过大或者故障时，能够自动进行扩容或重启容器。如果你在容器内使用 PM2 进行进程管理和保活，这可能会影响到 Kubernetes 对容器健康状况的判断与管理。\n\n使用 Kubernetes 时，我们想要松耦合、可迁移的应用程序，并希望能全面利用 Kubernetes 的自动恢复、日志集中、负载均衡和服务发现等特性。而这些与 PM2 提供的功能可能会存在冲突。因此，在 Kubernetes 环境中，我们通常不建议使用 PM2 或其他类似的进程管理器。"},{"title":"this之熟悉的陌生人","url":"/2021/04/02/this之熟悉的陌生人/","content":"\n\n\n博文推荐：\nhttps://github.com/YvetteLau/Blog/issues/6"},{"title":"编程语言的设计与实现-创造一门什么样的语言-新语言Streem的设计与实现-阅读笔记","url":"/2021/03/30/编程语言的设计与实现-创造一门什么样的语言-新语言Streem的设计与实现-阅读笔记/","content":"松本行弘的书\n\n### JavaScript\n\n基本语法 Java/AWK\n关键字 Java/AWK\n\n数组literal Python\n对象literal Python\ngenerator Python\nspread Python/Ruby\nrest Python/Ruby\narrow function CoffeeScript/C#\nasync await C#\n\nthe good parts of JS\ndouglas crockford\n\n#### Brendan Eich 采访中的设计思路\n- 基本语法 - C\n- 数据类型/内存管理机制 - Java\n- function - first class - Scheme\n- 基于prototype的继承机制 - Self\n\n"},{"title":"AnEssayConcerningHumanUnderstanding","url":"/2021/03/29/AnEssayConcerningHumanUnderstanding/","content":"\n> SICP / JAVASCRIPT ADAPTION\n<pre>\nChapter 1\nBuilding Abstractions with Functions\n\nThe acts of the mind, wherein it exerts its power over simple ideas, are chiefly these three: 1. Combining several simple ideas into one\ncompound one, and thus all complex ideas are made. 2. The second is\nbringing two ideas, whether simple or complex, together, and setting\nthem by one another so as to take a view of them at once, without\nuniting them into one, by which it gets all its ideas of relations. 3. The third is separating them from all other ideas that accompany them in\ntheir real existence: this is called abstraction, and thus all its general\nideas are made.\n\u0016 John Locke, An Essay Concerning Human Understanding (1690)\n</pre>\n\n这个是SICP JavaScript 改编版里面第一章cite的一段话，基本上讲透了我们思考问题所用的方法论\n\n\n推荐阅读文章：\nhttps://medium.com/javascript-scene/composing-software-an-introduction-27b72500d6ea\n"},{"title":"SQLite","url":"/2021/03/29/SQLite/","content":"### 文档指南：\nhttps://www.sqlite.org/index.html\n\n\n### 文章推荐：\nhttps://antonz.org/sqlite-is-not-a-toy-database/?continueFlag=4468f03238b1209651088b2e0490953e\n\n\n### 详细讲诉\n- 在 Chrome、Safari 和 Firefox 等浏览器客户端中使用 WebSQL 时，会直接操作 SQLite。\n(https://developer.chrome.com/docs/devtools/storage/websql/)\n\n可以打开这个网址（https://andrew.hedges.name/html5/sql.html）—— 里面还有很多别的实验\n\n\n实际上 SQLite 本身是一个嵌入式的开源数据库引擎，大小只有 3M 左右，可以将整个 SQLite 嵌入到应用中，而不用采用传统的客户端／服务器（Client/Server）的架构。这样做的好处就是非常轻便，在许多智能设备和应用中都可以使用 SQLite，比如微信就采用了 SQLite 作为本地聊天记录的存储。\n\n\nSQLite 是在 2000 年发布的，到目前为止已经有 19 年了。一直采用 C 语言编写，采用 C 语言而非 C++ 面向对象的方式，可以提升代码底层的执行效率。\n\n但 SQLite 也有一些优势与不足。它的优势在于非常轻量级，存储数据非常高效，查询和操作数据简单方便。此外 SQLite 不需要安装和配置，有很好的迁移性，能够嵌入到很多应用程序中，与托管在服务器上的 RDBMS 相比，约束少易操作，可以有效减少服务器的压力。\n\n不足在于 SQLite 常用于小到中型的数据存储，不适用高并发的情况。比如在微信本地可以使用 SQLite，即使是几百 M 的数据文件，使用 SQLite 也可以很方便地查找数据和管理，但是微信本身的服务器就不能使用 SQLite 了，因为 SQLite 同一时间只允许一个写操作，吞吐量非常有限。\n\n作为简化版的数据库，SQLite 没有用户管理功能，在语法上也有一些自己的“方言”。比如在 SQL 中的 SELECT 语句，SQLite 可以使用一个特殊的操作符来拼接两个列。在 MySQL 中会使用函数 concat，而在 SQLite、PostgreSQL、Oracle 和 Db2 中使用||号，比如：SELECT MesLocalID || Message FROM \"Chat_1234\"。\n\n这个语句代表的是从 Chat_1234 数据表中查询 MesLocalID 和 Message 字段并且将他们拼接起来。\n\n但是在 SQLite 中不支持 RIGHT JOIN，因此你需要将右外连接转换为左外连接，也就是 LEFT JOIN，写成下面这样：SELECT * FROM team LEFT JOIN player ON player.team_id = team.team_id\n\n除此以外 SQLite 仅支持只读视图，也就是说，我们只能创建和读取视图，不能对它们的内容进行修改。\n\n\n总的来说支持 SQL 标准的 RDBMS 语法都相似，只是不同的 DBMS 会有一些属于自己的“方言”，我们使用不同的 DBMS 的时候，需要注意。\n\n\n我今天讲了有关 SQLite 的内容。在使用 SQLite 的时候，需要注意 SQLite 有自己的方言，比如在进行表连接查询的时候不支持 RIGHT JOIN，需要将其转换成 LEFT JOIN 等。同时，我们在使用 execute() 方法的时候，尽量采用带有参数的 SQL 语句，以免被 SQL 注入攻击。\n\n### better-sqlite3\n文档指路：https://github.com/JoshuaWise/better-sqlite3/tree/4dc52f1dce355fc5894edf0566f8fd3eb0af214f\n\n<pre>\nThe fastest and simplest library for SQLite3 in Node.js.\nNode.js中最快、最简单的SQLite3库。\n\nFull transaction support\n完全的事务支持\nHigh performance, efficiency, and safety\n高性能、高效率和安全性\nEasy-to-use synchronous API (better concurrency than an asynchronous API... yes, you read that correctly)\n易于使用的同步API（比异步API有更好的并发性......是的，你没看错）\nSupport for user-defined functions, aggregates, and extensions\n支持用户定义的函数、集合和扩展。\n64-bit integers (invisible until you need them)\n64位整数(在你需要之前是不可见的)\nWorker thread support (for large/slow queries)\n工作线程支持（用于大型/慢速查询）https://nodejs.org/api/worker_threads.html\n</pre>\n\n提供了benchmark(https://en.wikipedia.org/wiki/Benchmark_(computing))\n<pre>\nBenchmark\nTo run the benchmark yourself:\n\ngit clone https://github.com/JoshuaWise/better-sqlite3.git\ncd better-sqlite3\nnpm install # if you're doing this as the root user, --unsafe-perm is required\nnode benchmark\n</pre>\n\n\n<pre>\nWhen is this library not appropriate?\n什么时候不适合使用这个库？\n\nIn most cases, if you're attempting something that cannot be reasonably accomplished with better-sqlite3, it probably cannot be reasonably accomplished with SQLite3 in general. For example, if you're executing queries that take one second to complete, and you expect to have many concurrent users executing those queries, no amount of asynchronicity will save you from SQLite3's serialized nature. Fortunately, SQLite3 is very very fast. With proper indexing, we've been able to achieve upward of 2000 queries per second with 5-way-joins in a 60 GB database, where each query was handling 5–50 kilobytes of real data.\n在大多数情况下，如果你正在尝试一些不能用better-sqlite3合理完成的事情，那么一般情况下可能也不能用SQLite3合理完成。例如，如果你正在执行需要一秒钟才能完成的查询，并且你期望有许多并发用户执行这些查询，那么再多的异步性也无法将你从SQLite3的序列化特性中拯救出来。幸运的是，SQLite3的速度非常非常快。通过适当的索引，我们已经能够在一个60GB的数据库中用5路连接实现每秒高达2000次的查询，其中每个查询都要处理5-50kb的真实数据。\n\nIf you have a performance problem, the most likely causes are inefficient queries, improper indexing, or a lack of WAL mode—not better-sqlite3 itself. However, there are some cases where better-sqlite3 could be inappropriate:\n如果你有性能问题，最有可能的原因是查询效率低下，索引不当，或者缺乏WAL模式，而不是better-sqlite3本身。然而，在某些情况下，better-sqlite3可能是不合适的。\n\nIf you expect a high volume of concurrent reads each returning many megabytes of data (i.e., videos)\n如果你期望大量的并发读取，每个返回许多兆字节的数据（即视频）。\nIf you expect a high volume of concurrent writes (i.e., a social media site)\n如果你期望有大量的并发写入（例如，一个社交媒体网站）。\nIf your database's size is near the terabyte range\n如果您的数据库的大小接近TB的范围\n\nFor these situations, you should probably use a full-fledged RDBMS such as PostgreSQL.\n对于这些情况，你可能应该使用一个成熟的RDBMS，如PostgreSQL。\n</pre>\n\n#### nodejs\n- Node.js 中安装 SQLite 需要安装两个模块：SQLite3 和 SQLite\n- sqlite3 是支持 SQLite 的标准Node.js模块\n- SQLite 模块是在这个基础上将 SQLite3 模块的异步 API 封装成 Promise 规范，易于使用 - A wrapper library written in Typescript with ZERO dependencies that adds ES6 promises and SQL-based migrations API to sqlite3 (docs).\n\n### 延伸阅读\n- https://nodesource.com/blog/worker-threads-nodejs/\n- https://blog.insiderattack.net/deep-dive-into-worker-threads-in-node-js-e75e10546b11\n\n\n### 工具推荐\nnavicat\ndatagrip\n- 数据库建模\nPDMan (http://www.pdman.cn/#/)\nPD(PowerDesigner)\n\n## sqlite testing\nwww.sqlite.org/testing.html\n很好的一篇讲sqlite在测试方面做的工作\n\n#### mac or windows 图形化界面管理工具\n- sqlpro studio - https://www.sqlprostudio.com/ - Mac/Windows都可，收费\n- sqliteexpert - https://www.sqliteexpert.com/ - windows平台，personal版本免费，专业版收费\n- db browser for SQLite"},{"title":"core-js","url":"/2021/03/25/core-js/","content":"https://www.npmjs.com/package/core-js\n大部分项目里面，一定会依赖到core-js\n\n- https://github.com/zloirock/core-js/blob/master/docs/2023-02-14-so-whats-next.md\n(作者分享他自己的经历和对开源的看法，以及support方式)\n- 作者基本上每天都有commit，解决一些小问题"},{"title":"有趣的文章-history","url":"/2021/03/24/有趣的文章-history/","content":"\n### frontend\n周爱民：\n[前端要给力之：代码可以有多烂？](https://kb.cnblogs.com/page/83497/)\n\n### 会议\n- https://www.myhuiban.com/ - 可以实时显示CS相关的会议情况\n\n\n\n\n\n\n\n\ntc39:\nhttps://tc39.es/ecma262/#sec-reference-record-specification-type"},{"title":"JavaScript中的类","url":"/2021/03/24/JavaScript中的类/","content":"\n推荐阅读：\n9.JavaScript中的类\n刘振涛. 深入理解ES6 (Chinese Edition) (Kindle位置2667). Kindle 版本. \n\n在线阅读地址：https://leanpub.com/understandinges6/read\n（这部书英文还是相对简单的，可以直接阅读）\n\n提issue:https://github.com/nzakas/understandinges6/\n\n配合MDN对具体对用法更详细的使用\nhttps://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Classes\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/static"},{"title":"md5","url":"/2021/03/24/md5/","content":"\n### 库\n[crypto-js](https://www.npmjs.com/package/crypto-js)\n[object-hash](https://www.npmjs.com/package/object-hash)\n[node-forge](https://github.com/digitalbazaar/forge)\n[spark-md5](https://www.npmjs.com/package/spark-md5)\n\n### SparkMD5\n- SparkMD5是MD5算法的一个快速MD5实现。这个脚本是基于JKM md5库的，它是最快的算法。这是最适合浏览器使用的，因为nodejs版本可能更快。\n\n#### 对JKM md5库的改进。\n- 字符串被转换为utf8，就像大多数服务器端算法一样。\n- 修正大量数据的计算(溢出)\n- 增量式md5（见下文）。\n- 支持数组缓冲区（类型化数组）。\n- 功能被封装在closure(闭包)中，以避免全局赋值。\n- 面向对象的库\n- CommonJS(它可以在node中使用)和AMD集成\n- 通过JSHint和JSCS校验\n\n增量式md5对于大量数据的哈希处理，例如文件，表现得更好。我们可以使用FileReader和Blob来分块读取文件，并在保持低内存使用率的情况下，追加每个分块进行md5哈希。\n\n\n### 代码调试\n本身包很小22K，代码也比较清楚\n\n开发工具是vscode\n```\n// Type definitions for spark-md5 3.0\n// Project: https://github.com/satazor/js-spark-md5#readme\n// Definitions by: Bastien Moulia <https://github.com/bastienmoulia>\n//                 Florian Keller <https://github.com/ffflorian>\n// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped\n// TypeScript Version: 2.3\n\n// copy of ArrayBuffer because of a conflict with the class SparkMD5.ArrayBuffer\ntype JsArrayBuffer = ArrayBuffer;\n\ndeclare class SparkMD5 {\n    constructor();\n\n    static hash(str: string, raw?: boolean): string;\n    static hashBinary(content: string, raw?: boolean): string;\n\n    append(str: string): SparkMD5;\n    appendBinary(contents: string): SparkMD5;\n    destroy(): void;\n    end(raw?: boolean): string;\n    getState(): SparkMD5.State;\n    reset(): SparkMD5;\n    setState(state: SparkMD5.State): SparkMD5.State;\n}\n\ndeclare namespace SparkMD5 {\n    interface State {\n        buff: Uint8Array;\n        hash: number[];\n        length: number;\n    }\n\n    class ArrayBuffer {\n        constructor();\n\n        static hash(arr: JsArrayBuffer, raw?: boolean): string;\n\n        append(str: JsArrayBuffer): ArrayBuffer;\n        destroy(): void;\n        end(raw?: boolean): string;\n        getState(): State;\n        reset(): ArrayBuffer;\n        setState(state: State): State;\n    }\n}\n\nexport = SparkMD5;\n```\nLibrary/Caches/typescript/4.2/node_modules/@types/spark-md5/index.d.ts\n因为vscode默认开启了AutomaticTypeAcquisition\n\nhttps://code.visualstudio.com/Docs/languages/javascript#_automatic-type-acquisition\n\n如果想要关闭的话，可以设置里面 disableAutomaticTypeAcquisition\n\n这样我们可以看到类型定义，本身node_modules里面 spark-md5是没有类型声明的\n\n\n### 实例调试\n我们应用场景是对视频做checkmd5,每秒钟50M的样子～\n\n### 读取文件\nhttps://github.com/forsigner/browser-md5-file/blob/master/src/index.js\n```\nimport SparkMD5 from 'spark-md5'\n\nexport default class BMF {\n  md5(file, md5Fn, progressFn) {\n    this.aborted = false\n    this.progress = 0\n    let currentChunk = 0\n    const blobSlice =\n      File.prototype.slice ||\n      File.prototype.mozSlice ||\n      File.prototype.webkitSlice\n    const chunkSize = 2097152\n    const chunks = Math.ceil(file.size / chunkSize)\n    const spark = new SparkMD5.ArrayBuffer()\n    const reader = new FileReader()\n\n    loadNext()\n\n    reader.onloadend = e => {\n      spark.append(e.target.result) // Append array buffer\n      currentChunk++\n      this.progress = currentChunk / chunks\n\n      if (progressFn && typeof progressFn === 'function') {\n        progressFn(this.progress)\n      }\n\n      if (this.aborted) {\n        md5Fn('aborted')\n        return\n      }\n\n      if (currentChunk < chunks) {\n        loadNext()\n      } else {\n        md5Fn(null, spark.end())\n      }\n    }\n\n    function loadNext() {\n      const start = currentChunk * chunkSize\n      const end = start + chunkSize >= file.size ? file.size : start + chunkSize\n      reader.readAsArrayBuffer(blobSlice.call(file, start, end))\n    }\n  }\n\n  abort() {\n    this.aborted = true\n  }\n}\n\n```\n- FileReader(https://developer.mozilla.org/en-US/docs/Web/API/FileReader)\n最好直接看英文的，中文的翻译有点问题，而且内容更新不及时！！！\n<pre>\nFileReader can only access the contents of files that the user has explicitly selected, either using an HTML <input type=\"file\"> element or by drag and drop. It cannot be used to read a file by pathname from the user's file system. To read files on the client's file system by pathname, use the File System Access API. To read server-side files, use standard Ajax solutions, with CORS permission if reading cross-domain.\n</pre>\n<pre>\nFileReader 对象允许 Web 应用程序异步读取存储在用户计算机上的文件（或原始数据缓冲区）的内容，使用 File 或 Blob 对象来指定要读取的文件或数据。\n\n文件对象可以从用户使用 <input> 元素选择文件后返回的 FileList 对象中获取，也可以从拖放操作的 DataTransfer 对象中获取，或者从 HTMLCanvasElement 上的 mozGetAsFile() API 中获取。\n\nFileReader 只能使用 HTML <input type=\"file\"> 元素或通过拖放来访问用户已明确选择的文件内容。它不能用于从用户的文件系统中按路径名读取文件。要通过路径名读取客户端文件系统中的文件，请使用文件系统访问API。要读取服务器端文件，请使用标准的Ajax解决方案，如果跨域读取，请使用CORS权限。\n</pre>\n\n- https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader/readAsDataURL"},{"title":"vue-class与style绑定","url":"/2021/03/23/vue-class与style绑定/","content":"文档链接：\nhttps://v3.cn.vuejs.org/guide/class-and-style.html#%E7%BB%91%E5%AE%9A-html-class\n> 操作元素的 class 列表和内联样式是数据绑定的一个常见需求。因为它们都是 attribute，所以我们可以用 v-bind 处理它们：只需要通过表达式计算出字符串结果即可。不过，字符串拼接麻烦且易错。因此，在将 v-bind 用于 class 和 style 时，Vue.js 做了专门的增强。表达式结果的类型除了字符串之外，还可以是对象或数组。\n\n具体使用见文档\n\n- 绑定HTML Class\n  - 对象语法\n  - 数组语法\n  - 在组件上使用\n\n#### code-review:\n:class在使用对象和数组语法的时候，团队中，对象语法使用最多，在数组语法的使用中，部分逻辑是可以简化的，也不需要使用数组语法，具体写作的时候没有做思考。\n\n- 绑定内联样式\n  - 对象语法\n  - 数组语法\n  - 自动添加前缀\n  - 多重值\n#### code-review:\n:style的使用，其实是没有做到样式和结构的分离的，追求语义明确和样式的扩展的话，其实是不推荐使用的；不过看场景，如果能做到语义明确，结构简单，使用的话，也没什么大问题\n\n### 实现原理剖析\n\n```\n// https://github.com/vuejs/vue/blob/dev/src/core/vdom/create-element.js\n// ref #5318\n// necessary to ensure parent re-render when deep bindings like :style and\n// :class are used on slot nodes\nfunction registerDeepBindings (data) {\n  if (isObject(data.style)) {\n    traverse(data.style)\n  }\n  if (isObject(data.class)) {\n    traverse(data.class)\n  }\n}\n```\n```\n// packages/vue-template-compiler/browser.js\n// 文件搜索class\nfunction transformNode (el, options) {\n    var warn = options.warn || baseWarn;\n    var staticClass = getAndRemoveAttr(el, 'class');\n    if (staticClass) {\n      var res = parseText(staticClass, options.delimiters);\n      if (res) {\n        warn(\n          \"class=\\\"\" + staticClass + \"\\\": \" +\n          'Interpolation inside attributes has been removed. ' +\n          'Use v-bind or the colon shorthand instead. For example, ' +\n          'instead of <div class=\"{{ val }}\">, use <div :class=\"val\">.',\n          el.rawAttrsMap['class']\n        );\n      }\n    }\n    if (staticClass) {\n      el.staticClass = JSON.stringify(staticClass);\n    }\n    var classBinding = getBindingAttr(el, 'class', false /* getStatic */);\n    if (classBinding) {\n      el.classBinding = classBinding;\n    }\n  }\n\n  function genData (el) {\n    var data = '';\n    if (el.staticClass) {\n      data += \"staticClass:\" + (el.staticClass) + \",\";\n    }\n    if (el.classBinding) {\n      data += \"class:\" + (el.classBinding) + \",\";\n    }\n    return data\n  }\n\n  var klass = {\n    staticKeys: ['staticClass'],\n    transformNode: transformNode,\n    genData: genData\n  };\n```\n\n### 相关tips\n1.truthy 不是 true，详见 MDN 的解释(https://developer.mozilla.org/zh-CN/docs/Glossary/Truthy)。"},{"title":"eslint版本问题","url":"/2021/03/22/eslint版本问题/","content":"\n### 命令行脚本\n- npm run lint:init\n- ```eslint --init```\n- 初始化配置 - interactive\n- npm run lint:fix \n- ```eslint './**/*.js' --fix```\n### basics\n#### env\n- browser: true - 就告诉eslint,是浏览器项目，这样不会有console未定义这样的错误（浏览器内置对象）\n#### rules\n- 定义覆盖规则\n\n### Vscode\n- 编辑器给出语法提示\n#### parserOptions\n- 指定支持的版本的最新的语法 - ecmaVersion\n- 支持ES module模块加载语法的检查 - sourceType: 'module'\n### problems\nCannot read property 'range' of null\n\nbabel-eslint版本依赖问题\n\n删除了node_modules和package-lock.json文件，重新安装后，问题就没有了\n\n```\nwarning  in ./src/views/statistical/english/data.js\n\nModule Warning (from ./node_modules/thread-loader/dist/cjs.js):\nCannot read property 'range' of null\n\n```\n\n#### eslint版本问题\n- 如果是在Linux机器上，16.x的node版本，安装之前用低版本\n\n\n#### rules\n- rules - https://eslint.org/docs/latest/user-guide/configuring/rules\n- https://eslint.org/\n```\n\"off\" or 0 - turn the rule off\n\"warn\" or 1 - turn the rule on as a warning (doesn’t affect exit code)\n\"error\" or 2 - turn the rule on as an error (exit code is 1 when triggered)\n```\n\n### eslint-config\n- https://github.com/antfu/eslint-config#faq\n\n\n### eslint 和 prettier\n- https://eslint.org/blog/2023/10/deprecating-formatting-rules/\n\n```\n旧项目\nmember-delimiter-style\nDEPRECATED\nFormatting rules now live in eslint-stylistic. @stylistic/ts/member-delimiter-style is the replacement for this rule.\nSee Deprecating Formatting Rules for more information.\n```"},{"title":"Good-parts-ProgrammingStyle确有好坏","url":"/2021/03/21/Good-parts-ProgrammingStyle确有好坏/","content":"\n## the good parts (JavaScript语言精粹)\nDouglas Crockford\n\n> 有个三天的workshop视频，以下是阅读理解笔记\n\n### part one => programming style and your brain\n\n- 有的人觉得programming style是偏好问题；但是Douglas觉得编程风格却有好坏，有些风格明显优于其他风格\n\n- Daniel Kahneman（the Nobel Winning Psychologist）有一本书《思考，快与慢》\n  - the Head, the Gut\n  - 对书里的理论进行了概括的阐述：可参考https://book.douban.com/review/5978072/\n  \n- The Web Browser Platform\n - Horribly insecure\n - Still \"fixing it later\"\n - HTML5 made it worse instead of better\n - It is still better than everything else\n\n> Blame the victim\n\n> whose interest does the program represent? the browser got this right. every other platform for this wrong\n\n\n"},{"title":"阅读-思考-快与慢-精读","url":"/2021/03/21/阅读-思考-快与慢-精读/"},{"title":"前端之拖拽drag","url":"/2021/03/19/前端之拖拽drag/","content":"https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_Drag_and_Drop_API\n\n前端的业务需求中，离不开拖拽\n\n5.b081c2050593ddb6b005.js:2 Options props is deprecated, add sortable options directly as vue.draggable item, or use v-bind. See https://github.com/SortableJS/Vue.Draggable/blob/master/documentation/migrate.md#options-props\n\n\nhttps://github.com/SortableJS/Vue.Draggable/blob/master/documentation/migrate.md#options-props"},{"title":"埋点那些事儿","url":"/2021/03/19/埋点那些事儿/","content":"入职以来，经历了\n- 友盟\n- growingIO\n- 听云\n- 神策\n\n\n\n### 神策\nhttps://manual.sensorsdata.cn/sa/latest/tech_sdk_client_web_all_use-7545350.html#id-.%E5%85%A8%E5%9F%8B%E7%82%B9(Web)v1.13-Web%E5%85%83%E7%B4%A0%E7%82%B9%E5%87%BB($WebClick)"},{"title":"node-email发送","url":"/2021/03/19/node-email发送/","content":"https://nodemailer.com/about/\nhttps://www.npmjs.com/package/nodemailer"},{"title":"puppeteer-node-pdf-service","url":"/2021/03/19/puppeteer-node-pdf-service/","content":"不涉及业务，讲一下技术方面PDF生成服务的心得\n\n### 文档指北：\n- puppeteer(https://github.com/puppeteer/puppeteer)\n<pre>\nPuppeteer is a Node library which provides a high-level API to control Chrome or Chromium over the DevTools Protocol. Puppeteer runs headless by default, but can be configured to run full (non-headless) Chrome or Chromium.\n</pre>\n\n应用场景：\n1. 页面截图服务\n2. PDF生成服务\n3. 自动化测试\n4. 服务端渲染内容抓取\n\ntry:https://try-puppeteer.appspot.com/\n\n就几乎碰到的问题，文档上面都能找到，所以文档和生态还是比较完备的\nhttps://github.com/puppeteer/puppeteer/blob/main/docs/api.md\n\n\n也有troubleShooting的文档：\nhttps://github.com/puppeteer/puppeteer/blob/main/docs/troubleshooting.md\n\n基于 -  DevTools Protocol \n## History\n\n### 几次技术改造\n\n- downloadCenter\n- 从接口获取模版渲染数据 -> 从mongodb获取\n- XX_report 进度状态原先由接口返回 -> 返回到mq\n- node服务本身 - 配合修改+日志+调试配置开关\n\n\n### 部署和CI优化\n#### 底层脚本\n- pm2配置\n```\n```\n\n#### Jenkins可视化集成\n\n\n## 项目代码分析\n\n### module本身使用代码风格不是很清晰明确\n- https://github.com/chemdemo/chemdemo.github.io/issues/2\n- exports.xxx | module.exports = xxx\n\n### process\n- beforeExit\n- \n\n## 字体相关\n\n### 字体的一些基础知识\n#### Windows\n- https://docs.microsoft.com/en-us/typography/\n -https://en.wikipedia.org/wiki/List_of_typefaces_included_with_Microsoft_Windows\n- 微软雅黑-vista开始提供的，win8之后，加入了light,默认win平台可以设置这个，效果最好；\n- Arial | Tahoma 等无衬线字体，西文选择\n#### Mac\n- https://en.wikipedia.org/wiki/List_of_typefaces_included_with_macOS\n---------旧一点\n- 华文黑体，华文细黑 10.6之前简体中文默认系统字体\n- 黑体 10.6之后\n- 冬青黑体 - 专业印刷字体，小字号清晰\n- Time New Roman - 西文衬线，Safari默认\n- Helvetica，Helvetica Neue - 可以看看history，有意思，苹果重金购买（在根号这个字符的渲染上，这个接近微软雅黑的，没有横线）\n--------- 新一点\n- PingFang SC - 苹果为中文用户提供的 - 极细｜。。。｜中粗 - 6个\n- San Francisco - Capitan 上最新发布的\n- 可以看看苹果官网针对不同地区设置的字体\n\n#### linux\n- 文泉驿微米黑 - 简体中文\n- 思源黑体，（在根号这个字符的渲染上，这个接近Helvetica的，没有横线）\n\n\n### 默认声明\n- 尽量用英文，中文也写保险一点\n- 英文放在中文前面，这样不影响中文\n- `font-family: Helvetica, Tahoma, Arial;` \n- `font-family: \"PingFang SC\", \"Hiragino Sans GB\", \"Heiti SC\", \"Microsoft YaHei\", \"WenQuanYi Micro Hei\";`\n- `font-family: Helvetica, Tahoma, Arial, \"Heiti SC\", \"Microsoft YaHei\", \"WenQuanYi Micro Hei\";`\n- `font-family: Helvetica, Tahoma, Arial, \"PingFang SC\", \"Hiragino Sans GB\", \"Heiti SC\", \"Microsoft YaHei\", \"WenQuanYi Micro Hei\";`\n- `font-family: Helvetica, Tahoma, Arial, \"PingFang SC\", \"Hiragino Sans GB\", \"Heiti SC\", \"Microsoft YaHei\", \"WenQuanYi Micro Hei\", sans-serif;` - 补充字体族\n- 可以参考各个类型网站的写法\n- 如果字体名称中间有空格，或者中文的，加上引号\n- 版权问题 - 思源黑体，我们打印就用的这个\n\n### 一些参考\n- https://github.com/zenozeng/fonts.css\n- https://github.com/sofish/typo.css - 好久以前的，可以看一眼\n### 页眉页脚中文字体\n- https://www.npmjs.com/package/pdf-lib#embed-font-and-measure-text\n- https://github.com/Hopding/pdf-lib/issues/430\n- 额外引入一些特殊的中文字体，如果直接用pdf-lib，@pdf-lib/fontkit（旧版本） ，则需配合font-carrier进行字体精简\n- https://www.npmjs.com/package/pdfkit， pdfkit则不用，默认精简\n- @pdf-lib/fontkit - https://github.com/Hopding/fontkit , https://github.com/foliojs/fontkit\n```\n# https://www.npmjs.com/package/font-carrier\n案例三\n对中文字体精简\n\nvar fontCarrier = require('font-carrier')\nvar transFont = fontCarrier.transfer('./test/test.ttf')\n// 会自动根据当前的输入的文字过滤精简字体\ntransFont.min('我是精简后的字体，我可以重复')\ntransFont.output({\n  path: './min'\n})\n```\n```\nconst fontkit = require('@pdf-lib/fontkit');\ndoc.registerFontkit(fontkit); // 注册字体\n# 如果直接用的话，则默认无裁剪，会导致生成的PDF文件过大\n# 可以利用font-carrier解决\nconst fontCarrier = require('font-carrier');\nconst transFont = fontCarrier.transfer(`${dir}/font/pingfang.ttf`);\ntransFont.min(headerFooter.title.join('') + extra + '.');\nconst fontMinResult = transFont.output({\n    types:['ttf']\n  });\n  // 加载自定义字体\nconst customFont = doc.embedFont(fontMinResult.ttf);\n\n# 基于font subsetting来做\nconst fontBytes = fs.readFileSync('./font/pingfang.ttf')\nconst pdfDoc = await PDFDocument.create()\npdfDoc.registerFontkit(fontkit)\nconst font = await pdfDoc.embedFont(fontBytes, { subset: true });\n# 这个目前版本会有问题，出来的文件除了adobe能正常读取，其余软件显示乱码\n\n```\n```\n# 较新版本支持subset\nconst subset = font.createSubset();\nrun.glyphs.forEach(function(glyph) {\n  subset.includeGlyph(glyph);\n});\n\nsubset.encodeStream()\n      .pipe(fs.createWriteStream('subset.ttf'));\n# 但是sub\n```\n\n### 割字问题\n保证内容里面不想被切割的，为块装结构\n\n### echarts部分图丢失\n升级puppteer\n\n\n### 开源字体\n- 思源 - 是由Google和Adobe合作开发的。Google将其命名为Noto SansCJK，作为Google的Noto字体家族的成员。Adobe则命名为Source Han Sans，作为Adobe的Source字体家族的一员。Adobe拥有字体设计的版权。发布的字体文件则可以不受限制的免费使用。\n- 打印用的字体就是思源，跑在linux机器上\n- 这个属于 sans-serif\n- 黑体字属于“无衬线体”（Sans-serif），而宋体字属于“有衬线体”（Serif）\n### ttf2woff2 (dep by font-carrier)\n- https://www.npmjs.com/package/ttf2woff2\n- This is a NodeJS wrapper for the Google WOFF2 project. If the C++ wrapper compilation fail, it fallbacks to an Emscripten build.\n- Convert TTF files to WOFF2 ones.\n\n### truetype | type1\n\n- TrueType是苹果和微软联合提出的一种新型数学字形描述，既可以作打印字体，又可以用作屏幕显示\n- OpenType，封装格式和truetype兼容，轮廓格式是Postscript\n- Type1 ,在Opentype出现前，Adobe的印刷字体封装格式，使用PS曲线\n- Type0. Postscript里的复合字体\n- 字体构成\n    - 轮廓格式（TT/PS） —— 记载字符的形状（矢量）\n    - 封装格式（SFNT/Type 1）—— 封装成一个文件的方法\n    - 编码方式（Unicode/CID） —— 决定字体里字符的内部编号、Unicode 以及轮廓的对应关系\n- 书本推荐：Fonts & Encodings - 作者: Yannis Haralambous\n\n\n## C端下载文件\n\n### web端\n- https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Disposition\n- 我们文件制作完成会上传腾讯云CDN\n- C端下载的话，注意content-disposition （看下response里面这部分的值）\n- 腾讯云支持query传参设定response里面的content-disposition的值\n```\nhttps://cloud.tencent.com/document/product/436/57420\n获取对象访问 URL\n功能说明\n查询对象访问的 URL，该接口不会判断对象是否真实存在。\n\n说明：\n如何使生成的对象URL在浏览器中打开是预览，而不是下载：在获取的url后拼接参数 response-content-disposition=inline\n如何使生成的对象URL在浏览器中打开是下载，而不是预览：在获取的url后拼接参数 response-content-disposition=attachment\n```\n\n#### --no-sandbox\n- 如果服务端root权限下运行\n- running as root without --no-sandbox is not supported\n- linux 里面使用Chrome也是这个道理，都会有这个权限问题\n\n#### iframe\n- 等待加载完成 - page.waitFor(提供各种模式)\n```\nIt's generally recommended to not wait for a number of seconds, but instead use Page.waitForSelector(), Page.waitForXPath() or Page.waitForFunction() to wait for exactly the conditions you want.\n```\n\n### chromium下载\n- https://storage.googleapis.com/chromium-browser-snapshots/\n- extract-zip\n\n## Others\n#### 如果需要打印PPT呢？\n- 模拟翻页操作\n- 每次翻页之后，获取需要打印的DOM - this.page.evaluate(domStr => document.body.innerHTML = domStr, content);\n- https://pptr.dev/api/puppeteer.page.evaluate/\n- 后台打印可用超管账号（增加中间件）\n\n### TTF, OTF, WOFF, EOT & SVG\n- WOFF 最小，最适合web\n- SVG Safari低版本支持\n- TTF 苹果微软，兼容性最好\n- OTF Adobe微软\n- EOT 微软\n\n### WOFF (Web Open Font Format) \n- 本质上是 metadata + 基于 SFNT 的字体（如 TTF、OTF 或其他开放字体格式）\n- 由 Mozilla 基金会、微软和 Opera 软件公司合作推出\n- WOFF 字体均经过 WOFF 的编码工具压缩，文件大小一般比 TTF 小 40%，加载速度更快，以更好的嵌入网页中\n- metadata 允许在字体文件中包含许可数据，以解决版权问题\n- WOFF2 格式在原有的基础上提升了 30% 的压缩率\n"},{"title":"CDN使用经验总结","url":"/2021/03/19/CDN使用经验总结/","content":"项目经验：\n私有CDN部署格式：\n可参考：https://www.jsdelivr.com/package/npm/vue?version=3.0.7\nload下来包以后，取目录，然后部署\n\n参考文档：\nhttps://blog.bitsrc.io/boost-frontend-load-speed-using-cdn-7ae02cbbf492\n\n- 静态资源如果做了CDN加速，注意CDN缓存问题，如果更新了同名资源，要主动刷新缓存！！\n- 我们这边是在CI中配置了刷新的流程，上完线主动刷新(针对有同名资源的情况，如果项目本身只有index.html是名称不变，别的资源名都有内容hash，则可以不同刷新，直接在CDN缓存策略里面配置index.html的规则即可)\n- 对于资源部分，通知运维进行主动刷新\n\n\n### 腾讯云\nx-cache-lookup: cache hit\nx-cache-lookup: hit from inner cluster\n- 命中\nx-cache-lookup：hit from upstream\n- 未命中\n\n"},{"title":"the-super-tiny-compiler","url":"/2021/03/19/the-super-tiny-compiler/","content":"文档指南：\n```\ngit clone https://github.com/jamiebuilds/the-super-tiny-compiler.git\n```\n\n"},{"title":"聊聊lodash","url":"/2021/03/17/聊聊lodash/","content":"\n## 实例\n\n### debounce\n项目中写的\n```\nexport function debounce(fn, ms) {\n  let debounceTimer = null\n  return function (...args) {\n    if (debounceTimer) clearTimeout(debounceTimer)\n    debounceTimer = setTimeout(() => {\n      fn.apply(this, args)\n    }, ms);\n  }\n}\n\n```\nlodash中\n```\nhttps://github.com/lodash\nhttps://github.com/lodash/lodash/blob/master/debounce.js\n代码不摘录了\n```\n\n### html-webpack-plugin\n- https://www.npmjs.com/package/html-webpack-plugin\n\noptions - useroptions\nOptions: You can pass a hash of configuration options to html-webpack-plugin. Allowed values are as follows:\n\n```\n{\n  entry: 'index.js',\n  output: {\n    path: __dirname + '/dist',\n    filename: 'index_bundle.js'\n  },\n  plugins: [\n    new HtmlWebpackPlugin({\n      title: 'My App', // options\n      filename: 'assets/admin.html'  // options\n    })\n  ]\n}\n\n// The following part renders the template with lodash as a minimalistic loader\nconst template = _.template(source, { interpolate: /<%=([\\s\\S]+?)%>/g, variable: 'data', ...options });\n```\n里面变量替换加渲染，默认的是基于loadash的template使用的\nhttps://lodash.com/docs/4.17.15#template\n\n\n### 类型判断\n- 里面提供了一些类型判断的方法\n- 哈哈哈，但是呢，还有一个项目\n- https://github.com/you-dont-need/You-Dont-Need-Lodash-Underscore\n- 可见下面的is系列-在lodash里面grep is\n```\nisArguments.js\nisArrayBuffer.js\nisArrayLike.js\nisArrayLikeObject.js\nisBoolean.js\nisBuffer.js\nisDate.js\nisElement.js\nisEmpty.js\nisEqualWith.js\nisError.js\nisFunction.js\nisLength.js\nisMap.js\nisMatch.js\nisMatchWith.js\nisNative.js\nisNil.js\nisNull.js\nisNumber.js\nisObject.js\nisObjectLike.js\nisPlainObject.js\nisRegExp.js\nisSet.js\nisString.js\nisSymbol.js\nisTypedArray.js\nisUndefined.js\nisWeakMap.js\nisWeakSet.js\n```\n- 同样，可以看看You-Dont-Need-Lodash-Underscore里面给出的原生方法可以给到的实现\n"},{"title":"vue-cli使用总结","url":"/2021/03/17/vue-cli使用总结/","content":"https://cli.vuejs.org/zh/guide/css.html#%E5%BC%95%E7%94%A8%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90\n还是基于webpack的，探索rollup及vite\n\n### Vue Cli 3.0重构原因\nfrom Evan You(https://medium.com/@youyuxi)\n(medium.com)\n一般vue相关官方发布的时候，Evan You会在medium上面发文章，阐述思想，这部分还是蛮值得看的。存在什么问题，为什么要解决，怎么解决的。\n\nhttps://medium.com/the-vue-point/vue-cli-3-0-is-here-c42bebe28fbb\n```\n尤雨溪认为，旧版本的 Vue CLI 本质上只是从 GitHub 上拉取模版，这种拉模版的方式有几个问题：\n在单个模版里面同时支持太多选项，会导致模版本身变得极其复杂和难以维护，而提供多个模版一方面会让初学者无所适从，另一方面模版之间也难以共享功能或是互相迁移。\n\nCLI 3 的解决方案是通过插件的形式，去支持多个不同的功能，一个插件对应一个功能，这样就避免了多个模版，也使得 CLI 自身的可维护性得到提升。\n\n拉模版生成的项目，所有的 webpack 配置和构建脚本都直接包含在仓库中，一旦用户对这些部分做了修改，就很难再获得源模版的更新和升级。\n\nCLI 3 生成的项目，核心的 webpack 配置和构建逻辑都被封装在依赖中，同时，允许用户通过配置文件来进行底层的修改。由于核心配置都被封装起来了，所以就有更多的空间去做更复杂的功能和优化，而不用担心用户的项目里面，充斥着大量和应用本身无关的构建代码。\n\n尤雨溪表示，Vue CLI 3.0 中加入了 GUI，主要就是为了降低使用门槛，因为命令行能展示的交互很有限，所以默认用户对于创建项目时，涉及的各种工具和配置项都有了基本的了解。\n\n而 GUI 可以提供更多的信息，帮助用户了解这些东西是干嘛的。\n\n另外，GUI 也能提供一些命令行无法展示的信息，比如，通过可视化的图表分析打包后各个模块的大小占比等。\n\n\nVue CLI 的核心目标是为基于 webpack 4 构建的预配置提供构建设置，目标是最大限度地减少开发人员配置的次数，因此，Vue CLI 3 对具有以下特点的项目都支持开箱即用：预配置 webpack 功能，如模块热替换、代码拆分、摇树优化（tree-shaking）、高效持久化缓存等；通过 Babel 插件（Babel 7 + preset-env）对 ES2017 进行转换；支持 PostCSS（默认启用 autoprefixer）和所有主要的 CSS 预处理器；Modern mode：并行发布原生 ES2017 +bundle 和传统 bundle；多页面模式：构建具有多个 HTML / JS 入口点的应用程序；构建目标：将 Vue 单文件组件构建成为库或原生 Web 组件。\n\nVue CLI 的核心目标是为基于 webpack 4 构建的预配置提供构建设置，目标是最大限度地减少开发人员配置的次数，因此，Vue CLI 3 对具有以下特点的项目都支持开箱即用：预配置 webpack 功能，如模块热替换、代码拆分、摇树优化（tree-shaking）、高效持久化缓存等；通过 Babel 插件（Babel 7 + preset-env）对 ES2017 进行转换；支持 PostCSS（默认启用 autoprefixer）和所有主要的 CSS 预处理器；Modern mode：并行发布原生 ES2017 +bundle 和传统 bundle；多页面模式：构建具有多个 HTML / JS 入口点的应用程序；构建目标：将 Vue 单文件组件构建成为库或原生 Web 组件。\n\n尤雨溪认为，以低级别形式访问 configs 具有很重要的意义，但是他不想抛弃那些“eject”的用户，所以他找出了一种无需 eject 的配置方法。\n\n对于 Babel、TypeScript 和 PostCSS 等第三方集成来说，Vue CLI 会尊重这些工具的配置文件。webpack 用户可以使用 webpack-merge 将简单的对象合并到最终配置中，或通过 webpack-chain 进行精确定位和调整现有的加载器和插件。此外，Vue CLI 附带了 vue inspect 命令，可以帮助开发者检查内部 Webpack 配置。这样做最大的好处是，只需要微小的调整，而不需要 eject，就可以升级 CLI service 和插件进行修复或更新。尤雨溪表示，Vue CLI 3 现在可以作为 Vue 应用程序的标准构建工具，但是这仅仅是个开始，它的长期目标是将当前和未来的最佳实践融入工具链中，最终为用户提供高性能的应用程序。\n\n\n```\n\n目前npm拉包默认是4.x，5还在发alpha版本(5.0.0-alpha.7 (2021-03-11))\n\n\n\n## 相关Tips\n@vue/cli \n如果你已经全局安装了旧版本的 vue-cli (1.x 或 2.x)，你需要先通过 npm uninstall vue-cli -g 或 yarn global remove vue-cli 卸载它。\n```\nvue --version\nnpm update -g @vue/cli\n```\n\n### report\nhttps://cli.vuejs.org/zh/guide/cli-service.html#vue-cli-service-serve\n- options 里面有--report\n\n\n### transpileDependencies\n```\ntranspileDependencies#\nType: boolean | Array<string | RegExp>\nDefault: false\n默认情况下 babel-loader 会忽略所有 node_modules 中的文件。你可以启用本选项，以避免构建后的代码中出现未转译的第三方依赖。\n不过，对所有的依赖都进行转译可能会降低构建速度。如果对构建性能有所顾虑，你可以只转译部分特定的依赖：给本选项传一个数组，列出需要转译的第三方包包名或正则表达式即可。\n```\n\n\n### @vue/cli-plugin-babel \n@vue/cli-plugin-babel 是一个 Vue CLI 的插件，它用于将 Babel 集成到 Vue 项目中。\n使用 @vue/cli-plugin-babel 的主要优势：\n1. 使用最新的 JavaScript 语法：这意味着你可以使用例如 async/await 或是 ES6 modules 这样新的语法特性，Babel 将会为旧浏览器编译这些代码。\n2. 自动检测浏览器兼容性：插件能获知你的 Vue 应用将在什么环境下运行，并为目标环境优化配置。\n3. 自动引入 polyfill：为了在旧版本浏览器中使用新特性，有时我们需要引入 polyfill。插件能了解你已经使用了哪些新特性，然后只引入需要的 polyfill。"},{"title":"npm使用指北","url":"/2021/03/17/npm使用指北/","content":"\n查看全局安装的包的版本\n```\nnpm list -g --depth 0 | grep @vue/cli\n```\n\n### 问题处理\n(node:50731) ExperimentalWarning: Package name self resolution is an experimental feature. This feature could change at any time\n94% after seal[hardsource:a9cf9509] Could not freeze ./src/router/index.js: Cannot read property 'hash' of undefined\n98% after emitting\n\n### error\n```\nUNMET PEER DEPENDENCY webpack@4.x.x || 5.x.x\n\nnpm ERR! peer dep missing: webpack@4.x.x || 5.x.x, required by webpack-cli@4.9.2\nnpm ERR! peer dep missing: webpack@4.x.x || 5.x.x, required by @webpack-cli/configtest@1.1.1\nnpm ERR! extraneous: which@2.0.2 /Users/xxxxx/node_modules/cross-spawn/node_modules/which\n```\n#### peer dep\n- https://blog.domenic.me/peer-dependencies/\n\n### n\nn升级到lts的时候出了问题\n\nnode -v\ndyld: initializer function 0x0 not in mapped image for /usr/local/bin/node\n\nbrew uninstall --force node\nbrew uninstall icu4c && brew install icu4c\nbrew unlink icu4c && brew link icu4c --force\nbrew install node\n\nI recently encountered a similar issue (after doing brew switch node 9.8.0 to downgrade to a previous version of node)\n\ndyld: Library not loaded: \n/usr/local/opt/icu4c/lib/libicui18n.60.dylib\n  Referenced from: /usr/local/bin/node\n  Reason: image not found\nAbort trap: 6\nThe issue is that node is picky about which version of icu4c it's looking for, and the version I had installed (62) was higher than node was expecting.\n\nTo fix, I made sure I had version 60 of icu4c selected.\n\nFirst I found which versions I had with brew info icu4c, then did brew switch icu4c 60.2 to select the one node was expecting.\n\n重新官网下载了node,解决的\nhttps://nodejs.org/en/\n\n### npx\n可以通过npx,去执行cli命令，不需要额外的安装\n比如：\n```\nnpx create-next-app test-demo\nnpx create-react-app test-app\n(If you've previously installed create-react-app globally via npm install -g create-react-app, we recommend you uninstall the package using npm uninstall -g create-react-app or yarn global remove create-react-app to ensure that npx always uses the latest version.)\n```\nnpx主要用于命令行寻址等辅助功能上\n\n- 可以和degit(https://www.npmjs.com/package/degit)配合着使用，比如：https://github.com/antfu/vitesse/blob/main/README.zh-CN.md\n```\nnpx degit antfu/vitesse my-vitesse-app\ncd my-vitesse-app\npnpm i # 如果你没装过 pnpm, 可以先运行: npm install -g pnpm\n```\n- expo 用npx使用\nnpx expo start (ok)\nnpx run ios (wrong)\n\n### yarn\n可以通过homebrew安装，也可以通过npm安装\nhttps://yarnpkg.com/getting-started\nyarn autoclean 功能可以试试\n\nhttps://gist.github.com/jonlabelle/c082700c1c249d986faecbd5abf7d65b\nhttps://shift.infinite.red/npm-vs-yarn-cheat-sheet-8755b092e5cc\n这篇文章提供npm和yarn的对比：\n官方也有简单的vs：\nhttps://classic.yarnpkg.com/en/docs/migrating-from-npm\n```\nnpm install === yarn\nnpm installl testpackage --save === yarn add testpackage\nnpm uninstall testpackage --save === yarn remove testpackage\nnpm install testpackage --save-dev === yarn add testpackage --dev\nnpm update --save === yarn upgrade\n```\n```\n// 都一样的\ninit | link | outdated | publish | run | cache clean | login | test\n```\n```\n// yarn 有npm没有的\nyarn licenses list\nyarn why lodash\n```\n\n### node_modules/.bin\n```\n通过npm启动的脚本，会默认把node_modules/.bin加到PATH环境变量中\nhttps://docs.npmjs.com/cli/v7/commands/npm-run-script\n\n当某个模块配置了 bin 定义时，就会被安装的时候，自动软链了过去\nhttps://docs.npmjs.com/cli/v7/configuring-npm/package-json/#bin\n```\n\n### .npmrc\n可以先看下```npm config ls -l```\nhttps://docs.npmjs.com/cli/v7/configuring-npm/npmrc\n<pre>\n具体项目：\nregistry 可以在这个里面设置\n\n可以设置\npackage-lock=false\nkoa就是这么设置的\n// 说明:如果设置为false，那么在安装时将忽略package-lock.json文件\npackage-lock\nDefault: true\nType: Boolean\nIf set to false, then ignore package-lock.json files when installing. This will also prevent writing package-lock.json if save is true.\n\nWhen package package-locks are disabled, automatic pruning of extraneous modules will also be disabled. To remove extraneous modules with package-locks disabled use npm prune.\n</pre>\n\n### pnpm\n- https://pnpm.io/zh/motivation\n- pnpm - 依赖项将存储在一个内容可寻址的仓库中\n- npm - 依赖都会被提升到模块的根目录 - 扁平化结构\n- pnpm - 使用软链的方式将项目的直接依赖添加进模块文件夹的根目录。 \n```\n树形的问题：\nThis approach had two serious issues:\n- frequently packages were creating too deep dependency trees, which caused long directory paths issue on Windows\n- packages were copy pasted several times when they were required in different dependencies\nTo solve these issues, npm rethought the node_modules structure and came up with flattening. \n```\n- 推荐阅读：https://www.kochan.io/ 这个里面写了几篇文章\n- vue-next用pnpm,还在preinstall里面加了验证\n- vite - only allow pnpm\n#### peerDependencies\n- npm中 ： https://docs.npmjs.com/cli/v9/configuring-npm/package-json#peerdependencies\n- pnpm: https://pnpm.io/zh/how-peers-are-resolved\n### difference\n- https://mp.weixin.qq.com/s?__biz=Mzg4MTYwMzY1Mw==&mid=2247496601&idx=1&sn=4c3bc00c37163e1dca152ebb8f723619&source=41#wechat_redirect\n\n## 项目管理\n### init\n- ```npm init```\n\n### package.json\n见```谈一谈package-json文件```博文\n\n\n### 技术选型\n- https://npmtrends.com/\n- 可以看trends参考\n\n\n### npm-cache\n- https://docs.npmjs.com/cli/v8/commands/npm-cache\n- clean: Delete all data out of the cache folder. Note that this is typically unnecessary, as npm's cache is self-healing and resistant to data corruption issues.\n\n### --verbose \n- 在较慢的网络上, 最好使用 --verbose 标志来显示下载进度: `npm install --verbose electron`\n- 在运行 npm install electron 时，有些用户会偶尔遇到安装问题。在大多数情况下，这些错误都是由网络问题导致，而不是因为 electron npm 包的问题。 如 ELIFECYCLE、EAI_AGAIN、ECONNRESET 和 ETIMEDOUT 等错误都是此类网络问题的标志。 最佳的解决方法是尝试切换网络，或是稍后再尝试安装\n\n\n### npm info\n\n### npm 发布(普通模块｜二进制模块)\n```\nnpm login\nnrm use npm\nnpm publish\n```\n```\nnpm i -g np\nnp\n```\n\n### packages \n- kp is a tool for kill process by server port. it can be used on mac && linux && window\n- mongo-here\n\n### process.argv 解析\n- clipanion\n- commander.js\n- yargs\n\n### .npmignore\n```\n`.npmignore` 文件是在发布 npm 包时排除不必要文件的一种方法。排除这些文件有助于减小包的体积，从而提高安装速度并减少磁盘空间占用。以下是一些建议的最佳实践：\n\n1. **基本规则**：通过将通配符（例如 `*`）或文件/文件夹名称添加到 `.npmignore`，您可以从发布的 npm 包中排除这些特定文件或文件夹。\n\n2. **将测试文件排除在外**：通常，用户不需要您的测试文件。将测试文件夹添加到 `.npmignore` 中（如 `test/`, `__tests__/` 等）。\n\n3. **排除配置文件和工具**：开发工具、构建工具和测试工具的配置文件不应包含在发布的 npm 包中。可能的文件包括：`.eslintrc`, `.prettierrc`, `.editorconfig`, `.gitignore` 等。\n\n4. **排除文档和代码示例**：文档和示例代码可以用来进一步解释包的使用方法，但在发布时应排除。文件夹名称可能包括：`docs/`, `examples/`, `samples/` 等。\n\n5. **排除源代码和构建产物**：如果您的项目使用了编译步骤（如使用 TypeScript、Babel 或构建工具），请排除源代码和生成的构建产物。可能的文件包括 `src/`, `dist/`, `build/`，但如果 `dist/` 或 `build/` 中的文件是最终用户需要的，则不要排除它们。\n\n6. **优先使用 `.npmignore` 而非 `files` 属性**：虽然 `package.json` 中的 `files` 属性可以指定要发布的文件，但使用 `.npmignore` 更方便管理排除列表。对于大型项目，`.npmignore` 的管理成本较低。\n\n7. **保留 LICENSE 和 README**：即使这些文件不是绝对必要的，我们还是建议您将许可证（LICENSE）和自述文件（README.md）包含在发布的 npm 包中，因为这些文件提供了关于您软件的许可、使用和贡献的重要信息。\n\n8. **使用 `.gitignore` 作为备选方案**：如果您没有提供 `.npmignore` 文件，npm 会默认使用 `.gitignore` 来确定要排除哪些文件。这也是合理的选择，但最好明确提供 `.npmignore` 文件以避免潜在的配置混淆。\n\n根据您的项目需求进行调整可能的文件/文件夹，确保发布的 npm 包尽可能小且只包含所需的内容。\n```\n### postinstall\nCreate React App：Facebook 出品的 React 脚手架工具， postinstall 用于提示用户将其加入到 PATH 环境变量中。\n\nGatsby：一个用于构建静态网站和应用程序的开源框架，它在 postinstall 中检查 Gatsby CLI 是否已经安装，若没有，则提示用户如何安装。\n\nAngular CLI：Angular 官方推出的命令行工具，它使用 postinstall 创建提交时的拦截器，用于在提交代码时运行携带 --commit 模式。\n\nsharp：一个高性能的 Node.js 图像处理库，在 postinstall 脚本中自动下载和安装预编译的二进制文件。\n\nnode-sass：Node.js 版本的 Sass 编译器，其 postinstall 用于处理跨平台安装，并在安装过程中下载对应平台所需的二进制文件。\n\n`npm postinstall` 是一个 npm 生命周期钩子，它在安装包及其依赖项之后运行。这是一个强大的钩子，您可以利用它执行一些在安装后需要进行的操作。以下是在使用 `npm postinstall` 时要遵循的一些建议和最佳实践：\n\n1. **避免过度使用**: 尽管 `postinstall` 具有很大的灵活性，但应避免将其用于不必要的操作。它最适合用于编译/构建代码、生成配置文件或执行其他需要在安装包之后执行的操作。\n\n2. **将操作过程告知用户**: 在执行 `postinstall` 期间，如果有可能的话，请向用户显示操作进度、实时日志或相关提示。这有助于用户了解在安装过程中发生了什么，以及如何解决可能出现的问题。\n\n3. **确保脚本可移植**: 在不同的操作系统和环境下，`postinstall` 脚本可能会表现不同。避免使用特定平台的命令或工具，以确保在各种环境中都能正常工作。\n\n4. **优雅地处理错误**: 如果 `postinstall` 脚本无法执行某些操作，优雅地处理这些错误，并向用户提供有关发生问题的原因和可能的解决方案的信息。\n\n5. **尽量提前中断**: 当检测到可能导致`postinstall`无法正常执行的问题时，尽量提前中断脚本。例如，通常应确保所有依赖项可用，然后再执行其他操作。\n\n6. **考虑在安装某些可选依赖时使用 `postinstall`**: 如果某些依赖项是可选，可以利用 `postinstall`脚本来根据用户环境或需求进行下载。这将有助于减小初始安装文件的大小。\n\n7. **避免进行不必要的网络活动**: 在`postinstall`过程中不建议下载或上传大量不必要的数据。仅在需要时才执行此类操作，以减少安装时间和带宽占用。\n\n8. **确保兼容性**: 请确保您的 `postinstall` 脚本与不同版本的 Node.js 和 npm 兼容。如果必须要求特定版本，请在 `package.json` 中指定所需的 Node.js 和 npm 版本范围。\n\n9. **不要破坏用户环境**: 不要在 `postinstall` 脚本中修改全局的 Node.js 安装和环境，并确保不要破坏用户设备上的其他软件和配置。\n\n10. **在开发环境和生产环境之间做出区分**：根据需要，可以使用 `NODE_ENV` 环境变量来了解当前处于生产环境还是开发环境。在不同环境中选择相应的行为，如避免在生产环境中包含只在开发环境中才需要的文件。\n\n遵循以上最佳实践，可以确保 `postinstall` 脚本在各种环境中正常工作，提供良好的用户体验，并避免对用户的环境产生不良影响。\n\n### usr/local/bin/pnpm: line 8: 33087 Killed: 9\npnpm 进程在执行时被意外终止（Killed: 9）\n1. 内存不足：系统可能由于资源限制（如内存不足）终止了进程。确保你的系统有足够的可用内存。\n2. 权限问题：确保你有正确的权限运行 pnpm。根据你提供的路径（`/usr/local/bin/pnpm`），它应该是全局安装的。尝试以管理员身份（使用 sudo）运行 pnpm 命令，例如：\n   ```\n   sudo pnpm install\n   ```\n3. 确保正确安装了 Node.js 和 pnpm。运行以下命令以检查 Node.js 和 pnpm 的版本：\n   ```\n   node -v\n   pnpm -v\n   ```\n   如果你看到这些命令中的任何一个调用失败或给出错误，请先解决这些错误。\n4. 重新安装 pnpm，因为它可能已损坏或不完整。\n   首先卸载 pnpm：\n   ```\n   npm uninstall -g pnpm\n   ```\n   然后重新全局安装 pnpm：\n   ```\n   npm install -g pnpm\n   ```\n用n装npm也是，也会给提示，也是权限问题；\n\n### --exact\n`npm install --exact` 命令是用于安装 Node.js 项目的依赖项，并确保安装的包版本与 `package.json` 文件中指定的版本完全匹配。`--exact` 标志表示安装的版本将不受 [语义化版本](https://semver.org/) 约束，而是严格遵循 package.json 中指定的确切版本。\n\n例如，如果你需要安装一个名为 `my-package` 的依赖项，可以使用以下命令：\n\n```\nnpm install --exact my-package\n```\n\n### update\n- npm update -g @nestjs/cli\n- npx nest new 项目名 (不用update)\n\n\n### cache\n`_cache`目录是一个包含Node.js类库(metadata)缓存的目录。其中用SHA1哈希值命名文件夹来存储某个特定版本的软件包。在npm 5及以上版本中，由于使用了Content Addressable方式对缓存进行存储，因此`content-v2`目录才开始出现。\n\n让我们看一下缓存目录的结构：\n\n```\n.npm\n└─ _cacache\n   └─ content-v2\n      ├─ sha1\n      │  ├─ aa\n      │  │  └─ 0115c9b19af2c6784c200fa612de\n      │  └─ bb\n      │     └─ 0715c9b19af2c6891c105fa612de\n      ├─ sha256\n      │  ├─ aa\n      │  │  └─ 0115c9b19af2c6784c200fa612de\n      │  └─ bb\n      │     └─ 0715c9b19af2c6891c105fa612de\n```\n\n在这个结构中，\n\n- `content-v2`文件夹包含两个子文件夹，分别基于两种不同的哈希算法：`sha1`和`sha256`。\n- 每个哈希算法文件夹下，按文件哈希值的前两个字符分类存储，比如：`aa`, `bb`。\n- 具体的缓存文件则存在于以上分类文件夹中。\n\n这种方式的好处在于与其他包中重复的文件只会缓存一次，避免了重复存储相同内容，从而节省了磁盘空间。\n\n要注意的是，你应该不需要直接操作`.npm/_cacache`目录。你可以使用npm CLI的内置缓存命令（例如`npm cache verify`）来管理、清除和验证缓存。更多关于npm缓存请参考官方文档：https://docs.npmjs.com/cli/v8/commands/npm-cache\n\n### npm version\n`npm version` 命令：使用 `npm version` 命令来更新 `package.json` 文件中的版本号。这个命令也可以自动创建一个新的 Git 标签。\n`^` 和 `~`字符：在 `package.json` 文件中，可以使用这些字符来指定一个版本范围，使项目能够自动接收 bug 修复和小更新，但不会突然接收到大的更新。\n`npm outdated`：这个命令可以检查所有依赖项的当前版本和最新版本，有助于跟踪哪些依赖包需要更新。\n`npm audit`：这个命令可以检查项目依赖项中的安全漏洞。如果发现有安全问题的依赖，可以使用 `npm audit fix` 来自动更新这些依赖包。"},{"title":"github-actions","url":"/2021/03/17/github-actions/","content":"https://github.com/developit/redaxios\n这个项目有.github/workflows文件\n\ngithub actions:\nhttps://docs.github.com/cn/actions/quickstart\n\nhttps://docs.github.com/en/github/using-git/git-workflows\n\n### artus workflow 配置\n#### package.json\npackage.json + \"ci\"\n\n#### .github/workflows\nnodejs.yml\n```\n# This workflow will do a clean install of node dependencies, build the source code and run tests across different versions of node\n# For more information see: https://help.github.com/actions/language-and-framework-guides/using-nodejs-with-github-actions\n\nname: Node.js CI\n\non:\n  push:\n    branches:\n      - main\n      - master\n  pull_request:\n    branches:\n      - main\n      - master\n  schedule:\n    - cron: '0 2 * * *'\n\njobs:\n  build:\n    runs-on: ${{ matrix.os }}\n\n    strategy:\n      fail-fast: false\n      matrix:\n        node-version: [14, 16, 18]\n        os: [ubuntu-latest, windows-latest, macos-latest]\n\n    steps:\n    - name: Checkout Git Source\n      uses: actions/checkout@v2\n\n    - name: Use Node.js ${{ matrix.node-version }}\n      uses: actions/setup-node@v1\n      with:\n        node-version: ${{ matrix.node-version }}\n\n    - name: Install Dependencies\n      run: npm i\n\n    - name: Continuous Integration\n      run: npm run ci\n\n    - name: Code Coverage\n      uses: codecov/codecov-action@v1\n      with:\n        token: ${{ secrets.CODECOV_TOKEN }}\n\n```"},{"title":"BigInt","url":"/2021/03/16/BigInt/","content":"### 文档指南：\nhttps://v8.dev/features/bigint\nhttps://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/BigInt\n\nTC39——（18年fullstack大会上，Brendan Eich介绍，会在TC39加入BigInt：这是一种新的值类型，用于处理任意精度的整数；）\nhttps://tc39.es/ecma262/#sec-bigint-objects\n```\n21.2.1 The BigInt Constructor\nThe BigInt constructor:\n\nis %BigInt%.\nis the initial value of the \"BigInt\" property of the global object.\nperforms a type conversion when called as a function rather than as a constructor.\nis not intended to be used with the new operator or to be subclassed. It may be used as the value of an extends clause of a class definition but a super call to the BigInt constructor will cause an exception.\n```\n\n### 查看浏览器是否实现了这个API\n```\nlet target = new Set()\nlet arrs = [\"BigInt\"]\narrs.forEach(o=>target.add(o))\nlet all = Object.getOwnPropertyNames(window)\nlet ifHas = all.filter(e=>target.has(e))\n```\n\n### 最大安全数\nhttps://2ality.com/2013/10/safe-integers.html\n\n\n### 延伸\nString的maxLength\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/length\n```\nThis property returns the number of code units in the string. UTF-16, the string format used by JavaScript, uses a single 16-bit code unit to represent the most common characters, but needs to use two code units for less commonly-used characters, so it's possible for the value returned by length to not match the actual number of characters in the string.\n\nECMAScript 2016 (ed. 7) established a maximum length of 2^53 - 1 elements. Previously, no maximum length was specified. In Firefox, strings have a maximum length of 2**30 - 2 (~1GB). In versions prior to Firefox 65, the maximum length was 2**28 - 1 (~256MB).\n\nFor an empty string, length is 0.\n\nThe static property String.length is unrelated to the length of strings, it's the arity of the String function (loosely, the number of formal parameters it has), which is 1.\n```\n\n### 类型转换\n```\n“等值（==）”运算中，不能确定左、右操作数的类型；（JavaScript 认为，如果左、右操作数之一为 string、number、bigint 和 symbol 四种基础类型之一，而另一个操作数是对象类型 (x)，那么就需要将对象类型“转换成基础类型（ToPrimitive(x)）”来进行比较。操作数将尽量转换为数字来进行比较，即最终结果将等效于：Number(x) == Number(y)。）\n```\n\n### 相关\n- V8——2018 年，团队为 WebAssembly 发布了一个名为 Liftoff 的基线编译器，它大大减少了 WebAssembly 应用程序的启动时间，同时提供了可预测的性能。并且发布了 BigInt，这是一个新的 JavaScript 原始类型，可以实现任意精度的整数。\n\n### A small, fast JavaScript library for arbitrary-precision decimal arithmetic.\n- https://github.com/MikeMcl/big.js/\n```\n一个小型、快速的 JavaScript 库，用于任意精度的十进制运算。\n简单的应用程序接口\n比 JavaScript 版本的 Java BigDecimal 更快、更小、更易用\n最小化后仅 6 KB\n复制 JavaScript Numbers 的 toExponential、toFixed 和 toPrecision 方法\n以可访问的十进制浮点格式存储数值\n全面的文档和测试集\n无依赖关系\n仅使用 ECMAScript 3，因此可在所有浏览器中运行\n是 bignumber.js 和 decimal.js 的姊妹篇。关于它们之间的区别，请参阅此处。\n```\n\n### mathjs\n- https://github.com/josdejong/mathjs\n- Math.js 是一个适用于 JavaScript 和 Node.js 的广泛数学库。它具有灵活的表达式解析器，支持符号计算，提供了大量内置函数和常量，并提供了处理不同数据类型（如数字、大数、复数、分数、单位和矩阵）的集成解决方案。功能强大，易于使用。"},{"title":"Array的reduce方法","url":"/2021/03/16/Array的reduce方法/","content":"### MDN文档指南：\nhttps://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce\n\n### 使用实例\nListNode的数据结构，如果我想把一个数组，转成ListNode的结构：\n```\n// leetcode2.两数相加\n\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\nlet sum = 324\nlet arr = [...sum.toString()]\narr.reduce((acc,v)=>({val: v, next: acc}), null)\n```\n### 参考阅读材料：\n- 深入浅出RxJS——6.1.3:规约统计（虽然讲的是rxjs中的reduce，但是对理解JavaScript中的reduce很有帮助）\n```\n无论是JavaScript数组原生支持的reduce，还是RxJS中的reduce操作符，都接受一个函数参数，这个函数参数就是“规约函数”，规约函数的形式如下：\nfunction(accumulation,current){\n  //accumulation是当前累计值，current是当前数据\n  //函数应该返回最新的累计值\n}\nreduce的功能就是对一个集合中所有元素依次调用这个规约函数，这个规约函数可以返回一个“累积”的结果，然后这个“累积”的结果会作为参数和数据集合的下一个元素一起成为规约函数下次被调用的参数，如此遍历集合中所有的元素，因为规约函数可以任意定义，所以最后得到的“累积”结果也就完全可定制。\n\n程墨. 深入浅出RxJS (实战) (Chinese Edition) (Kindle Locations 2496-2502). Kindle Edition. \n```\n\n- JavaScript高级程序设计——5.2.9缩小方法\n```\nECMAScript5还新增了两个缩小数组的方法：reduce()和reduceRight()。这两个方法都会迭代数组的所有项，然后构建一个最终返回的值。\n其中，reduce()方法从数组的第一项开始，逐个遍历到最后。\n而reduceRight()则从数组的最后一项开始，向前遍历到第一项。\n这两个方法都接收两个参数：一个在每一项上调用的函数和（可选的）作为缩小基础的初始值。\n传给reduce()和reduceRight()的函数接收4个参数：前一个值、当前值、项的索引和数组对象。这个函数返回的任何值都会作为第一个参数自动传给下一项。第一次迭代发生在数组的第二项上，因此第一个参数是数组的第一项，第二个参数就是数组的第二项。\n\n泽卡斯(Zakas. Nicholas C.). JavaScript高级程序设计(第3版) (图灵程序设计丛书) (Chinese Edition) (Kindle Locations 3555-3562). 人民邮电出版社. Kindle Edition. \n```\n\n- 深入理解ES6\n箭头函数和数组：\n箭头函数的语法简洁，非常适用于数组处理。\n诸如sort()、map()及reduce()这些可以接受回调函数的数组方法，都可以通过箭头函数语法简化编码过程并减少编码量。\n\n刘振涛. 深入理解ES6 (Chinese Edition) (Kindle Location 1196). Kindle Edition. \n在线版本(https://leanpub.com/understandinges6/read#leanpub-auto-arrow-functions)\n\n### 杂谈 \n\n> 函数式编程的一个重要洞见就是，大部分操作都可以归结成列表转换，其中，最核心的列表转换就是 map、filter 和 reduce\n> python中的正则表达参考了Perl，而内置函数lambada,map,reduce,filter等参考了lisp\n\n\n### flat\n- https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/flat\n```\nvar arr = [1, 2, [3, 4]];\n\n// 展开一层数组\narr.flat();\n// 等效于\narr.reduce((acc, val) => acc.concat(val), []);\n// [1, 2, 3, 4]\n\n// 使用扩展运算符 ...\nconst flattened = arr => [].concat(...arr);\n```"},{"title":"javascript-reverse","url":"/2021/03/16/javascript-reverse/","content":"## reverse\n文档指南：https://www.freecodecamp.org/news/how-to-reverse-a-string-in-javascript-in-3-different-ways-75e4763c68cb/\n\n\n\n## for ... in\n- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...in\n- Reference - Statements&declarations\n- for ... in 不应用于迭代一个数组，因为迭代的顺序是依赖于执行环境的\n- 如果需要迭代访问顺序很重要的数组，用整数索引去进行for 的循环\n- for in 适用于debug\n- 具体可以看MDN的文档\n\n## callback\n\n## 立即执行函数\n```\n    const width = 512\n      const height = 512\n      ;(async function () {\n        const program = await doodle.load('./lib/fragment.glsl')\n        doodle.useProgram(program)\n        doodle.uniforms.resolution = [width, height]\n        doodle.render()\n      })()\n```\n- ; 如果少了，就会报错\n- `{(intermediate value)(intermediate value)} is not a function`\n- 立即执行函数前面需要分号\n\n\n#### ReferenceError\n- https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/ReferenceError\n- 报错合集:The ReferenceError object represents an error when a non-existent variable is referenced.\n- 当一个不存在的变量被引用时发生的错误\n```\nfunction foo () {\n  console.log(bar)\n  let bar = 3\n}\nfoo()\n```"},{"title":"chrome版本更新","url":"/2021/03/15/chrome版本更新/","content":"\n今天测试老师report了一个在Chrome浏览器上的样式问题，排查了下，88无问题，89有问题 —— 具体查，某个没有用scoped的模块，/deep/没有处理\n让具体的开发老师处理了下代码，那为什么渲染会有差异呢，哪部分的处理变更了呢，查了下Chrome的更新文档\n\n在Google直接搜索 web updates\nhttps://developers.google.com/web/updates/2021\nhttps://chromium.googlesource.com/chromium/src/+log/89.0.4389.72..89.0.4389.82?pretty=fuller&n=10000\nhttps://developer.chrome.com/blog/deps-rems-89/\n\n[Deprecation] /deep/ combinator is no longer supported in CSS dynamic profile.It is now effectively no-op, acting as if it were a descendant combinator. /deep/ combinator will be removed, and will be invalid at M65. You should remove it. See https://www.chromestatus.com/features/4964279606312960 for more details.\n\n\nhttps://www.chromestatus.com/features#%2Fdeep%2F\n\nhttps://segmentfault.com/a/1190000021576348\n\nhttps://www.cnblogs.com/CyLee/p/10006065.html\n\nhttps://vue-loader.vuejs.org/guide/scoped-css.html#deep-selectors\n\nnode_modules/@vue/component-compiler-utils/lib/stylePlugins/scoped.ts\n```\nnode.selector = selectorParser((selectors: any) => {\n      selectors.each((selector: any) => {\n        let node: any = null\n\n        // find the last child node to insert attribute selector\n        selector.each((n: any) => {\n          // \">>>\" combinator\n          // and /deep/ alias for >>>, since >>> doesn't work in SASS\n          if (\n            n.type === 'combinator' &&\n            (n.value === '>>>' || n.value === '/deep/')\n          ) {\n            n.value = ' '\n            n.spaces.before = n.spaces.after = ''\n            return false\n          }\n\n          // in newer versions of sass, /deep/ support is also dropped, so add a ::v-deep alias\n          if (n.type === 'pseudo' && n.value === '::v-deep') {\n            n.value = n.spaces.before = n.spaces.after = ''\n            return false\n          }\n\n          if (n.type !== 'pseudo' && n.type !== 'combinator') {\n            node = n\n          }\n        })\n\n        if (node) {\n          node.spaces.after = ''\n        } else {\n          // For deep selectors & standalone pseudo selectors,\n          // the attribute selectors are prepended rather than appended.\n          // So all leading spaces must be eliminated to avoid problems.\n          selector.first.spaces.before = ''\n        }\n\n        selector.insertAfter(\n          node,\n          selectorParser.attribute({\n            attribute: id\n          })\n        )\n      })\n    }).processSync(node.selector)\n```\n\n\n从设计角度来说，我们也不推荐使用嵌套过多:\n```\nVery nested SCSS produces big CSS output and is less reusable than little nested one.\n\nUse nesting to not repeat yourself when scoping of selectors is necessary, not to reflect the document structure.\n\nSupported by: http://youtu.be/fPAf8dN4G4w?t=26m17s and http://youtu.be/hou2wJCh3XE?t=4m11s\n```\n\n### chrome 版本\n- https://omahaproxy.appspot.com/\n- https://commondatastorage.googleapis.com/chromium-browser-snapshots/index.html\n\n- https://chromiumdash.appspot.com/schedule (很清楚，有内核也有对应browser的)\n- https://chromestatus.com/roadmap (更新的特性)\n### 118的问题\n- 有问题\n\n### Chrome Enterprise and Education release notes\n- https://support.google.com/chrome/a/answer/7679408?sjid=6136179283723156290-AP\n- https://chromereleases.googleblog.com/2023/\n\n","tags":["chrome"]},{"title":"feign","url":"/2021/03/15/feign/","content":"#### 最近要接入神策埋点，数据采集接入的话，API接入部分，使用feign api方式调用\n\n```\nHow does Feign work?\nFeign works by processing annotations into a templatized request. Arguments are applied to these templates in a straightforward fashion before output. Although Feign is limited to supporting text-based APIs, it dramatically simplifies system aspects such as replaying requests. Furthermore, Feign makes it easy to unit test your conversions knowing this.\n```\n#### 文档指南：\nhttps://github.com/OpenFeign/feign\n\n为什么要使用feign呢？\n\n#### feign的扩展：\n\n提高扩展性，使用者可以不修改框架源码的情况下，为框架扩展新的功能（类似于插件模式）\nfeign 是一个 HTTP 客户端框架，我们可以在不修改框架源码的情况下，用如下方式来扩展我们自己的编解码方式、日志、拦截器等。\n```\n\nFeign feign = Feign.builder()\n        .logger(new CustomizedLogger())\n        .encoder(new FormEncoder(new JacksonEncoder()))\n        .decoder(new JacksonDecoder())\n        .errorDecoder(new ResponseErrorDecoder())\n        .requestInterceptor(new RequestHeadersInterceptor()).build();\n\npublic class RequestHeadersInterceptor implements RequestInterceptor {  \n  @Override\n  public void apply(RequestTemplate template) {\n    template.header(\"appId\", \"...\");\n    template.header(\"version\", \"...\");\n    template.header(\"timestamp\", \"...\");\n    template.header(\"token\", \"...\");\n    template.header(\"idempotent-token\", \"...\");\n    template.header(\"sequence-id\", \"...\");\n}\n\npublic class CustomizedLogger extends feign.Logger {\n  //...\n}\n\npublic class ResponseErrorDecoder implements ErrorDecoder {\n  @Override\n  public Exception decode(String methodKey, Response response) {\n    //...\n  }\n}\n```\n\n\n\n### other cases\n#### A\nhystrix - https://github.com/Netflix/Hystrix\n```\nHystrix是一个用于分布式系统的容错库，它主要用于隔离访问远程系统、服务和第三方库的节点，防止其故障级联到其它部分影响整个系统。\nHystrix通过提供线程池、超时设置、熔断器（Circuit Breaker）以及监控和实时配置等一系列工具，给微服务带来了稳定性和弹性。 \nHystrix是Netflix开源项目的一部分，用Java编写，并且基于Java的并发和异步库实现。\n\n使用Hystrix的主要优点如下：\n\n1. 提供熔断器：通过使用熔断器模式来防止对不稳定服务的访问。当服务连续发生一定数量的错误时，熔断器会“熔断”，此时会快速返回一个默认结果而不是继续访问故障服务。当故障服务回复后，熔断器会自动“闭合”，重新允许对服务的访问。\n\n2. 线程隔离： Hystrix使用线程池来隔离对远程服务的访问，这样您可以控制使用的并发，防止一个服务的崩溃导致整个系统崩溃。\n\n3. 超时设置：你可以为每个远程服务调用设置超时时间，以便在服务未在规定时间内响应时终止访问。\n\n4. 提供指标和监控：Hystrix提供了实时监控指标，以便你可以跟踪每个服务的性能，包括成功、失败、熔断和线程使用的统计数据。\n\n5. 使用Fallback：当远程服务调用错误或超时时，Hystrix提供了fallback方法，允许你返回指定的默认值，确保微服务在故障的情况下依然可以返回有用的信息。\n\n总之，Hystrix可提高分布式系统的稳定性、弹性和容错能力。 在网络和服务不稳定的情况下，Hystrix能起到很大作用。\n```\n降级方案 - 系统之间feign调用\n\n#### B\n- sentinel - 资源|规则 - 流量控制-自由选择控制的角度，灵活组合，从而达到想要的效果 -熔断降级-降低调用链路中的不稳定资源 - 系统负载保护\n- sentinel(面向分布式服务架构的流量控制组件) - 适配feign\n```\nfeign.sentinel.enable=true\nerror\nNoSuchMethodErrorfeign.RequestTemplate.path（）Ljava / lang / String;\n版本不匹配 - spring-cloud-starter-alibaba-sentinel feign-core\n解决 - 添加流量规则\nMethod：http://service-name/path\n```\n\n#### C\nokhttp3性能 > httpclient\nfeign底层 更换为 okhttp3\n"},{"title":"mathquill在项目中的应用","url":"/2021/03/15/mathquill在项目中的应用/","content":"\n文档指路：http://docs.mathquill.com/en/latest/\n\n### 前置知识\n\n#### latex\n\n### 项目应用\n\n1. 先拉取源码，进行改造\n\n### 关于全等的一些事儿\n- https://www.zhihu.com/question/61401308\n- 这个问答说的特别清楚，来龙去脉前世今生\n\n#### latex公式编辑器\n- https://www.latexlive.com/\n#### latex 渲染服务器\n- GitHub 就有一个latex渲染服务器\n- VS Code Math to Image - 插件\n- https://github.com/TeamMeow/vscode-math-to-image\n- https://medium.com/spencerweekly/vs-code-math-to-image-write-latex-math-equations-in-github-markdown-the-easy-way-9fa8b81dc910\n\n","tags":["mathquill","editor"]},{"title":"intro-to-redaxios","url":"/2021/03/12/intro-to-redaxios/"},{"title":"leetcode-shell-4道题","url":"/2021/03/11/leetcode-shell-4道题/","content":"\n### 192.统计词频\nhttps://leetcode-cn.com/problems/word-frequency/\n\n```\ncat words.txt | tr -s ' ' '\\n' | sort | uniq -c | sort -r | awk '{print $2, $1}'\n```\n命令说明：（man cmd）\n- cat -- concatenate(link (things) together in a chain or series) and print files\n```\n(The cat utility reads files sequentially, writing them to the standard output.)\n```\n- tr -- translate characters\n```\n(The tr utility copies the standard input to the standard output with sub-stitution or deletion of selected characters.)\n(-s      Squeeze multiple occurrences of the characters listed in the last\n             operand (either string1 or string2) in the input into a single\n             instance of the character.  This occurs after all deletion and\n             translation is completed.)\n```\n- sort -- sort or merge records (lines) of text and binary files\n```\n-r, --reverse\n             Sort in reverse order.\n```\n- uniq -- report or filter out repeated lines in a file\n```\n-c      Precede each output line with the count of the number of times\n             the line occurred in the input, followed by a single space.\n```\n- awk - pattern-directed scanning and processing language（很强大，只用他也能完成这个任务，不过如果是只用这个的话，也可以用编写起来更趁手的python或者node来处理了）\n\n分词这一步```tr -s ' ' '\\n'```也可以替换成```xargs -n1```\n\n### 193.有效电话号码\nhttps://leetcode-cn.com/problems/valid-phone-numbers/\n\n- 分析正则\n- 使用grep/awk/gawk都可\n```\ngrep -P '^([0-9]{3}-|\\([0-9]{3}\\) )[0-9]{3}-[0-9]{4}$' file.txt\nawk '/^([0-9]{3}-|\\([0-9]{3}\\) )[0-9]{3}-[0-9]{4}$/' file.txt\n```\n### 194.转置文件\nhttps://leetcode-cn.com/problems/transpose-file/\n```\n# Read from the file file.txt and print its transposed content to stdout.\ncolumns=$(cat file.txt | head -n 1 | wc -w)\nfor i in $(seq 1 $columns)\ndo\nawk '{print $'''$i'''}' file.txt | xargs\ndone\n\n```","tags":["leetcode"]},{"title":"学习娱乐资料-外网篇","url":"/2021/03/10/学习娱乐资料-外网篇/","content":"1. 挑战类：\nhttp://www.pythonchallenge.com/\nhttps://www.codewars.com/\n\nhttps://github.com/wesbos/JavaScript30\n\n\n2. 播客类\n\n\n\n\n3. Twitter订阅\n\n\n\n4. Youtube订阅\n\n\n\n5. 新手入门类\n- Brian Holt 在 frontend masters上面有一系列的trial的课程，里面的参考资料在他的 [github page](http://btholt.github.io/)上\n- https://btholt.github.io/intro-to-web-dev-v2/\n\n\n- Bianca Gandolfo 在 frontend masters上面有一个trial的算法课（A Practical Guide to Algorithms with JavaScript）\n## 资料：https://slides.com/bgando\n## 主要内容：\n### Introduction\n- Introducing Practical Guide to Algorithms\n  - why algorithms are essential to all engineers\n\n### Space & Time Complexity\n- Introducing Space & Time Complexity\n  - the concept of time complexity, space complexity, and understanding algorithmic speed\n\n- Native Methods & JavaScript\n  - time complexity of Native JavaScript methods and expressions such as property access, loops, and native array methods\n  - map, reduce and sort\n\n- Big O Notation\n  - the different big O notations: constant, linear, quadratic,logarithmic, and exponentical\n\n- Space Complexity & Review\n  - https://www.geeksforgeeks.org/analysis-of-algorithms-set-3asymptotic-notations/\n- Big O:Loop\n  - disset function with a loop to reason about the time complexity\n\n- Big O:Property Lookup\n  - a property lookup in an array.length and measure time complexity\n\n- Big O:Push,Shift,&Unshif\n  - contrast different array methods and their respective time complexity\n\n### Optimization with Caching\n- Fas\n\n \n"},{"title":"DNS解析","url":"/2021/03/10/DNS解析/","content":"\n> 由腾讯云的DNSPod文档讲起\n\n文档指南：\nhttps://cloud.tencent.com/document/product/302/3449\n\n各记录类型的设置：\n- 通过添加 A 记录可将域名指向一个 IP 地址（外网地址）\n- 如果需要将域名指向另一个域名，再由另一个域名提供 IP 地址，就需要添加 CNAME 记录，最常用到 CNAME 的场景包括做 CDN、做企业邮箱。\n- 如果需要设置邮箱，让邮箱能收到邮件，就需要添加 MX 记录。\n- 如果需要将子域名交给其他 DNS 服务商解析，则需要添加 NS 记录。\n- 通过添加 AAAA 记录可将域名指向一个 IPv6 地址。\n- SRV 记录用来标识某台服务器使用了某个服务，常见于微软系统的目录管理。\n- 如果希望对域名进行标识和说明，可以使用 TXT 记录，绝大多数的 TXT 记录是用来做 SPF 记录（反垃圾邮件）。\n- 将一个域名指向另外一个已经存在的站点时，需要添加 URL 记录。\n  - 隐性转发：用的是 iframe 框架技术、非重定向技术，效果为浏览器地址栏输入 http://a.com 回车，打开网站内容是目标地址 http://cloud.tencent.com/ 的网站内容，但地址栏显示当前地址 http://a.com 。\n  - 显性转发：用的是301重定向技术，效果为浏览器地址栏输入 http://a.com 回车，打开网站内容是目标地址 http://cloud.tencent.com/ 的网站内容，且地址栏显示目标地址 http://cloud.tencent.com/。\n  - 添加 URL 转发记录时，涉及到的两个域名已完成备案。未经备案的域名无法添加 URL 转发。\n  - 备案内容要和Document title一致\n\n  ### 传统DNS\n  - 域名缓存\n  - 域名转发\n  - 出口NAT（网络地址转换）\n  - 域名更新\n\n\n  ### HTTPDNS\n  #### 应用场景\n  - 手机端嵌入SDK\n  - 解决本地DNS服务缓存更新不及时的问题\n\n  #### 设计\n  - 缓存设计\n    - 客户端SDK，本地缓存，HTTPDNS服务器\n    - 缓存的过期，更新，不一致的问题\n    - 同步更新-Cache-Aside\n    - 异步更新-Refresh-Ahead （Guava Cache）\n  - 调度设计\n  #### cases\n  - https://juejin.cn/post/7200278589874782265\n\n\n #### dig\n 查DNS的问题\n 一般做了CDN缓存，可以用这个看看，或者新上的域名，运维配置有没有问题；\n\n ### 一些问题\n Alpine - 可能会有dns解析超时问题\n虽然 Alpine Linux 由于其小差异、安全和简单性而受到许多 Docker 用户的喜爱，但它确实存在一些问题，其中之一就是 DNS 解析问题。\n\n关于 DNS 解析问题，大多是由于 Alpine 使用的是 musl libc，而不是 glibc。此差异可能会引起一些特定的问题，尤其是在 DNS 解析和网络中。\n\n如果你的应用依赖于特定的 glibc 功能，或者你发现了 Alpine 引导的问题，那么使用更大的基础镜像（如 debian 或 ubuntu）可能会更好。即使它们占用的空间更多一些，但它们可能避免了一些潜在的问题。","tags":["tencent-cloud","DNS"]},{"title":"electron应用签名问题","url":"/2021/03/08/electron应用签名问题/","content":"### 代码签名：\n- 自定义测试（无法自动更新）签名：\n1. 钥匙串访问=>证书助理=>创建证书=>自定签名的根证书，代码签名\n2. export CSC_NAME=\"Electron Auto Update\"\n（https://www.electron.build/code-signing）\n<pre>\nmacOS and Windows code signing is supported. Windows is dual code-signed (SHA1 & SHA256 hashing algorithms).\n\nOn a macOS development machine, a valid and appropriate identity from your keychain will be automatically used.\n\nCSC_NAME\tmacOS-only Name of certificate (to retrieve from login.keychain). Useful on a development machine (not on CI) if you have several identities (otherwise don’t specify it).\n</pre>\n\n- 从Xcode里面 偏好设置-accounts-manage certificates +developer id application ,加到钥匙串里面即可\n\n### 包签名\n无法打开“XXXPro”，因为Apple无法检查其是否包含恶意软件。\n\n已阻止使用“XXXPro”,因为来自身份不明的开发者 仍要打开 \n\n\n### 自定义安装界面\nhttps://www.electron.build/configuration/dmg\n可以在electron-builder的configuration里面进行配置：\nmacOS我们目前是dmg的产出，可以按照文档进行配置\n\n### 创建目录路径选择\n根目录：/\n用户目录：～\n在根目录创建文件的时候会出现：read-only file system\n\n\n\n### 查看日志\ncd ~/Library/Cache\ncd ~/Library/Application Support\n\ncd ~/Library/Logs\n\n### 公证\n- https://kilianvalkhof.com/2019/electron/notarizing-your-electron-application/\n现有软件，已用集团账号导出的证书进行了code signing —— 代码的开发者签名10.14\n\nhttps://support.apple.com/zh-cn/guide/mac-help/mh40616/mac \n（给用户看的操作链接）\n\nhttps://support.apple.com/zh-cn/HT202491\n（高版本的系统还需要公证） Catalina 及以上版本\n\n2019的wwdc19 公证面面观\n公证就是关于在分发前识别和拦截恶意的Mac软件，而无需App Review团队或Mac App Store的参与。在去年推出。\n公证方法：\nhttps://oldj.net/article/2019/12/29/electron-builder-sign-and-notarize-for-macos/\n\nhttps://github.com/electron/electron-notarize\n\n```\n// 公证操作执行命令：\nxcrun altool --notarize-app --primary-bundle-id \"cn.xxx.xx.xxxx\" --username \"xxx@xxx.cn\" --password \"apppasswd\" --asc-provider \"providerNameXXX\" -t osx --file xxx.dmg\n// 说明：\n// xxx.dmg 替换为要公证的文件名，执行命令和要公证的文件包（xxx.dmg）在同一目录下\n// cn.xxx.xx.xxxx 替换成应用到bundleid\n// providerNameXXX 是providerName，根据邮箱和密码查出来的\nxcrun altool --list-providers --username \"xxx@xxx.cn\" --password \"apppasswd\"\n// 结果如下，则上传成功：\nNo errors uploading 'xxx.dmg'.\nRequestUUID = \"一串字符串\"\n// 公证成功会收到邮件：\n// 或者可以通过命令查公证状态：\nxcrun altool --notarization-info \"RequestUUID\" --username \"xxx@xxx.cn\" --password \"apppasswd\"\n公证成功后，安装APP，不会再有安全提示拦截（每次上线新版本前需进行公证）\n\n```\n\n## 杀毒软件误杀问题处理\n\n### 360（Win）\n\n- 开启360，第一次安装或更新的软件的时候，360会弹出“有程序试图修改关键程序DLL文件”的警告\n- 用公司账号登录360软件开放平台。选择首页的提交软件检测并填写相关信息，等待审核。审核通过后解决（在第一次更新时360还是会弹窗，后续每次更新客户端时，在打包后都需执行上述过程，则不会再次弹窗）\n\n\n### McAfee(Win)\n- McAfee 我们当时遇到的问题是，集团给员工配置的电脑，会安装McAfee ，程序会McAfee 被删除。\n- 目前解决方案：\n1. 如果时集团配备的电脑自带的McAfee 软件，问题已解决，可以通过集团统一配置白名单，放行内部软件;\n2. 如果自己装的McAfee 软件，则有关闭实时扫描的权限，可以关闭实时扫描，避免误杀；\n- 集团那边收到的信息是，软件触发了自适应威胁防护清理，因为软件的信誉低于配置的清理阈值；\n- McAfee 关于误杀的问题，需要我们这边提供软件的英文操作说明，然后进行审核；\n- 厂商给的文档里面是让提高软件信誉度（在TIE服务器或McAfee GTI上的信誉值）\n- 安全部门给到开发部门的紧急解决流程\n```\n- 提供一个登录账号用于人工排查\n- 先人工安装排查一下是否有异常进程，并用其他杀毒软件交叉验证，尽快反馈结果\n- 同时请将问题反馈给Mcafee厂商，判断是否是误报或是如何判断为木马的，以便产品开发进行修改。\n- 如果人工排查结果没有发现异常，可以先开启白名单，避免影响业务人员的工作。同时跟进Mcafee的反馈。\n```\n- 软件如果嵌入网页，尽量https，http请求很容易被判定为高风险\n- 我们这边本地没有部署TIE服务器\n\n#### windows - pfx签名\n- https://www.electron.build/code-signing.html\n- 按照build的官方文档操作即可\n- 因为我们是一个仓库，通过配置参数，打包不同的客户端，使用同一个pfx签名，所以配置到打包配置文件里面\n- 在build/xxx/config.js里面加上\n```\nwin: {\n    icon: \"build/xxx/icon.ico\",\n    target: [\n      {\n        target: \"nsis\",\n        arch: [\n          \"ia32\"\n        ]\n      }\n    ],\n    // 新增下面\n    certificateFile: './codesign.pfx',\n    certificatePassword: 'xxxxxxxxxx'\n  },\n\n```\n有个安全性的问题\n一旦Windows进行提权的操作，可能会被误认为有危险性\n```\n+    \"requestedExecutionLevel\": \"requireAdministrator\",\n     \n     \"nsis\": {\n-    \"oneClick\": true\n+    \"oneClick\": false,\n+    \"perMachine\": false,\n+    \"allowToChangeInstallationDirectory\": true\n   },\n\n```\n\n### 清除缓存功能\n\n\n## 运维问题\n> 沉淀了两份文档，一份给运营一份给开发，还有Windows的一些操作指南\n- 先做预判，快速有个问题处理导向\n- 一定解决问题，不管通过什么方式\n- 注意问题记录，积累经验和话术\n### installer intergrity check has failed - 下载包不完整\n\n### 安装进度栏卡死 - 彻底卸载之前文件 - %appdata%\n\n### 系统问题，可以选择兼容性处理，右键属性-兼容性-以兼容模式运行这个程序\n\n\n### 安装完没有能创建快捷方式 - %appdata% -> 到安装目录，发送桌面快捷方式\n\n\n### 白屏 - 浏览器能打开里面嵌入到网页 - 确认是网络问题后\n- 控制面板 -> internet选项 -> 连接 -> 局域网设置\n\n### win7系统.net Framework版本过低\n- 登录Microsoft网站https://dotnet.microsoft.com/download/dotnet-framework，下载.net Framework最新版本（推荐.NET Framework 4.8 (recommended)），安装\n"},{"title":"typescript实践经验总结","url":"/2021/03/08/typescript实践经验总结/","content":"> https://www.typescriptlang.org/docs/handbook/intro.html - handbook随手查～\n\n> 多看下生成的JS，从而看看处理的逻辑（使用不同的ES标准进行编译）\n### 几个迁移的案例\nhttps://developers.google.com/web/updates/2021/01/puppeteer-typescript\n\n\n### react-typescript\n- https://github.com/typescript-cheatsheets/react\n- https://react-typescript-cheatsheet.netlify.app/docs/basic/setup\n### ROI \n- 团队迁移成本\n（开发思维，开发生态，项目处理，接口及声明文件的维护）\n\n\n### redaxios\nhttps://www.tslang.cn/docs/handbook/type-checking-javascript-files.html\nhttps://github.com/Microsoft/TypeScript/wiki/JSDoc-support-in-JavaScript\n使用JSDoc注解\n```\n// https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html\n支持的JSDoc\n下面的列表列出了当前所支持的JSDoc注解，你可以用它们在JavaScript文件里添加类型信息。\n\n注意，没有在下面列出的标记（例如@async）都是还不支持的。\n\n@type\n@param (or @arg or @argument)\n@returns (or @return)\n@typedef\n@callback\n@template\n@class (or @constructor)\n@this\n@extends (or @augments)\n@enum\n它们代表的意义与usejsdoc.org上面给出的通常是一致的或者是它的超集。 \n```\n\n### 推荐相关文档：\nhttps://zhuanlan.zhihu.com/p/40322215\nhttps://labs.thisdot.co/blog/your-first-vue-3-app-using-typescript\nhttps://medium.com/vue-typescript/vue-3-with-typescript-setup-a-new-project-with-the-vue-cli-4ea806be7a91\n\n\n### 推荐TS入门：\nhttps://basarat.gitbook.io/typescript/getting-started\nhttps://jkchao.github.io/typescript-book-chinese/typings/types.html#%E4%BD%BF%E7%94%A8-types\n\n### 教程推荐\n- 英文OK的还是官方文档\n    - https://www.typescriptlang.org/docs/handbook/basic-types.html\n    - 更新及时，对应版本准确\n- 中文的话：\n    - http://ts.xcatliu.com/\n\n\n## 项目总结\n\n### 接入的第三方插件\n#### sentry\n- sentry本身就有@sentry/types，被JavaScript 相关的 SDK依赖，所以没啥问题，安装之后，就支持了\n- https://getsentry.github.io/sentry-javascript/\n\n\n### type vs interface\n官方example\n```\n// There are two main tools to declare the shape of an\n// object: interfaces and type aliases.\n//\n// They are very similar, and for the most common cases\n// act the same.\n\ntype BirdType = {\n  wings: 2;\n};\n\ninterface BirdInterface {\n  wings: 2;\n}\n\nconst bird1: BirdType = { wings: 2 };\nconst bird2: BirdInterface = { wings: 2 };\n\n// Because TypeScript is a structural type system,\n// it's possible to intermix their use too.\n\nconst bird3: BirdInterface = bird1;\n\n// They both support extending other interfaces and types.\n// Type aliases do this via intersection types, while\n// interfaces have a keyword.\n\ntype Owl = { nocturnal: true } & BirdType;\ntype Robin = { nocturnal: false } & BirdInterface;\n\ninterface Peacock extends BirdType {\n  colourful: true;\n  flies: false;\n}\ninterface Chicken extends BirdInterface {\n  colourful: false;\n  flies: false;\n}\n\nlet owl: Owl = { wings: 2, nocturnal: true };\nlet chicken: Chicken = { wings: 2, colourful: false, flies: false };\n\n// That said, we recommend you use interfaces over type\n// aliases. Specifically, because you will get better error\n// messages. If you hover over the following errors, you can\n// see how TypeScript can provide terser and more focused\n// messages when working with interfaces like Chicken.\n\nowl = chicken;\nchicken = owl;\n\n// One major difference between type aliases vs interfaces\n// are that interfaces are open and type aliases are closed.\n// This means you can extend an interface by declaring it\n// a second time.\n\ninterface Kitten {\n  purrs: boolean;\n}\n\ninterface Kitten {\n  colour: string;\n}\n\n// In the other case a type cannot be changed outside of\n// its declaration.\n\ntype Puppy = {\n  color: string;\n};\n\ntype Puppy = {\n  toys: number;\n};\n\n// Depending on your goals, this difference could be a\n// positive or a negative. However for publicly exposed\n// types, it's a better call to make them an interface.\n\n// One of the best resources for seeing all of the edge\n// cases around types vs interfaces, this stack overflow\n// thread is a good place to start:\n\n// https://stackoverflow.com/questions/37233735/typescript-interfaces-vs-types/52682220#52682220\n\n```\n\n\n### declare\n- https://www.typescriptlang.org/docs/handbook/declaration-files/by-example.html\n#### declare module 'xxx'\n- 声明一个全局模块\n- 解决查找模块路径的问题\n```\n# env.d.ts\n\n/// <reference types=\"vite/client\" />\n\ndeclare module '*.vue' {\n  import type { DefineComponent } from 'vue'\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/ban-types\n  const component: DefineComponent<{}, {}, any>\n  export default component\n}\n```\n- 环境声明 - *.d.ts文件, 里面每个根级别的声明需要以declare作为前缀\n\n### 当你安装TypeScript时，会顺带安装一个lib.d.ts声明文件。这个文件包含JavaScript运行时及DOM（Document Object Model，文档对象模型）中存在的各种常见的JavaScript环境声明。● 它自动包含在TypeScript项目的编译上下文中。● 它能让你快速开始书写经过类型检查的JavaScript代码。\n## tsconfig\n- strictNullCheck 建议设置true，如果有需要都允许的地方，可以使用联合类型\n\n\n## sources\n- https://drive.google.com/file/d/170oHzpLNeprUa-TMmOAnSU4caEFDSb3e/view\n- https://github.com/mike-works/typescript-fundamentals/tree/v2#dependencies\n\n\n## why\n> 用typescript的原因，是一种思维模式上面的减负；想应该想的，一些语言特性里面的遗留问题，不需要再想\n```\nundefined == null // true \nundefined === null // false\n```\nhttps://github.com/lodash/lodash.git\n\n#### 注释\n```\nTypeScript 的 3.7 版本引入了 @ts-nocheck 注释，可以增加在 TypeScript 文件的头部来禁用语义检查。我们没有使用这个注释，因为它之前不支持.ts/.tsx 文件，但它也可以在迁移过程中成为一个很好的中间阶段助手。\n\nTypeScript 的 3.9 版本引入了 @ts-expect-error 注释。当一行以 @ts-expect-error 注释作为前缀时，TypeScript 将禁止报告该错误。如果没有错误，TypeScript 会报告 @ts-expect-error 是不必要的。在 Airbnb 代码库，我们使用了 @ts-expect-error 而不是 @ts-ignore 。\nhttps://medium.com/airbnb-engineering/ts-migrate-a-tool-for-migrating-to-typescript-at-scale-cd23bfeb5cc​​​\n```\n\n### Prototypes\n- https://gist.github.com/gaearon/a25fd42a1e6b4cc24851978df0a36571\n- Beneath Classes: Prototypes\n- https://2ality.com/2015/09/proto-es6.html\n- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter\n- https://esdiscuss.org/topic/having-a-non-enumerable-array-prototype-contains-may-not-be-web-compatible"},{"title":"深入使用vscode-打磨一把趁手的刻刀","url":"/2021/03/08/深入使用vscode-打磨一把趁手的刻刀/","content":"\n### 参考资源：\n\ngitbook （https://burkeholland.gitbook.io/vs-code-can-do-that/）\n系统的介绍了 vscode 的使用，还有一些很棒的 tricks，各种拓展的选择和使用\n\nfrontend masters 有 course，gitbook 里面是 exercise\n\n如果使用上面的材料：\nvscode 可以安装这个 extension —— (慎重全部安装，可以查看下，按需安装)\nhttps://marketplace.visualstudio.com/items?itemName=burkeholland.vs-code-can-do-that\ndocker ——\nhttps://docs.docker.com/get-docker/\ngit + node\n\n提供了一个测试项目：\ngit clone https://github.com/burkeholland/workshop-vs-code-can-do-that\n\n### 重要的快捷键\n\n- 快捷用 vscode 打开项目\n\n```\ncode .\n\n# https://github.com/ohmyzsh/ohmyzsh/tree/master/plugins/vscode\ncode --diff file file\ncode --goto file:line[:char]\ncode --verbose\n\n```\n\n需要先：\n(Cmd/Ctrl + Shift + P) and select \"Shell Command: Install 'code' command in path\".\n\nMac 的话，也可以构建任务流，这样就可以右键选择，里面“用 vscode 打开了”\n\n- Mac 里面 Cmd 是主要的控制键，Windows 里面 Ctrl 是主要的控制键\n- 一些常用的快捷键(写成 Mac 的，Windows 的换控制键为 Ctrl 即可)\n- sidebar 的切换(Cmd + B)\n- 打开命令面板(Cmd + shift + P)\n- 打开文件面板(Cmd + P)\n- 打开设置(Cmd + ,)\n- 集成终端视图切换(Ctrl + `) => (私人换了，一般应该是Cmd + `)\n\n### 定制编辑器\n\n#### 切换主题/安装 icon 主题/切换字体\n\n(Cmd/Ctrl + Shift + P)\n\n- \"Preferences: Color Theme\".\n拖到最底下，可以下载想要安装的主题（颜色主题）\n\n- \"Preferences: File Icon Theme\"\nmaterial 比较清晰，可以区分 workspace 和 file(icon 主题)\n\n- FiraCode/Hasklig/Monoid\n\n- https://github.com/tonsky/FiraCode\n- https://github.com/i-tu/Hasklig\n\n- font ligatures\n- 有些字体支持 \"字体连字\"。这些符号代表我们在编程中使用的复合符号。如果你正在使用的字体支持它们，你可以通过勾选 \"Editor.Font Ligatures\"框来打开它们。\n\n#### 编辑器调整\n\n- minimap(缩略图),其实不太好用，可以关掉\n\n- Settings(Cmd+,) => 搜索 Minimap => 取消 enable 的选择\n\n- sidebar 位置调整\n\n- 在 cmd + shift + p\n- 输入 toggle sidebar position\n\n- open enditors (打开的编辑器)\n- 其实我们可以通过 cmd + p 快速搜索文件，所以这部分如果想关掉，可以 Settings(Cmd+,) => 搜索 Explorer › Open Editors: Visible\n  “打开编辑器”窗格中显示的编辑器的数量。将其设置为 0 将隐藏“打开编辑器”窗格 => 还有别的设置，可以更细粒度的控制这部分\n\n#### 设置部分改成默认打开为 json\n\n- cmd + , 搜索 Workbench › Settings: Editor 配置默认使用的设置编辑器 => 改为 json\n- 如果想保留 UI 的快捷打开，可以在键盘快捷方式里面，open settings (ui)，可以自己设置一个，我设置成了（cmd + alt + ,）\n\n#### peacock\n\n- cmd + shift + P => peacock:enter a color\n- settings 增加这两行，这样看起来颜色没那么鲜艳:\n\"peacock.affectActivityBar\": false\n\"peacock.affectStatusBar\": false\n\n### 生产力提高技巧\n\n#### 基本导航快捷键\n\n- cmd + 0 焦点到 sidebar\n- cmd + 1 焦点到编辑器\n下面几个都是英文首字母：\n- cmd + shift + e 资源管理器 explorer\n- cmd + shift + d 运行和调试 debug\n- ctrl + shift + g 源代码管理器 git\n- cmd + shift + x 扩展 extensions\n- cursor 位置移动 —— On Mac: Ctrl + - ... navigate back / Ctrl + Shift + - ... navigate forward\n- cmd + shift + o 如果是 markdown 文件，可以快速选择定位到哪个标题\n\n#### Emmet\n\n- 输入! （记住是英文输入法）然后 Tab 键\n- 这个时候按 Tab 键，可以在标题和属性设置间切换，按序修改我们需要修改的地方\n- (Cmd/Ctrl + Shift + P) and select \"Emmet: Balance Outward\" 可以一层层的选择标签\n- (Cmd/Ctrl + Shift + P) and select \"Emmet: Wrap with abbreviation\" 可以可以快速在外层包标签(.test)\n- (Cmd/Ctrl + Shift + P) and select \"Format Document\" 可以快速格式化文件,输入 format on save，可以选择是否要在保存时候格式化文档，推荐不要选，因为文件有差异，还是走具体项目的格式化\n- emmet 样式上面，也可以用缩写，还是很好用的，省时间\n\n#### auto close tag Extensions\n\n可以安装这个插件，修改 tag 名的时候，闭合标签会跟着改动(根据说明配置 settings)\nemmet 也可以达到这个=> cmd + shift + P ，输入 update tag\n\n#### 移动，复制和删除\n\n- 复制一行 opt/alt + shift + down/up arrow\n- 移动一行 opt/alt + down/up arrow\n- 删除一行 cmd + shift + k\n\nvscode 里面，光标在哪一行，直接 cmd + c/x/v ,就可以复制/剪切了\n\n#### folding sections\n\n- html/code 光标放在需要折叠的区域 cmd + shift + P => fold\n- fold region ，可以添加 a comment with //#region at the start of the block and //#endregion at the end.\n创建折叠区域\n- cmd + k + 0，0 是代码折叠级别,全部折叠，同理可以换用 1，2，3\n- cmd + k + j 展开所有代码块\n\n#### 快速注释\n\n- cmd + / 注释行\n\n#### 选中word\n- cmd + d\n\n#### editor切换tab\ncmd + option + <- | -> \n\n## Words\n\nhttps://burkeholland.gitbook.io/vs-code-can-do-that/\n\n- That denotes that these are separate workspaces, not folders. Other icon themes will not make this distinction as you can see below in Chalice Icons.\n这表示这些是独立的工作空间，而不是文件夹。其他图标主题不会做出这种区分，你可以在下面的 Chalice Icons 中看到。\n\n- prerequisite | BrE priːˈrɛkwɪzɪt, AmE priˈrɛkwəzət |\nA. noun\n先决条件\n▸ to be a prerequisite for sth;\n是某事的前提\n\n- You can make some tweaks to the visual components of the editor to increase the available space and improve legibility.你可以对编辑器的视觉组件进行一些调整，增加可用空间，提高可读性。\n\n- Here are a few more keyboard shortcuts to add to your repertoire( a list or supply of dramas, operas, pieces, or parts that a company or person is prepared to perform).\n\n## ts\n\n### ts 支持，但是目前首行报错\nvetur.experimental.templateInterpolationService\n\n### <script setup>\n如果使用了<script setup>\n用 Volar\n禁掉 Vetur\n\n- https://github.com/vuejs/rfcs/blob/script-setup/active-rfcs/0000-script-setup.md\n- https://github.com/vuejs/vue-next/blob/master/CHANGELOG.md 里面搜索 <script setup>\n\n\n### ligatures\nhttps://worldofzero.com/posts/enable-font-ligatures-vscode/\nhttps://marketplace.visualstudio.com/items?itemName=sdras.night-owl\nhttps://marketplace.visualstudio.com/items?itemName=vscode-icons-team.vscode-icons\n\n\n#### debug\nF5进入debug模式\n\n### 查找，正则\n- 先开启正则模式\n- .* 匹配任意数量任意字符\n\n#### `.vscode/settings.json` 文件是 Visual Studio Code 的一个配置文件，用于为特定项目自定义设置。\n```\n\"cSpell.words\"是Code Spell Checker 插件提供的一个设置选项。Code Spell Checker 是一个用于检查拼写错误的 Visual Studio Code 插件。\n\"cSpell.words\" 的值应该是一个数组，其中包含的单词将被添加到插件的词汇表中。这就意味着这些单词不会被拼写检查器标记为拼写错误，即使它们不在默认的英语词典中。\n例如：\n{\n    \"cSpell.words\": [\"jsonwebtoken\", \"bcryptjs\", \"eslint\", \"mocha\", \"chai\"]\n}\n在这个例子中，“jsonwebtoken”, \"bcryptjs\", \"eslint\", \"mocha\"和\"chai\"这些单词不会被拼写检查器标记为错误，即使它们不是标准的英语单词。这对编程中的库名、函数名等非标准英语词汇提供了方便的拼写检查。\n```"},{"title":"从腾讯云服务器迁移到静态网站部署服务上去","url":"/2021/03/05/从腾讯云服务器迁移到静态网站部署服务上去/","content":"### 迁移\n博客是基于 hexo 构建的，直接买了服务，按照 [文档](https://cloud.tencent.com/document/product/876/47141)来就行 \n```\n npm i -g @cloudbase/cli\n cd public // 进入博客项目构建完成的目录下\n ls\n tcb login\n cloudbase framework deploy -e xxxx-123123 // 最后的xxxx-123123为环境id\n```\n简单上面几个命令即可发布\n\n博客的域名cname下，做下解析就可以了，这部分腾讯云也都有手把手的文档\n\n### https续费\n- 证书续了之后\n- 因为使用的是静态网站托管的服务\n- 在基础配置里面-自定义域名-编辑-重新选择下新申请的证书，然后强制HTTPS\n- 这时候状态会自动重新部署\n- 之后再访问，就OK了\n\n### 工作中\n> 聊到cname，项目里面一个资源迁移的事儿\n\n- 资源从阿里云迁移到腾讯云\n- 对外域名不变\n- 对外的这个域名是要做CDN加速的\n\n所以要处理两步：\n1. 在腾讯云上面配置CDN域名加速，https也要注意处理好\n2. 在对外域名的管理端，增加CNAME到腾讯云的加速域名\n\n### cloudbase-templates\n- 官方提供的templates\n\n"},{"title":"nodejs-doc","url":"/2021/03/04/nodejs-doc/","content":"\n### centos 安装\n- rpm\n- yum (install | clean all) 如果版本安装有问题，记得按照官方distribution的文档里面写的，做好处理，不然会被缓存影响\n- 或者直接通过nvm安装 - https://github.com/nvm-sh/nvm/tree/v0.39.3\n```\ncurl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.3/install.sh | bash\nwget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.3/install.sh | bash\nexport NVM_DIR=\"$([ -z \"${XDG_CONFIG_HOME-}\" ] && printf %s \"${HOME}/.nvm\" || printf %s \"${XDG_CONFIG_HOME}/nvm\")\"\n[ -s \"$NVM_DIR/nvm.sh\" ] && \\. \"$NVM_DIR/nvm.sh\" # This loads nvm\n```\n- centos7不支持nodejs18的安装，会提示依赖有问题，具体可见github上面的issue\n```\n机器版本：\nCentOS Linux release 7.9.2009 (Core)\n用户issue：\nhttps://github.com/nodejs/node/issues/43246\n官方支持声明：\nSupported CentOS versions:\n* CentOS 7 (64-bit) WARNING: BUILD SYSTEM CURRENTLY BROKEN FOR NODEJS 18+\n* CentOS 8 (64-bit)\n* CentOS 8 Stream (64-bit)\n\n因已知及潜在兼容性问题，和官方支持声明，所以安装16+版本，提供nvm进行切换\n\n安装：\n走rpm装18的时候的报错\n\ncurl -fsSL https://rpm.nodesource.com/setup_lts.x | bash -\nError: Package: 2:nodejs-18.14.2-1nodesource.x86_64 (nodesource)\n           Requires: libstdc++.so.6(GLIBCXX_3.4.21)(64bit)\nError: Package: 2:nodejs-18.14.2-1nodesource.x86_64 (nodesource)\n           Requires: libm.so.6(GLIBC_2.27)(64bit)\nError: Package: 2:nodejs-18.14.2-1nodesource.x86_64 (nodesource)\n           Requires: libstdc++.so.6(GLIBCXX_3.4.20)(64bit)\nError: Package: 2:nodejs-18.14.2-1nodesource.x86_64 (nodesource)\n           Requires: libstdc++.so.6(CXXABI_1.3.9)(64bit)\nError: Package: 2:nodejs-18.14.2-1nodesource.x86_64 (nodesource)\n           Requires: libc.so.6(GLIBC_2.28)(64bit)\n You could try using --skip-broken to work around the problem\n You could try running: rpm -Va --nofiles --nodigest\n```\n\n\n\n## latest\n- corepack - https://github.com/nodejs/corepack\n- undici WG - https://github.com/nodejs/undici\n- diagnostics WG - 门槛更低的诊断能力\n- Node-API WG - 现代化，API稳定的Addon API\n- strategic-initiatives - https://github.com/nodejs/node/blob/main/doc/contributing/strategic-initiatives.md\n- https://nodejs.org/calendar\n## nodejs-path\n### 文档指北：\nhttps://nodejs.org/api/path.html#path_path\nhttp://nodejs.cn/api/path.html\n还是推荐dash,可以快速搜索，然后选择右上角copy online page\n\n### 项目经验\nnode服务项目\nelectron项目\n\n### globals\n- https://nodejs.org/api/globals.html\n\n### Module\n- https://nodejs.org/api/packages.html\n\n\n\n### querystring\n- https://nodejs.org/dist/latest-v16.x/docs/api/querystring.html\n```\n/**\n * The `querystring` module provides utilities for parsing and formatting URL\n * query strings. It can be accessed using:\n *\n * ```js\n * const querystring = require('querystring');\n * ```\n *\n * The `querystring` API is considered Legacy. While it is still maintained,\n * new code should use the `URLSearchParams` API instead.\n * @deprecated Legacy\n * @see [source](https://github.com/nodejs/node/blob/v18.0.0/lib/querystring.js)\n */\n```\n- https://nodejs.org/dist/latest-v16.x/docs/api/url.html#class-urlsearchparams\n\n### 基础架构（原理）\n\n\n### api\n#### vm\n- https://nodejs.org/api/vm.html\n- https://www.youtube.com/watch?v=u81pS05W1JY\n- https://pwnisher.gitlab.io/nodejs/sandbox/2019/02/21/sandboxing-nodejs-is-hard.html\n用这个实现基于ES6模版字符串语法语法的模版引擎\n- 通过VM模块编译JS形成函数\n    - include子模版\n    - XSS过滤、模版helper函数\n\n### npm\n#### easy_sock\n\n\n#### https://www.npmjs.com/package/protocol-buffers\n\n### slides - ryan dahl 的一系列在conf里面的演讲，不同阶段，可以去YTB上面看\n- nodejs ry@tinyclouds 2009 - 最初的设计，为什么这么设计\n- https://www.slideshare.net/JSFestUA/js-fest-2019-ryan-dahl-deno-a-new-way-to-javascript\n\n#### perf_hooks\nperf_hooks\n解决这个报warining的问题\n先新建一个项目，引入perf_hooks,没有任何问题\n看了不同版本的代码，发现引入的问题，升级了版本即可\nhttp://nodejs.cn/api/perf_hooks.html\n\n\n### cases\n#### fetch - 和nodejs的版本相关\nRequestInit: duplex option is required when sending a body #46221\nhttps://github.com/nodejs/node/issues/46221\n\n\n### addon\nNode.js 的 addon 允许本地（C/C++）库与 JavaScript 代码进行交互\n\n- 图像处理\nOpenCV（Open Source Computer Vision Library）使用 OpenCV 进行实时视频处理、人脸识别和物体追踪等高性能操作\n\n- 加密和解密\n加密和解密通常需要执行大量计算，本地库（如 OpenSSL）在这方面的执行效果通常比纯 JavaScript 更高效\n\n- 文件系统操作\n进行文件压缩与解压缩操作时，本地库（如 zlib）的性能可能优于纯 JavaScript 实现\n\n- 数值计算与科学计算\nLAPACK - Linear Algebra PACKage、FFTW - Fastest Fourier Transform in the West）\n\n- 机器学习、深度学习及人工智能\nTensorFlow,C++\n\n### error\n```\n{\n  opensslErrorStack: [ 'error:03000086:digital envelope routines::initialization error' ],\n  library: 'digital envelope routines',\n  reason: 'unsupported',\n  code: 'ERR_OSSL_EVP_UNSUPPORTED'\n}\n```\nnodejs 版本过高\nvue-cli的项目，降级nodejs到16.x能用，18，20都报错","tags":["node"]},{"title":"nodejs-path","url":"/2021/03/04/nodejs-path/","content":"### 文档指北：\nhttps://nodejs.org/api/path.html#path_path\nhttp://nodejs.cn/api/path.html\n还是推荐dash,可以快速搜索，然后选择右上角copy online page\n\n### 项目经验\nnode服务项目\n\n\n\n\n\n\n\nelectron项目\n\n### glob\n- https://www.npmjs.com/package/glob\n- https://github.com/isaacs/node-glob\n- 支持配置通配符规则的方式来扫描文件目录，像在 shell 里执行命令一样，获取匹配对应规则的文件\n```\n__dirname 脚本文件所在目录\nprocess.cwd() 脚本文件执行目录\n```\n\n### 当前文件和目录所在位置\n- __dirname __filename  (express-generator __dirname确定项目模版目录所在位置)\n\n### 当前终端执行路径\n- process.cwd()\n\n### 当前系统用户主目录\n- process.env.HOME - HOMEPATH - USERPROFILE\n- os - homedir\n\n\n#### 模块依赖图\n- brew install graphviz\n- npm i -g npm2dot","tags":["node"]},{"title":"lambda理解小记","url":"/2021/03/04/lambda理解小记/","content":"### feature-core\n#### 函数是一等公民\n- 函数（值 | 运算 | 参数 | 返回值）\n- 在lambda演算中，不存在其他公民\n#### 柯理化\n- 限制\n- lambda演算不支持多参数\n\n#### 纯函数/不可变性\n- lambda演算中不存在复制运算，它只能产生纯函数，数据也一定不可变\n\n#### 高阶函数\n- 因为lambda演算中存在函数以外的值，所有函数一定是高阶函数\n\n### essential\n- 函数是一等公民 && 闭包\n- 语言本身可能提供高阶特性，没必要全都用lambda推导\n- lambda是图灵完备的，这意味着它可以实现任何算法（递归是一种表现形式，而不是一种算法）"},{"title":"electron入门参考指北","url":"/2021/03/03/electron入门参考指北/","content":"团队在electron方面的经验已经积累了2年多了，从较轻量级的客户端，到重量级的客户端；也不断有新同学想要学习或者加入相关项目的评审，这个时候回推荐一些相关的入门文档和demo,做个记录，之后可以直接扔链接了。\n\n### 安装网络问题\n```\nRequestError: socket hang up\n    at ClientRequest.<anonymous> \n    at Object.onceWrapper (events.js:483:26)\n    at ClientRequest.emit (events.js:388:22)\n    at ClientRequest.origin.emit \n    at TLSSocket.socketOnEnd (_http_client.js:499:9)\n    at TLSSocket.emit (events.js:388:22)\n    at endReadableNT (internal/streams/readable.js:1336:12)\n    at processTicksAndRejections (internal/process/task_queues.js:82:21)\n```\n- 保证网络即可\n\n### learning-intro\n- https://electronjs.org/docs\n文档啦，关于看文档，这儿推荐一本书，叫《如何阅读一本书》，讲得就是如何阅读的，其实我们好多人的阅读能力还停留在小学六年级水平，看了这本书，还是大有裨益。\n- https://github.com/electron/electron-api-demos\n结合文档，跑一遍这个demo,对能做什么，做成什么样，就会有很直观的认知（electron官方出的）\n- electron fiddle https://www.electronjs.org/fiddle\n也是官方出的，可以试用功能，改代码查看功能，可以看看代码是否能在electron指定的版本上面运行\n- TIPS:\n  - webPreferences.nodeIntegration 这个选项的关闭还是开启需要注意（安全问题）_https://www.electronjs.org/docs/tutorial/security ,可以按照官方说明进行处理.\n      - ⚠️ Under no circumstances should you load and execute remote code with Node.js integration enabled. Instead, use only local files (packaged together with your application) to execute Node.js code. To display remote content, use the <webview> tag or BrowserView, make sure to disable the nodeIntegration and enable contextIsolation.\n  - 如果开启了nodeIntegration，用<script>引入jQuery就会有问题， jQuery内部会对require变量判断，和node的require冲突；所以只能\n    ```\n    window.$ = window.jQuery = require('./jquery-3.5.1.min)\n    ```\n新版本不可  <script src=\"https://cdn.bootcdn.net/ajax/libs/jquery/3.5.1/jquery.min.js\"></script>\n旧版本可以  <script src=\"https://cdn.bootcdn.net/ajax/libs/jquery/1.4.1/jquery.min.js\"></script>\n```\n$.fn.jquery\n1.4.1\n$.fn.jquery\nVM338:1 Uncaught TypeError: Cannot read property 'jquery' of undefined\n    at <anonymous>:1:6\n```\n\n### log\n#### electron-log\n文档：https://github.com/megahertz/electron-log\nBy default, it writes logs to the following locations:\n\non Linux: ~/.config/{app name}/logs/{process type}.log\non macOS: ~/Library/Logs/{app name}/{process type}.log\non Windows: %USERPROFILE%\\AppData\\Roaming\\{app name}\\logs\\{process type}.log\n\n可以引入之后再封装一层\n### 及时关注版本发布\nhttps://www.electronjs.org/releases/stable\n版本更新解决了什么问题\n比如对M1芯片的支持，big sur的支持等～\n\n\n### 网络问题判断\nonline\noffline\n网络状态不好有两种情况：\n1. 切断物理连接本身\n2. 网络本身有问题(如路由等具体问题)\n嗯呢，navigator.onLine不完全可靠，无法检测网络真实状态，只能判断是否是物理切断连接\n通用更可靠方案是：定时向服务器发起任意一个能够判断网络状态的请求，类似心跳连接\n\nUnfortunately, these events aren't fully reliable. If you need greater reliability, or if the API isn't implemented in the browser, you can use other signals to detect if you are offline including using service workers and responses from XMLHttpRequest.\n————————————————————————\nhttps://developer.mozilla.org/en-US/docs/Web/API/NavigatorOnLine/Online_and_offline_events\n\nhttps://github.com/sindresorhus/is-online\n\nhttps://www.electronjs.org/docs/tutorial/online-offline-events\n\n\n### sentry - error\n- Error: EBUSY: resource busy or locked\n```\nThe main reason you are seeing this error is due to a program putting a lock on the folder for whatever reason. Testing the command while closing programs one at a time can help resolve the issue and let you know which program is the culprit.\nOne issue people were having was with anti-malware on windows. You can read through this thread here:\nhttps://github.com/npm/npm/issues/13461\nIn case link stops working here was the most upvoted comment:\nIn Windows 10 64-bit OS, I have resolved this issue by uninstalling Anti-Malware software. - 卸载杀毒软件\nAnother way you can trigger this error is if you are running an npm run [command] while cd'd into the directory that its altering. This happened to me where I closed every program and it didn't work, but realized I was inside the dist folder which needed to be removed and rebuilt. This triggered the Error: EBUSY: resource busy or locked, rmdir error in PowerShell and can be reproduced every time.\n```\n\n### Preload\nwebPreferences-preload\n(https://www.electronjs.org/docs/api/browser-window)\n\n\n### download\n我们项目中基于downloadItem实现的\n可以看看这个项目（@electron/get）的实现https://github.com/electron/get\n\n### 安装背景图\n如果想要背景清楚，可以用二倍图，文件命名符合规则即可生效\n<pre>\nAdopt the @2x Naming Convention\nWhen you create a high-resolution version of an image, follow this naming convention for the image pair:\n\nStandard: <ImageName>.<filename_extension>\nExample: circle.png\n\nHigh resolution: <ImageName>@2x.<filename_extension>\nExample: circle@2x.png\n\nThe <ImageName> and <filename_extension> portions specify the name and extension for the file. The inclusion of the @2x modifier for the high-resolution image lets the system know that the image is the high-resolution variant of the standard image. The two component images should be in the same folder in the app’s sources. Ideally, package the image pairs into one file (see Package Multiple Versions of Image Resources into One File).\n</pre>\n\n\n### 可参考他人踩坑文档\nhttps://www.yuque.com/arvinxx-fe/electron\n本质还是项目中遇到问题，解决问题，有空了彻底解决问题\n\n\n### app-builder\n- https://www.npmjs.com/package/app-builder-bin\n\n```\napp-builder\nGeneric helper tool to build app in a distributable formats. Used by electron-builder but applicable not only for building Electron applications\n```\n- https://github.com/electron-userland/electron-builder\n```\n和node的版本有关 - 16.X的时候\nreify:app-builder-bin: timing reifyNode:node_modules/typescript Completed in 6782ms\n```\n\n## feature\n#### -webkit-app-region\n- https://github.com/electron/electron/issues/1354\n- https://www.electronjs.org/zh/docs/latest/api/frameless-window\n- 父元素设置了，子元素不想，可以重新设置下子元素的这个属性\n\n#### window\n- 适时显示窗口\n- 不规则窗口的设置\n- 点击穿透透明区域 - trick\n- 多窗口资源竞争问题 （渲染进程通信 - node-fs.watch - token令牌来控制文件读写）\n- 模态窗口\n\n#### Mac｜win\n- process.versions.electron\n- nativeTheme.shouldUseDarkColors\n\n#### webContents\n- 监听页面事件\n- 页面加载时间 ｜ 页面跳转事件-navigate|redirect\n- webFrame - 访问和控制子页面的对象\n- getFoucusedWebContents\n\n#### Canvas|Svg\n- Canvas - 较小的画布上绘制大量元素，较强的频繁重绘能力 - 当绘制元素超出画布大小之后，绘制工作不再占用渲染资源\n- Svg - 大型渲染区域绘制少量元素，或者需要复杂事件交互逻辑的图形\n- Canvas - 线条变粗且颜色变淡的现象 - 计算机最小1px - 解决方案，宽度增加或者减少0.5个像素\n- PixiJS库","tags":["electron"]},{"title":"whistle-基于node实现的跨平台抓包调试代理工具","url":"/2021/03/02/whistle-基于node实现的跨平台抓包调试代理工具/","content":"\n### 应用场景\n- 开发环境下，截图图片资源调试时，跨域的问题（也可在本地起nginx代理）\n- 抓包配置交接问题\n\n### Start UP\n- [操作文档指南](http://wproxy.org/whistle/install.html)\n\n> 来点简单的\n```\nnpm i -g whistle\nw2 -h\nw2 start\n```\n\n### whistle代码分析\n\n\n### nohost\n- 基于whistle\n- [nohost接入文档及github链接](https://nohosts.github.io/nohost/)\n\n### Others\n- nginx本地起代理解决跨域问题\n\n\n## 应用场景\n### CASE1-前端域名代理\n#### 本地代理静态资源服务，用*.xdf.cn的域名即可\n- 安装whistle，起whistle服务\n```\n  npm i -g whistle // 安装whistle\n  w2 start // 起whistle\n```\n- 浏览器设置SwitchyOmega\n```\nchrome://extensions/ \n安装Proxy SwitchOmega，并进行配置\n情景模式-新增一个叫whistle的，配置如图，配置完点击应用选项\n\n![](redis-node.png)\n\n在插件栏，选择上我们刚刚配置到情景模式\n![](redis-node-2.png)\n\n\n打开http://127.0.0.1:8899/，配置规则\n选择 rules, 配置规则 127.0.0.1:8886 test.imagining.cn\n然后点击 save 按钮\n\n本地起完npm run dev 之后，浏览器输入 test.imagining.cn 即可访问本地\n\n- auto switch \n可以这边进行配置，处理代理之间的切换\n\n- https\n打开http://127.0.0.1:8899/\n点击https\n打开\"capture tunnel connects\"选项\n\n信任证书：\n双击下载的证书，选择始终信任\n\n重启W2:\nw2 stop\nw2 start\n```\n\n### 真机调试\n- https://github.com/liriliri/whistle.chii\n- 原理和weinre差不多\n```\n与传统的Web Inspector的使用场景不同， Weinre的使用场景如下图， 调试的页面在手机上， 调试工具在PC的chrome， 二者通过网络连接通信。\n```\n```\n# chii\nnpm i chii -g\nchii start -p\n按说明，在项目中引入target.js\n# https 的前端页面\n可以把chii部署到自己的放置前端服务的服务器上,这样我们就有了https的域名，及调试的服务了\n或者借助whistle，代理搞定一切\n```\n\n- https://juejin.cn/post/6844903592424374285#heading-2\n#### Safari\nMac\niphone｜ipad\n\n1. iPhone => 设置 => Safari浏览器 => 高级 => 网页检查器（开启）\n2. Mac => Safari => 偏好设置 => 高级 => 启动在菜单栏中显示“开发”菜单\n3. 数据线连接手机和电脑，信任设备\n4. 在手机Safari中打开需要调试的页面，在电脑上点击菜单栏的“开发”，选择手机，选择具体打开的页面\n5. 如果是APP里面的Webview，可以让iOS开发的老师提供可以debug的包（XXX的IOS端已开启，现在的包都是可以调试的），同Safari，只要进入APP需要调试的页面，在电脑打开Safari浏览器，选择页面，即可调试真机器上的页面；\n\n#### andriod\n\n1.设备连上电脑，选择信任\n2.设备里面的APP确保 WebView.setWebContentsDebuggingEnabled(true),xxx调试版本已经设置\n3.打开chrome://inspect/#devices\n都可以console里面打印performance信息，但是GPU的Chrome远程调试的时候performance也不提供\n\n如果要查看CPU使用率\n打开控制台之后：cmd + P => Mac\n输入：> show performance monitor\n即可查看\n- https://developer.chrome.com/docs/devtools/evaluate-performance/reference/\n- https://www.paulirish.com/2012/why-moving-elements-with-translate-is-better-than-posabs-topleft/\n- https://codepen.io/shospodarets/pen/QOQvyz - GPU渲染可用demo\n\n#### vconsole\n- https://www.npmjs.com/package/vconsole\n\n#### source - overrides\n- sources - overrides - select folders for overrides(选择本地空文件夹目录)\n- 在page中修改代码，cmd+S保存\n- devTools - more tools - changes","tags":["node"]},{"title":"pythonVSnode操作表格","url":"/2021/03/01/pythonVSnode操作表格/","content":"01 python VS node 操作表格\n\n• python 利用扩展库：\n# 这两个支持的是xls旧版本的操作\n```\npip3 install xlrd #支持excel读取(xls)\npip3 install xlwt # 支持excel写入(xls)\n```\n# 支持excel2010 xlsx/xlsm/xltx/xltm\n```\npip install openpyxl\n```\nhttp://www.python-excel.org/  This site contains pointers to the best information available about working with Excel files in the Python programming language.\n上面站点里面列出了较为popular 的 python处理excel文件的包\n\n```\nimport xlwt\nimport xlrd\nfrom openpyxl import Workbook\nfrom datetime import datetime\n\n\"\"\" openpyxl part \"\"\"\nwb = Workbook()\n\n# grab the active worksheet\nws = wb.active\n\n# Data can be assigned directly to cells\nws['A1'] = 42\n\n# Rows can also be appended\nws.append([1, 2, 3])\n\n# Python types will automatically be converted\nws['A2'] = datetime.now()\n\n# Save the file\nwb.save(\"sample.xlsx\")\n\n\n\"\"\" xlwt part \"\"\"\n# https://pypi.org/project/xlwt/\n\nstyle0 = xlwt.easyxf('font: name Times New Roman, color-index red, bold on',\n    num_format_str='#,##0.00')\nstyle1 = xlwt.easyxf(num_format_str='D-MMM-YY')\n\nwb = xlwt.Workbook()\nws = wb.add_sheet('A Test Sheet')\n\nws.write(0, 0, 1234.56, style0)\nws.write(1, 0, datetime.now(), style1)\nws.write(2, 0, 1)\nws.write(2, 1, 1)\nws.write(2, 2, xlwt.Formula(\"A30+D30\"))\n\nwb.save('xlwt-example.xls')\n\n\"\"\" xlrd part \"\"\"\n# https://pypi.org/project/xlrd/\nbook = xlrd.open_workbook(\"xlrd-example.xls\")\nprint(\"The number of worksheets is {0}\".format(book.nsheets))\nprint(\"Worksheet name(s): {0}\".format(book.sheet_names()))\nsh = book.sheet_by_index(0)\nprint(\"{0} {1} {2}\".format(sh.name, sh.nrows, sh.ncols))\nprint(\"Cell D30 is {0}\".format(sh.cell_value(rowx=29, colx=3)))\nfor rx in range(sh.nrows):\n    print(sh.row(rx))\n\n```\n\n• node 利用npm包(sheetjs-xlsx, github里面xlsx相关star最多的项目):\n```\nnpm install xlsx // https://www.npmjs.com/package/xlsx\n```\n- https://docs.sheetjs.com/\n\n\n\n\n\n\n### 总结扩展\n• 开放了API的Office套件，都可以通过操作API来实现想要的重复的，有逻辑的操作\n• 可以了解下open XML，Microsoft Office 中\n\n### Tips:\n\n• 命令行操作：\nman ls\nctrl + a 跳到行首\nctrl + e 跳到行末\nctrl + u 删除行首到光标位置\nctrl + k 删除行尾到光标位置\n\nmv/rename重命名\nrename需要homebrew安装\n\n• Python相关\npip list | grep xlwt\n\nPath,PurePath\n文档参考\nhttps://github.com/python/cpython/tree/3.9/Lib/pathlib.py\nhttps://docs.python.org/zh-cn/3/library/pathlib.html\n\n\n• 问题解决\nTraceback (most recent call last):\n  File \"xlwt.py\", line 1, in <module>\n    import xlwt\n  File \"/Users/py/xlwt.py\", line 13, in <module>\n    workbook = xlwt.Workbook(encoding='utf-8')\nAttributeError: module 'xlwt' has no attribute 'Workbook'\n文件名和导入的模块名不能是一样的\n\n\n## Excel相关\n- https://www.yuque.com/antfe/featured/ko8iuecqi9elaa1v\n\n### sheetjs相关\n- https://docs.sheetjs.com/docs/miscellany/\n\n渲染table - https://github.com/handsontable/handsontable\n\n### 其他 - Java\n- https://github.com/apache/poi\n- https://github.com/alibaba/easyexcel\n(快速、简洁、解决大文件内存溢出的java处理Excel工具)\n```\nApache POI和JXL在处理大数据量的Excel时，确实可能会出现内存溢出的问题。针对这个问题，Apache POI提供了SAX模式API。\n\n实际上，SAX(Simple API for XML)是一种基于事件驱动的API。这样可以实现你在解析文档时只把XML文档看成一系列的事件，然后编写处理事件的代码，这样可以极大地减小内存的消耗。\n\n而easyexcel在处理大Excel的性能上进一步优化，比如对07版Excel解析时的内存压缩，显著降低了内存消耗。EasyExcel在模型转换的封装也让开发者用起来更方便。\n```","tags":["node","Python"]},{"title":"SQL学习笔记之不同数据库中的执行","url":"/2021/01/07/SQL学习笔记之不同数据库中的执行/","content":"### Oracle中SQL的执行\n\n#### SQL语句\n\t- 语法检查\n\t\t- 检查SQL拼写\n\t- 语义检查\n\t\t- 检查SQL中国内地访问对象是否存在\n\t- 权限检查\n\t\t- 看用户是否具备访问该数据的权限\n\t- 共享池检查\n\t\t- shared pool 内存池\n\t\t\t- 库缓存\n\t\t\t\t- 决定SQL语句是否需要进行硬解析\n\t\t\t\t- 如何避免硬解析——绑定变量：在SQL语句中使用变量，通过不同变量取值来改变SQL的执行结果\n\t\t\t- 数据字典缓冲区\n\t\t\t\t- 对象定义\n\t\t\t\t- 表，视图，索引等对象\n\t\t\t\t- 对SQL语句进行解析对适合，如果需要相关数据，会从数据字典缓冲区中提取\n\t\t\t- 缓存SQL语句和该语句的执行计划\n\t\t- Oracle通过检查是否存在SQL语句的执行计划，来判断进行软解析还是硬解析\n\t\t- 执行（软解析）\n\t- 优化器（硬解析）\n\t\t- 决定怎么做，比如创建解析树，生成执行计划\n\t\t- 执行\n\t- 执行器\n\t\t- 基于解析树+执行计划\n\t\t- 在执行器中执行语句\n\n\n#### 如何避免硬解析，使用软解析？\noracle 绑定变量\n```\nselect * from a where a_id = 10001\nselect * from a where a_id = :a_id\n```\n但是动态SQL因为参数不同，SQL的执行效率也不同，给SQL优化带来了困难\n\n### MySQL\nC/S架构\n• 连接层\n• SQL层\n• 存储引擎层\n### create database VS create schema\n- mysql\n    - CREATE DATABASE creates a database with the given name. To use this statement, you need the CREATE privilege for the database. \n    - CREATE SCHEMA is a synonym for CREATE DATABASE.\n    -  https://dev.mysql.com/doc/refman/8.0/en/create-database.html\n\n- SQL Server","tags":["SQL"]},{"title":"module之commonjs与ES6及其他","url":"/2021/01/06/module之commonjs与ES6及其他/","content":"\n### 兼容性\n- https://caniuse.com/es6-module\n- 现在看起来还行昂，越来越好了\n\n参考文档：https://www.zhihu.com/question/20351507/answer/14859415\n\nhttp://caibaojian.com/es6/module.html\n\n项目经历：\nnode:commonjs\nforeceipt:amd(requirejs)\n现在项目：es6\n\n### systemjs\n- https://babeljs.io/docs/babel-plugin-transform-modules-systemjs  This plugin is included in @babel/preset-env under the modules option(@vitejs/plugin-legacy -> @babel/preset-env)\n- vite - legacy - systemjs"},{"title":"Vue笔记系列之那些被废除了的API","url":"/2021/01/06/Vue笔记系列之那些被废除了的API/"},{"title":"Vue笔记系列之通信","url":"/2021/01/06/Vue笔记系列之通信/"},{"title":"构建一个本地leetcode刷题or代码逻辑测试环境","url":"/2021/01/06/构建一个本地leetcode刷题or代码逻辑测试环境/"},{"title":"atom使用指北","url":"/2021/01/06/atom使用指北/","content":"\n### apm(Atom Package Manager)\n\n### 快速打开终端\n可以在settings=>intall里面搜索terminal，安装一个合适的，Key bindings设置为自己想要的\n或者cmd+shif+p，调出命令面版，输入terminal，即可调出终端\n"},{"title":"人力资源学习","url":"/2020/12/29/人力资源学习/","content":"### 辅导下属制定绩效改进计划\n\n- 绩效考核+反馈面谈=>认识差距=>改进绩效\n\n- 员工（拟定个人绩效改进计划的草稿）\n- 主管（承诺员工提供资源和帮助）\n  - 讨论达成一致\n\n|缓急程度\\难易程度  |容易改变  |改变不易|\n| :-----:| :----: | :----: |\n|急需改进的|选作第一改进项目|列入长期改进计划，或寻求外部资源支持|\n|较不急于改进的|选作第二改进项目|目前暂缓讨论|\n\n- 改进项目=>期望目标（结果型/驱动型目标）\n  - 目标要符合SMART原则（具体的，可衡量，可达到，相关联，有时限）\n    - 避免概括性描述，关注具体行为；描述的细节程度取决于下属成熟度\n    - 工作中可以观察，评论；数据指标，或行为标准\n    - 在改进周期内，付出努力可以达到；综合考虑所有绩效指标的难度\n    - 符合团队整体的业绩要求；与员工个人的职业发展需求一致\n    - 有明确的考核期限\n\n- 奖惩激励（直接影响员工对改进活动的投入程度）\n  - 未达到目标的后果\n  - 达到甚至超出目标的奖励\n\n1. 强调留用、奖励和重奖的绩效临界点\n2. 设置小的奖惩措施\n   - 表扬，检讨分享会\n   - 团队建设活动\n   - 额外培训机会 \n3. 物理激励和精神激励相结合\n   - 加薪、奖金、奖品、福利\n   - 表扬、奖章、称号、经验宣传 \n\n- 行动方案（步骤）\n  - 知识与技能\n  - 操作方法与工作习惯（步骤）\n  - 检查与反馈节点（了解进度，及时反馈=>强化改进效果，纠正理解或行动偏差，调整行动步骤）\n    - 了解（新知识技能的掌握，新技能，工具，程序的运用）\n    - 反馈（内外部客户的反应）\n    - 评价（绩效差距变化）\n    - 调整（增删或调整改进方法或工具）\n\n- 承诺你能给予的支持保障\n  - 指导和辅导员工\n  - 协调工作与改进计划\n  - 信息更新与互动\n\n- 签名同意（双方对所有内容已完全理解，并达成共识）\n  - 这份计划对员工有帮助？\n  - 疑虑或待解决的问题？\n  - 其他补充说明？\n\n\n\n\n### 如何科学地淘汰低绩效员工\n- 组织中人力资源管理\n- 不处理C类（低绩效，低潜力）员工的原因\n  - 缺少接替人选（权益之计）\n  - 感情包袱（无可厚非）\n  - 缺乏勇气\n  - 缺少认识\n\n- 淘汰C类员工的重要性\n- 不处理C类员工对影响\n  - 对其他人不公平\n  - 对上司不公平\n  - 对下属不公平\n  - 对其本人不公平\n\n- 误区一：忽视坦诚公开的绩效文化\n  - 不坦诚和公开\n- 误区二：固定比例的末位淘汰\n  - 人与人而不是工作标准\n- 误区三：绩效考核机制单一化\n  - 同一个标准来衡量所有人\n  - 多样化的评价标准（通用电器的）\n\n- 原则一：流程要公平透明\n  - 绩效和潜力没有达到岗位的目标和要求\n  - 对事不对人\n  - 与岗位要求做比较\n\n- 原则二：如无改进再淘汰\n  - 了解目标没有达成的原因（对事不对人）\n  - 讨论下一阶段的目标（找出困难和需要）\n  - 是否达成新目标\n- 原则三：淘汰不等于辞退\n  - 不是简单地开除员工\n\n"},{"title":"axios的cancelToken初探","url":"/2020/12/29/axios的cancelToken初探/","content":"\n### axios官方文件源\n官方指南：https://github.com/tc39/proposal-cancelable-promises（但是：This proposal has been withdrawn）\n代码实现\n```\n'use strict';\n\nvar Cancel = require('./Cancel');\n\n/**\n * A `CancelToken` is an object that can be used to request cancellation of an operation.\n *\n * @class\n * @param {Function} executor The executor function.\n */\nfunction CancelToken(executor) {\n  if (typeof executor !== 'function') {\n    throw new TypeError('executor must be a function.');\n  }\n\n  var resolvePromise;\n  this.promise = new Promise(function promiseExecutor(resolve) {\n    resolvePromise = resolve;\n  });\n\n  var token = this;\n  executor(function cancel(message) {\n    if (token.reason) {\n      // Cancellation has already been requested\n      return;\n    }\n\n    token.reason = new Cancel(message);\n    resolvePromise(token.reason);\n  });\n}\n\n/**\n * Throws a `Cancel` if cancellation has been requested.\n */\nCancelToken.prototype.throwIfRequested = function throwIfRequested() {\n  if (this.reason) {\n    throw this.reason;\n  }\n};\n\n/**\n * Returns an object that contains a new `CancelToken` and a function that, when called,\n * cancels the `CancelToken`.\n */\nCancelToken.source = function source() {\n  var cancel;\n  var token = new CancelToken(function executor(c) {\n    cancel = c;\n  });\n  return {\n    token: token,\n    cancel: cancel\n  };\n};\n\nmodule.exports = CancelToken;\n\n```\n\n### XMLHttpRequest\n同步请求：原理是 XMLHttpRequest 这个可以传第三个参数，但是不建议用同步请求，会把 JS 执行线程卡住\n\n\n### Fetch\nAbortController\n> AbortController接口表示一个控制器对象，允许你根据需要中止一个或多个 Web请求。\n\n文档指南：\nhttps://developer.mozilla.org/zh-CN/docs/Web/API/AbortController\n\nredaxios(Axios has a great API that developers love. Redaxios provides that API in 800 bytes, using native fetch().)\n```\n// redaxios(https://github.com/developit/redaxios)中，用AbortController实现的CancelToken\n/**\n\t * @public\n\t * @type {AbortController}\n\t */\n\tredaxios.CancelToken = /** @type {any} */ (typeof AbortController == 'function' ? AbortController : Object);\n\n```\n\n### 同步异步\nrequest拦截器执行的时机，默认放异步队列，加了参数的话，则requestinterceptor同步处理；\n- https://github.com/axios/axios/blob/master/lib/core/Axios.js\n- https://github.com/axios/axios/pull/2702/files\n```\nWhen you add request interceptors, they are presumed to be asynchronous by default. This can cause a delay in the execution of your axios request when the main thread is blocked (a promise is created under the hood for the interceptor and your request gets put on the bottom of the call stack). If your request interceptors are synchronous you can add a flag to the options object that will tell axios to run the code synchronously and avoid any delays in request execution.\n\naxios.interceptors.request.use(function (config) {\n  config.headers.test = 'I am only a header!';\n  return config;\n}, null, { synchronous: true });\nIf you want to execute a particular interceptor based on a runtime check, you can add a runWhen function to the options object. The interceptor will not be executed if and only if the return of runWhen is false. The function will be called with the config object (don't forget that you can bind your own arguments to it as well.) This can be handy when you have an asynchronous request interceptor that only needs to run at certain times.\n\nfunction onGetCall(config) {\n  return config.method === 'get';\n}\naxios.interceptors.request.use(function (config) {\n  config.headers.test = 'special get headers';\n  return config;\n}, null, { runWhen: onGetCall });\n```\n\n#### core\n- cancelToken - config \n- if cancelToken\n- 在 promise 链式调用的 dispatchRequest 抛出错误，在 adapter 中 request.abort() 取消请求，使 promise 走向 rejected，被用户捕获取消信息\n### OPML\nhttps://en.wikipedia.org/wiki/OPML\n\n### source code\n- https://github.com/axios/axios/blob/main/lib/utils.js\n\n\n### XMLHttpRequest 对象\n- https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/readyState\n\n\n//这篇文章非常好\n- https://medium.com/datadriveninvestor/aborting-cancelling-requests-with-fetch-or-axios-db2e93825a36\n- https://mp.weixin.qq.com/s/2ADjfJPge391xpdikM08qQ - 由一个bug引发对axios的刨根问底\n\n\n#### withCredentials\nhttps://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials\n\nThe XMLHttpRequest.withCredentials property is a Boolean that indicates whether or not cross-site Access-Control requests should be made using credentials such as cookies, authorization headers or TLS client certificates. Setting withCredentials has no effect on same-site requests.","tags":["XMLHttpRequest"]},{"title":"SQL学习笔记之基础介绍","url":"/2020/12/22/SQL学习笔记之基础介绍/","content":"\n\n> 1946_ENIAC_Electronic Numerical Integrator And Computer_第一台通用电子计算机\n\n### 引入\n\n- I/O 是DBMS最容易出现瓶颈的地方\n\t- 数据库操作中大量时间花在了I/O 上面\n  - 参考文档：https://docs.oracle.com/cd/B28359_01/server.111/b28274/iodesign.htm#PFGRF015\n- 降低CPU的计算量\n\t- 在SQL语句中使用GROUP BY ，ORDER BY 等语句会消耗大量CPU计算资源\n  - 参考文档：https://use-the-index-luke.com/sql/sorting-grouping\n- 内存使用情况\n\n\n- EXISTS  / IN  查询\n\n```\nSELECT * FROM A WHERE cc IN (SELECT cc FROM B)\nSELECT * FROM A WHERE EXISTS IN (SELECT cc FROM B WHERE B.cc=A.cc)\n```\n\n- 有索引\n\t- 表A比表B大，IN子查询的效率比EXISTS子查询效率高\n\n\n比如最大生命值大于 7000 的法师英雄都有谁，那么你会怎么做呢？\n```\nSELECT * FROM heros WHERE hp_max >= 7000 AND role = '法师'\n```\n\n\n 7 天内的新增用户数有多少，该怎么做呢？\n\n```\nSELECT COUNT(*) as num FROM new_user WHERE TO_DAYS(NOW())-TO_DAYS(regist_time)<=7\n```\n\n- 基于数据的各种技术中也会用到 SQL\n\t- OLTP（联机事务处理过程）\n\t- OLAP（联机分析处理过程）\n\t- RDBMS（对象关系型数据库管理系统）\n\t- 在 NoSQL 的阵营上，如今也在使用类似 SQL 的操作，要知道，提出 NoSQL 这个概念的初衷就是远离 SQL，但如今人们更愿意把 NoSQL 定义为 Not Only SQL（不只是 SQL）\n\t- 在 XML、JSON 等数据格式中，都存在着各种 SQL，比如用于 XML 的 SQL、用于 JSON 的 SQL 等\n\t- 用于记录地理位置信息的 SQL、用于搜索的 SQL、用于时间序列数据的 SQL、用于流的 SQL 等\n\n\n### SQL\n- TIPS\n\t- TIOBE(https://www.tiobe.com/tiobe-index/)\n\n\n- 历史\n\t- https://zh.wikipedia.org/wiki/SQL\n\t- 在1970年代初，由IBM公司San Jose,California研究实验室的埃德加·科德发表将资料组成表格的应用原则（Codd's Relational Algebra）。\n\t- 1974年，同一实验室的D.D.Chamberlin和R.F. Boyce对Codd's Relational Algebra在研制关系数据库管理系统System R中，研制出一套规范语言-SEQUEL（Structured English Query Language），并在1976年11月的IBM Journal of R&D上公布新版本的SQL（叫SEQUEL/2）。\n\t- 1980年改名为SQL。\n\t- 目前，所有主要的关系数据库管理系统支持某些形式的SQL，大部分数据库至少遵守ANSI SQL89标准。\n\t- ANSI SQL92标准在交叉连接（cross join）和内部连接之上，新增加了外部连接，并支持在FROM子句中写连接表达式。支持集合的并运算、交运算。支持Case (SQL)表达式。支持CHECK约束。创建临时表。支持cursor。支持事务隔离。\n\t- SQL99\n\n\n- 按功能划分（语句分类）\n\t- DDL\n\t\t- Data Definition Language\n\t\t- 数据定义\n\t\t- 定义数据库对象\n\t\t\t- 数据库\n\t\t\t- 数据表和列\n\t\t- 我们可以创建，修改和删除数据库和表的结构\n\t- DML\n\t\t- Data Manipulation Language\n\t\t- 数据操控\n\t\t- 操作和数据库相关的记录\n\t\t- 增，删，改数据表中的记录\n\t\t- INSERT UPDATE DELETE\n\t- DCL\n\t\t- Data Control Language\n\t\t- 定义访问权限和安全级别\n\t- DQL\n\t\t- Data Query Language\n\t\t- 数据查询\n\t\t- SELECT\n\n\n- 声明性语言\n\t- 不需要制定具体的执行步骤\n- SQL语言定义了我们的需求\n- 不同的DBMS会按照指定的SQL帮我们提取想要的结果\n\n- RDBMS\n\t- 实体关系模型（Entity-Relationship Model），简称E-R Model，是陈品山（Peter P.S Chen）博士于1976年提出的一套数据库的设计工具，他运用真实世界中事物与关系的观念，来解释数据库中的抽象的资料架构。实体关系模型利用图形的方式（实体-关系图（Entity-Relationship Diagram））来表示数据库的概念设计，有助于设计过程中的构思及沟通讨论。\n\n\t- 设计—— ER图（Entity Relationship Diagram）实体——关系图\n\t\t- 用来描述现实世界的概念模型\n\t\t- 要素：实体——要管理的对象，属性——标识每个实体的属性，关系——对象之间的关系\n\n\t- ER图评审通过，用SQL语句或者可视化管理工具创建数据表-\n\n- SQL大小写\n\t- 表名，表别名，字段名，字段别名——小写\n\t- SQL保留字，函数名，绑定变量——大写\n- 数据表的字段名——下划线命名\n\n\n### 数据库管理系统\n- DBS\n  - DataBase System，数据库系统\n\t- 包括数据库、数据库管理系统以及数据库管理人员 DBA\n\n- DBMS\n\t- DataBase Management System，数据库管理系统\n\t- 实际上它可以对多个数据库进行管理， DBMS = 多个数据库（DB） + 管理程序\n\n- 排名\n\t- https://db-engines.com/en/\n  - https://db-engines.com/en/ranking\n\n\n- NoSQL泛指非关系型数据库——\n\t- 键值型数据库\n\t\t- key-value的方式来存储数据\n\t\t- key:唯一标识符\n\t\t- 查找速度快，但无法自由的使用条件过滤\n\t\t- 使用场景——作为内容缓存\n\t\t- 例如：redis\n\t- 文档型数据库\n\t\t- 文档作为处理信息的基本单位\n\t\t- 一个文档相当于一条记录\n\t\t- 例如：mongoDB\n\t- 搜索引擎\n\t\t- 全文索引，核心原理是“倒排索引”\n\t\t- 例如：Elasticsearch,Splunk,Solr\n\t- 列式数据库\n\t\t- 相对于行式（Row-based:Oracle，MySQL，SQL Server）\n\t\t- 大量降低系统IO\n\t\t- 适合分布式文件系统\n\t\t- 不足在于功能相对有限\n\t- 图形数据库\n\t\t- 用图存储实体之间的关系\n\t\t- 数据模型以节点和边（关系）来实现\n\t\t- 能高效的解决负责的关系问题\n\n\n- Oracle\n\t- 第一个商用RDBMS\n- MySQL\n\t- 1995\n\t- 开源数据库管理系统\n\t- 2008，被SUN收购，2010，SUN被Oracle收购\n\t- MariaDB\n- SQL Server\n\t- 微软，1989\n\t- 微软还有Access（2G）—— 轻量级桌面数据库\n\n\n> NoSQL最早是想远离SQL，随着发展，越来越离不开SQL; NoSQL是对SQL很好的补充\n\n\n### 参考学习项目\n- mybatis-3\n  - MyBatis SQL mapper framework for Java —— mybatis.github.io/mybatis-3/\n\t- 数据持久化\n\t- https://github.com/mybatis/mybatis-3\n- MyBatis-Plus是一个对MyBatis的增强工具，在MyBatis的基础上只做增强，不做改变，为简化开发、提高效率而生。\n- https://github.com/baomidou/mybatis-plus\n1. 自动化SQL语句处理：它提供了一些增删查改的通用方法，能够自动构造SQL语句，对常见的增删查改操作能节省大量的编码工作，简化代码。\n2. 条件构造器：简化了复杂条件查询，提供了丰富的表达式，满足大部分的查询需求。\n3. 支持ActiveRecord模式：ActiveRecord是一种Active Record模式，它将数据库记录映射为对象，这是一种领域模型模式，行为和数据被封装在对象中。  \n4. 完全兼容MyBatis：和MyBatis无缝结合，可以灵活读写分离等等。\n5. 支持自定义全局通用操作：插入、修改、删除及查询，提供全局通用方法做基础操作，提供通用接口Iselect为非通用系操作。\n  ","tags":["sql"]},{"title":"工作中遇到的babel","url":"/2020/11/28/工作中遇到的babel/","content":"\n### why && what \n- babel是JavaScript编译器\n- 解决代码对旧版本的兼容性问题\n\n### 初始化项目\n- @vue/cli 的话，可以直接走```@vue/cli-plugin-babel```\n- 没用脚手架构建工具的话： @babel/core - 核心库 @babel/cli - 命令行工具 @babel/preset-env - 默认的预设环境 | devDependencies\n- core-js - dependencies - 在运行时为老版本的浏览器提供不支持的API\n\n### .babelrc\n- \n\n\n### \n### 官方文档\nhttps://babeljs.io/\n### 场景：\n1. babel的升级—— 那么前提就要了解版本之间的核心差异，可以通过官方发布的blog，对整体概况有一个了解\n2. 开发babel插件\n\n### babel 7.0 的更新\nhttps://babeljs.io/blog/2018/08/27/7.0.0\nBabel 7.0 版本的重大变更包括：\n- 支持 TypeScript 和 JSX Fragment；\n- 不再支持没有维护的 Node 版本（0.10、0.12、4、5）；\n- 使用 @babel 命名空间（babel-core 变成了 @babel/core）；\n- 移除并停止发布任何年度预设（preset-es2015 等）;\n- 移除“Stage” 预设（@babel/preset-stage-0 等）；\n- 重命名了某些包（任何 TC39 提议插件现在都是 -proposal 而不是 -transform）。\n\n\n## 开发babel插件\n### 原理\n#### 解析阶段\n- 词法分析（tokens）\n- 语法分析（AST）\n#### 转换阶段\n- 访问者模式\n- 深度优先遍历\n- path\n#### 生成阶段\n\n\n\n## cases\n### vue2.x的项目\n- 要使用 ```<script setup>``` 的语法，所以引用了插件 \n- https://github.com/antfu/unplugin-vue2-script-setup.git\n- https://github.com/antfu/unplugin-vue2-script-setup/blob/main/src/core/transformScriptSetup.ts\n- 处理script setup语法支持的时候\n```\nimport generate from '@babel/generator'\nreturn {\n    ast,\n    code: generate(ast).code,\n  }\n\n```\n\n### shippedproposal\nhttps://github.com/vitejs/vite/commit/ed25817\nhttps://tc39.es/ecma262/#sec-array.prototype.at\nhttps://tc39.es/ecma262/2021/\nhttps://tc39.es/ecma262/2022/\n\n### compat-table\nhttps://kangax.github.io/compat-table/es2016plus/\n\n\n### Presets\n@babel/preset-env\n\n基本上可以看到各个版本的新增特性和用法\nhttps://babeljs.io/docs/babel-plugin-transform-async-to-generator\n\n## 其他\n- https://babeljs.io/blog/2021/05/10/funding-update\n- https://babeljs.io/blog/2023/10/16/cve-2023-45133"},{"title":"webpack-development","url":"/2020/11/19/webpack-development/","content":"#### webpack-dev-server\nwebpack-dev-server是一个小型的Node.js Express服务器,它使用webpack-dev-middleware来服务于webpack的包,除此自外，它还有一个通过Sock.js来连接到服务器的微型运行时.\n\nsock.js(https://github.com/sockjs/sockjs-client):\n\n\n\n### alias\n\n\n\n\n### sass-loader\nhttps://github.com/webpack-contrib/sass-loader#imports \n<pre>\nUsing ~ is deprecated and can be removed from your code (we recommend it), but we still support it for historical reasons. Why you can remove it? The loader will first try to resolve @import as relative, if it cannot be resolved, the loader will try to resolve @import inside node_modules. Just prepend them with a ~ which tells webpack to look up the modules.\n\n@import \"~bootstrap\";\nIt's important to only prepend it with ~, because ~/ resolves to the home directory. Webpack needs to distinguish between bootstrap and ~bootstrap because CSS and Sass files have no special syntax for importing relative files. Writing @import \"style.scss\" is the same as @import \"./style.scss\";\n\n\n</pre>\n\n旧的版本，如果不加 ～\nModule build failed (from ./node_modules/sass-loader/lib/loader.js):\n\nundefined\n ^\n      File to import not found or unreadable: @/views/plan/publish/publish.scss.\n\nissues:\nhttps://github.com/teambit/bit/issues/1103\n\n<pre>\nwebpack provides an advanced mechanism to resolve files. The sass-loader uses Sass's custom importer feature to pass all queries to the webpack resolving engine. Thus you can import your Sass modules from node_modules. Just prepend them with a ~ to tell webpack that this is not a relative import:\n\n@import \"~bootstrap/dist/css/bootstrap\";\nIt's important to only prepend it with ~, because ~/ resolves to the home directory. webpack needs to distinguish between bootstrap and ~bootstrap because CSS and Sass files have no special syntax for importing relative files. Writing @import \"file\" is the same as @import \"./file\";\n\n</pre>\n\n### HardSourceWebpackPlugin\n4里面可以用来优化\n5里面直接放进去了\n\n现有问题：\nhttps://github.com/mzgoddard/hard-source-webpack-plugin/issues/416\n\n\n### 构建性能优化\n#### official - doc\n- https://webpack.docschina.org/guides/build-performance/\n\n> 将 Node.js 更新到最新版本，也有助于提高性能。除此之外，将你的 package 管理工具（例如 npm 或者 yarn）更新到最新版本，也有助于提高性能。较新的版本能够建立更高效的模块树以及提高解析速度。 - doc\n- loader | bootstrap | 解析 ｜ dll | smaller = faster | worker pool | 持久化缓存 ｜ 自定义的plugin和loader分析\n\n#### Warning\n- worker 池(worker pool) \n- thread-loader 可以将非常消耗资源的 loader 分流给一个 worker pool。\n\n- 不要使用太多的 worker，因为 Node.js 的 runtime 和 loader 都有启动开销。最小化 worker 和 main process(主进程) 之间的模块传输。进程间通讯(IPC, inter process communication)是非常消耗资源的。需要谨慎使用～\n\n#### 通用 ｜ 开发 ｜生产\n- 不同环境的优化\n\n#### reference\n- http://webpack.wuhaolin.cn/4%E4%BC%98%E5%8C%96/\n### chokidar\n- https://www.npmjs.com/package/chokidar\n- Minimal and efficient cross-platform file watching library\n- webpack-dev-server 的依赖\n- 比如说这个博客，基于hexo,hexo-fs也依赖chokidar\n- chokidar中有个依赖-fsevents\n\n### webpack-cli\n#### 命令行工具cli\n- 可以在处理node时候，模块这部分，命令行编译\n- npx webpack [command] [options]\n- 可以免安装\n- 注意webpack版本和对应的用法\n- ```npx webpack --no-devtool --mode development --target node14.5```\n\n\n## build process - JavaScript Bundler\n#### Rollup\n- https://github.com/rollup/rollup\n- https://rollupjs.org/guide/en/#tools - 和其他工具的集成\n#### microbundle\n#### snowpack\n#### Parcel\n- 简单好用\n\n\n## source\n- https://docs.google.com/presentation/d/1hFtMCMo62DgOIc-9OwgaVwPZHwv1cgMELArHcMbXlSI\n- https://github.com/thelarkinn/webpack-workshop-2018\n\n## create-react-app\n### after eject\n#### lint\n```\nParsing error: [BABEL] /Users/kuangyimin/Documents/公司/新东方/进行项目/yy/react-playground/scripts/build.js: Using `babel-preset-react-app` requires that you specify `NODE_ENV` or `BABEL_ENV` environment variables. Valid values are \"development\", \"test\", and \"production\". Instead, received: undefined.\n\n所以需要指定下\nNODE_ENV=development BABEL_ENV=development eslint . --ext .js,.jsx,.ts,.tsx src\n```\n\n\n#### test\n    \"test\": \"node scripts/test.js\",\n- 注意node版本\n```\n因为test的原因，node版本需要大于14.17.0\n不然\n```\n import { PatternPrompt, printPatternCaret, printRestoredPatternCaret } from 'jest-watcher';\n                            ^^^^^^^^^^^^^^^^^\n    SyntaxError: Named export 'printPatternCaret' not found. The requested module 'jest-watcher' is a CommonJS module, which may not support all module.exports as named exports.\n    CommonJS modules can always be imported via the default export, for example using:\n\n    import pkg from 'jest-watcher';\n    const { PatternPrompt, printPatternCaret, printRestoredPatternCaret } = pkg;\n```\n- https://github.com/facebook/create-react-app/issues/11792\n\n```\n#### less\n- github.com/DocSpring/craco-less\n\n\n#### better-scripts\n```\nExecuting script: build_diy\n\nto be executed: react-app-rewired build \nfalse process.argv.includes('--analyze')\n当前环境为生产环境\nCreating an optimized production build...\n\n  `@babel/polyfill` is deprecated. Please, use required parts of `core-js`\n  and `regenerator-runtime/runtime` separately\n\nTreating warnings as errors because process.env.CI = true.\nMost CI servers set it automatically.\n\nFailed to compile.\n\nsrc/component-diy/layout/index.js\n  Line 9:1:  `@/component/QuestionTools` import should occur after import of `api/ajax-project`  import/order\n\nsrc/component/QuestionTools/components/SingleQuestion/index.js\n  Line 213:8:  JSX props should not use functions  react/jsx-no-bind\n  Line 231:8:  JSX props should not use functions  react/jsx-no-bind\n\nsrc/component/QuestionTypes/GapFillingQuestion/index.js\n  Line 87:5:  JSX props should not use functions  react/jsx-no-bind\n  Line 97:6:  JSX props should not use functions  react/jsx-no-bind\n\n\nnpm ERR! code ELIFECYCLE\nnpm ERR! errno 1\nnpm ERR! seal_react_backend_new@0.1.0 build:diy: `better-npm-run build_diy`\nnpm ERR! Exit status 1\nnpm ERR! \nnpm ERR! Failed at the seal_react_backend_new@0.1.0 build:diy script.\nnpm ERR! This is probably not a problem with npm. There is likely additional logging output above.\n```\n```\n\"build_prod\": {\n      \"command\": \"CI=false&&react-app-rewired build\",\n      \"env\": {\n        \"REACT_APP_BUILD_TYPE\": \"online\"\n      }\n    },\n```\nCI设置为false，避免把warning当成error处理，导致构建直接退出\n\n#### lint需要再配置\n\n#### mini-css-extract-plugin Conflicting order\n- 分离并打包CSS到单独文件\n- https://github.com/webpack-contrib/mini-css-extract-plugin/issues/250\n- https://stackoverflow.com/questions/51971857/mini-css-extract-plugin-warning-in-chunk-chunkname-mini-css-extract-plugin-con/67579319#67579319\n\n## 基础\n\n### history\n- Webpack 1.0.0：2014年2月\n  - 此版本是Webpack的首个稳定版本，主要功能是模块打包和资源管理。\n\n- Webpack 2.2.0：2017年1月17日\n  - 新增了对ES6模块处理的支持，即\timport 和 export语法。\n  - 引入了Tree shaking技术，可以实现去除无用代码。\n  - 新增了动态导入功能，即 import()语法。\n\n- Webpack 3.0.0：2017年6月19日\n  - 具有作用域提升(Scope Hoisting)功能，可以使代码在浏览器端运行更快。\n  - 提供了新的插件系统。\n\n- Webpack 4.0.0：2018年2月26日\n  - 新增了Mode选项，取代了--optimize-*选项。\n  - 废除了CommonsChunkPlugin，新添加了optimization.splitChunks和optimization.runtimeChunk选项。\n  - 在编译时，可以将 import 和 export 语句转换为 ES5 代码，支持更多的设备和环境。\n\n- Webpack 5.0.0：2020年10月10日\n  - 默认支持持久缓存，提升了构建性能。\n  - 自动生成文件名，用于长期缓存。\n  - 新增了对模块联邦（Module Federation）的支持，可以实现多个构建共享模块。\n  - 提高了算法和默认配置以减少捆绑包的大小。\n\n### dif\nWebpack中的插件（Plugins）和加载器（Loaders）都是Webpack的扩展方式，它们在处理项目时起着不同的作用。这两者的主要区别如下：\n\n1. 负责的工作内容不同：\nLoader：它是一个转换器，将A文件进行编译形成B文件，这里操作的是文件，比如将A.scss或A.less转化为A.css，单纯的文件转换过程。\nPlugin：它是一个扩展器，它丰富了webpack本身，针对的是loader结束后，webpack打包的整个过程，它并不直接操作文件，而是基于事件机制工作，会监听webpack打包过程中的某些节点。\n\n2. 使用方式不同：\nLoader：在module.rules中配置，作为模块的规则存在，类似于一种解析器。\nPlugin：在plugins中单独配置，作为插件的存在，用来扩展Webpack的功能。\n\n3. 作用的文件不同：\nLoader：在导入某个文件的时候，预处理文件。\nPlugin：处理的是整个构建过程。\n\n总的来说，Loader 主要用于转换文件内容，而 Plugin 则可以用于执行范围更广的任务。Loaders 是在文件加载时使用，Plugins 更多的是在打包优化和缩小以及重新定义环境中的词等操作。\n","tags":["webpack"]},{"title":"从toFixed看编译过程","url":"/2020/11/16/从toFixed看编译过程/","content":"\n- https://262.ecma-international.org/10.0/#sec-terms-and-definitions-null-type\n- https://2ality.com/2013/10/typeof-null.html\n- https://en.wikipedia.org/wiki/Double-precision_floating-point_format\n- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness\n- https://dorey.github.io/JavaScript-Equality-Table/\n- https://gist.github.com/gaearon/08a85a33e3d08f3f2ca25fb17bd9d638\n\nMDN文档指路：https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed\n规范指路：https://tc39.es/ecma262/#sec-number.prototype.tofixed\n\nNumber.prototype.toFixed()\nThe toFixed() method formats a number using fixed-point notation.\n// toFixed() 方法使用定点表示法来格式化一个数值。\n\n```\nvar numObj = 12345.6789;\n\nnumObj.toFixed();         // 返回 \"12346\"：进行四舍六入五看情况，不包括小数部分\nnumObj.toFixed(1);        // 返回 \"12345.7\"：进行四舍六入五看情况\n\nnumObj.toFixed(6);        // 返回 \"12345.678900\"：用0填充\n\n(1.23e+20).toFixed(2);    // 返回 \"123000000000000000000.00\"\n\n(1.23e-10).toFixed(2);    // 返回 \"0.00\"\n\n2.34.toFixed(1);          // 返回 \"2.3\"\n\n2.35.toFixed(1)           // 返回 '2.4'. Note it rounds up\n\n2.55.toFixed(1)           // 返回 '2.5'. Note it rounds down - see warning above\n\n-2.34.toFixed(1);         // 返回 -2.3 （由于操作符优先级，负数不会返回字符串）\n\n(-2.34).toFixed(1);       // 返回 \"-2.3\" （若用括号提高优先级，则返回字符串）\n\n1.toFixed();              // 返回VM81:1 Uncaught SyntaxError: Invalid or unexpected token\n\n```\n<pre>\nExceptions\nRangeError\nIf digits is too small or too large. Values between 0 and 100, inclusive, will not cause a RangeError. Implementations are allowed to support larger and smaller values as chosen.\nTypeError\nIf this method is invoked on an object that is not a Number.\n</pre>\n\n我们可以看到```1.toFixed();```报的是SyntaxError\n\n```\n1..toFixed()\n\nlet num = 1;\nnum.toFixed();\n\n(1).toFixed();\n```\n改成上面三种形式皆可\n\n\n### V8如何处理toFixed的呢\n```\n2.55 - 2.5\n// 0.04999999999999982\n```\n\nhttps://www.jianshu.com/p/361afb9c4d59\n"},{"title":"TypeScript在Slack之文章阅读笔记","url":"/2020/11/16/TypeScript在Slack之文章阅读笔记/","content":"\n### 文章指路\nhttps://slack.engineering/typescript-at-slack/\n\n> 英文还OK的可以直接阅读（没啥阅读难度），需要辅助翻译的可以安装个chrome插件（Google 翻译），打开阅读页面后，选择“翻译此页面”; OR DeepL;\n\n#### 读这篇文章前的几个问题：\n- 问什么要在团队推typescript\n- 什么样的项目收益更多（trade-on）\n\n### demos\n- https://github.com/PacktPublishing/Advanced-TypeScript-3-Programming-Projects\n```\n We will do web development projects briefly on simple vanilla typescript to get the ball rolling, then a full stack project with node.js, a project with TypeScript, A CRM application with React and microservices, a cloud-based map application with Angular and Firebase. In the end, we will build an image recognition application with TensorFlow. \n```","tags":["TypeScript","Electron"]},{"title":"elk","url":"/2020/11/11/elk/","content":"## kibana query-string-Syntax\n### doc\n- 过滤器语法基于Lucene\n- elastic文档\n- https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-query-string-query.html#query-string-syntax\n- lucene语法\n- https://lucene.apache.org/core/6_6_0/queryparser/org/apache/lucene/queryparser/classic/package-summary.html\n- 引导demo\n- https://demo.elastic.co/cookie/index.html#/discover\n\n## filebeat配置\n\n- https://github.com/elastic/beats - The Beats are lightweight data shippers, written in Go\n- logstash-forwarder - THIS PROJECT IS REPLACED BY FILEBEAT(6年前，Commits on Nov 13, 2015)\n- filebeat - https://www.elastic.co/guide/en/beats/filebeat/current/index.html\n- https://www.elastic.co/guide/en/beats/filebeat/current/filebeat-overview.html\n\n### 问题\n- 日志不活跃，filebeat关闭连接\n- filebeat配置有问题，导致收集路径错了，修改配置，重启下，索引创建，就能看到日志了\n\n## LogStash\n- https://github.com/elastic/logstash\n- Logstash is part of the Elastic Stack along with Beats, Elasticsearch and Kibana. Logstash is a server-side data processing pipeline that ingests data from a multitude of sources simultaneously, transforms it, and then sends it to your favorite \"stash.\" (Ours is Elasticsearch, naturally.). Logstash has over 200 plugins, and you can write your own very easily as well.\n\n#### 配置\n\n\n## CKafka\n- https://cloud.tencent.com/document/product/597/32743\n\n## keyword\nhttps://www.elastic.co/guide/en/elasticsearch/reference/6.7/query-dsl-query-string-query.html#query-dsl-query-string-query\n\ndevtools\nGET xxx/_mapping\n可以看keyword抓取的字符数限制\n\n## 聚合搜索\n- inspect 查看搜索具体语句\n- dev-tools 粘贴刚刚的语句，进行aggs的修改\n```\n\"size\": 0,\n  \"aggs\": {\n    \"orders_by_ip\": {\n      \"terms\": {\n        \"field\": \"client_ip.keyword\"\n      }\n    }\n  },\n```\n-- 或者可以用visualize , 选择已保存的语句，buckets里面add aggs"},{"title":"工作阶段整理","url":"/2020/11/10/工作阶段整理/","content":"Apart：\n\n逻辑的复杂 => 用户使用的复杂 + 运维的复杂\n\n业务（简单 -> 复杂）（技术跟不上业务的变化）\n\n架构升级 （对业务的再建模）\n\n业务好用\n架构简单\n\nor else 用户也会得到复杂的东西\n\n\nBpart：\n\n另起炉灶\n\nadapter稳住 + 外科手术（分步）\n\nmagical + （工程基础：vue-lib,template, lib(core_sdk + basics_ui) + service（topic + pdf_template））\n我还是不知道你要什么，我自己分层，抽能力，抽核心，基础建设+基础碎片=>业务需求组合\n\n\n\nCpart:\n\n自建 + 服务购入（快速构建，服务带来限制）\n\n通用问题的解决，和现有体系的打通\n\nedas对比图表(https://www.aliyun.com/product/edas?spm=5176.13910061.746114.1.5b51295eWIu9uZ)\n\n\n\nDpart:\n\n业务，产品，技术\n\n目标，考核指标，后续迭代的评价规则\n\n## Cases\n\n### 登录和权限一定要理清楚\n- 看了下别的团队的一个复盘，描述了问题，但是不彻底\n- 我们都会接入XX统一登录中心，进行验证，是否有XX身份的权限\n- A团队的问题是，对于子系统的权限，和是否具有XX身份的权限处理不明确，从而导致了再统一登录页面陷入了逻辑循环\n- Chrome浏览器和非Chrome浏览器等会有各个因为安全的配置，不同的版本，导致的对cookie的处理的不同差异，做有关后台写入cookie的问题的时候，一定要注意到这点\n\n### 针对浏览器兼容性的问题\n\n- 定位要准确\n- 做好运营（landing）页面，浏览器的下载引导\n- 系统拉横幅，针对兼容性差的IE等收集来的信息，直接进行判断，显示下载提示和按钮\n- 做好前端行为的上报，这样可以在服务端接口没有trace的时候，通过手机号，时间等信息，trace到用户的设备\n\n### infoq\n- https://gmtc.infoq.cn/2018/beijing/schedule","tags":["朋友"]},{"title":"谈谈文档和日常工作规划","url":"/2020/11/10/谈谈文档和日常工作规划/","content":"> 念书时候，风格比较严谨，工作以后被我老大带的比较自由随意派，后来又拧了回去\n\n认识了大佬们后，工作规划和文档上面学到了不少：\n- 有个朋友的文档像论文，优点就是结构很清晰=>对我的影响就是，技术调研这种我基本上就按朋友的论文的型来了；\n\n- 工作规划会有短期的规划-明确的时间节点和内容+长期的目标；树形节点，checklist形式；\n    - 笔记工具：notability\n    - 工作在线文档：语雀\n    - 阅读：单位购买的极客时间（当搜索工具用，看看别人在处理问题时候是怎么想的）；kindle（值得读的好书，也当作搜索工具）；dash(切换语言写代码时候的工具)\n\n"},{"title":"DSL","url":"/2020/11/10/DSL/","content":"\n比对，写一个编译器\n\n规定录入是一种新的语言\nDSL\n简单的\n\n我们可以编译成现有的，可识别的\n\n- https://juejin.cn/post/6844904068117168142#heading-15\n- 前端DSL实践指南"},{"title":"edas","url":"/2020/10/28/edas/","content":"> 问朋友干啥呢，edas升级呢（统一阿里云）\n> 问我们这边架构师，开源自建呢（我们统一腾讯云）\n\nedas(https://www.aliyun.com/product/edas?spm=5176.13910061.746114.1.5b51295eWIu9uZ)\n阿里云服务\n\n企业级分布式应用服务 EDAS（Enterprise Distributed Application Service）是一个应用托管和微服务管理的 PaaS 平台，提供应用开发、部署、监控、运维等全栈式解决方案，同时支持 Spring Cloud、Apache Dubbo（以下简称 Dubbo ）等微服务运行环境，助力您的各类应用轻松上云。\n","tags":["朋友","服务端"]},{"title":"github之awesome","url":"/2020/10/25/github之awesome/","content":"> 依旧朋友，pphub我给重新下载回来了，刷微博换成了刷topic\n\nhttps://github.com/topics/awesome\n\n\n\nhttps://github.com/github/gitignore\n\n\n\n\nhttp://blog.marcnuri.com/field-injection-is-not-recommended/\n","tags":["朋友"]},{"title":"谈一谈package-json文件","url":"/2020/10/22/谈一谈package-json文件/","content":"\n> 官方文档指南：https://docs.npmjs.com/files/package.json\n\n### version \n- semver - 见```软件版本```博文\n### main 属性\n- 项目入口 （被import｜require，默认入口main指定）\n- 如果不填的话，默认是找文件夹根目录下的index\n<pre>\nThe main field is a module ID that is the primary entry point to your program. That is, if your package is named foo, and a user installs it, and then does require(\"foo\"), then your main module’s exports object will be returned.\n\nThis should be a module ID relative to the root of your package folder.\n\nFor most modules, it makes the most sense to have a main script and often not much else.\n</pre>\n- 一般用于对外提供调用功能的API入口\n\n### scripts\n- 带有命令行的node模块，不需要全局安装，scripts中定义的脚本根据node_modules找到对应模块并启动脚本指令\n\n### keywords | author | license\n### TIPS\n#### 中文字符\n- Package.json 里面不要出现中文，不然会出现解析错误\n-项目标题不要大写字母，要全小写\n\n\n### json\n- https://www.json.org/json-zh.html\n```\nA value can be a string in double quotes, or a number, or true or false or null, or an object or an array. These structures can be nested.\n```\n- 注意double quotes,双引号\n\n### -lock文件\n如果没有强制配 --registry，registry会走lock文件里面的，即使强制配置了--registry还是会走lock\n我这边会ignore -lock文件\n```\nnpm WARN old lockfile \nnpm WARN old lockfile The package-lock.json file was created with an old version of npm,\nnpm WARN old lockfile so supplemental metadata must be fetched from the registry.\nnpm WARN old lockfile \nnpm WARN old lockfile This is a one-time fix-up, please be patient...\nnpm WARN old lockfile \n```\n切换了node版本后，lockfile也会被重写\n\n```\nnpm ERR! code ERESOLVE\nnpm ERR! ERESOLVE unable to resolve dependency tree\nnpm ERR! \nnpm ERR! While resolving: xxx\nnpm ERR! Found: react@17.0.2\nnpm ERR! node_modules/react\nnpm ERR!   react@\"^17.0.1\" from the root project\nnpm ERR! \nnpm ERR! Could not resolve dependency:\nnpm ERR! peer react@\"^0.14.0 || ^15.0.0 || ^16.0.0-0\" from react-html-parser@2.0.2\nnpm ERR! node_modules/react-html-parser\nnpm ERR!   react-html-parser@\"^2.0.2\" from the root project\nnpm ERR! \nnpm ERR! Fix the upstream dependency conflict, or retry\nnpm ERR! this command with --force, or --legacy-peer-deps\nnpm ERR! to accept an incorrect (and potentially broken) dependency resolution.\n```\n这个是因为node版本切换高了\n```\n> ttf2woff2@3.0.0 install /home/xxx/Documents/xxx/current/seal_pdf_server/node_modules/ttf2woff2\n> ((node-gyp configure && node-gyp build) > builderror.log) || (exit 0)\n\nmake: g++: No such file or directory\nmake: *** [addon.target.mk:137: Release/obj.target/addon/csrc/addon.o] Error 127\ngyp ERR! build error \ngyp ERR! stack Error: `make` failed with exit code: 2\ngyp ERR! stack     at ChildProcess.onExit (/home/xxx/.nvm/versions/node/v14.20.0/lib/node_modules/npm/node_modules/node-gyp/lib/build.js:194:23)\ngyp ERR! stack     at ChildProcess.emit (events.js:400:28)\ngyp ERR! stack     at Process.ChildProcess._handle.onexit (internal/child_process.js:285:12)\ngyp ERR! System Linux 5.18.11-200.fc36.x86_64\ngyp ERR! command \"/home/xxx/.nvm/versions/node/v14.20.0/bin/node\" \"/home/xxx/.nvm/versions/node/v14.20.0/lib/node_modules/npm/node_modules/node-gyp/bin/node-gyp.js\" \"build\"\ngyp ERR! cwd /home/xxx/Documents/xxx/current/seal_pdf_server/node_modules/ttf2woff2\ngyp ERR! node -v v14.20.0\ngyp ERR! node-gyp -v v5.1.0\ngyp ERR! not ok\n```\n用的之前的lockfile,报了这个错误；删除之前lockfile之后依然还是有这个错误\n- This is a NodeJS wrapper for the Google WOFF2 project. If the C++ wrapper compilation fail, it fallbacks to an Emscripten build.\n- https://insertafter.com/en/blog/native-node-module.html\n```\nGracefully fail compilation\nSo, now we have our Emscripten build, let's fallback to him when the native NodeJS add-on compilation goes wrong. First, we must ensure that any failure won't impeach the module to install. We're basically doing this by overriding the default installation script to exit with a 0 code whatever result the compiler gives.\n\nThen, as a main JavaScript file we will ensure failing to bind to the native add-on will result in requiring the Emscripten fallback. It is simply done by catching exceptions when requiring the bindings.\n```\n- 这样就确保任何失败都不会影响模块的安装 - 通过覆盖默认的安装脚本来做到这一点，无论编译器给出什么结果，都以0代码退出\n- 然后，绑定时通过捕捉异常回退到Emscripten\n\n\n### files\n- 如果不写的话，所有文件都会被打包进去\n- 写的话，就是当我们的包作为依赖包被安装时候，被包括的条目\n\n\n### lock\n`package-lock.json` 文件是在 Node.js 项目中使用 npm 包管理器时自动生成的。 它记录了关于项目依赖项（如名称、版本、来源等信息）的确切版本。`lockfileVersion` 是表示锁定文件版本的属性。\n\n每个 `lockfileVersion` 版本都对应一个 npm 版本。 在 `lockfileVersion` 不同之间，主要区别在于文件和解析方式的细微差别\n\n1. `lockfileVersion: 1`\n   - 对应于 npm v5 和 v6。\n   - 此版本的主要目标是确保具有兼容性，使那些正在使用较旧版本的用户不受升级项目依赖版本和生成新锁定文件影响。\n   - 使用此版本时，项目依赖性树在 `package-lock.json` 中以层次结构表示。\n\n2. `lockfileVersion: 2`\n   - 对应于 npm v7 之后的版本。\n   - 包含新的项目依赖关系解析算法。\n   - 包含对 `workspaces` 的支持。\n   - 使用此版本时，项目依赖性树使用扁平列表表示，而不是层次结构。 这使得锁定文件更紧凑，并有助于减小文件大小。\n\n除了 `lockfileVersion`，`package-lock.json` 中还包括以下属性：\n\n- `name` 和 `version`：补充 `package.json` 中项目名称和版本的信息。\n- `requires`：到处都是，作为所有依赖。 这些依赖在 `dependencies` 下的该依赖对象中。\n- `dependencies`：项目的所有第三方依赖，包括直接和间接依赖。 每个依赖包含名称、版本、来源等信息。 还可以包括指向子依赖项的 `requires` 和 `dependencies`。\n\n维护 `package-lock.json` 文件的最佳实践是将它包含在您的版本控制系统中。 这样可以确保所有团队成员和不同环境之间使用相同的依赖项版本。\n\n### peer dep\n在 npm 中，`npm i`（或 `npm install`）命令用于安装项目的依赖项。`--legacy-peer-deps` 是一个命令行选项，用于在安装依赖项时使用旧版的 peer 依赖处理逻辑。\n\n当您使用 npm v7 及更高版本时，默认情况下，peer 依赖项将自动安装，并在遇到冲突时中止安装并报错。这是为了确保所有依赖项与其 peer 依赖项完全兼容，避免后续的问题。\n\n然而，某些情况下，自动安装并检查 peer 依赖()可能会导致错误，或者与现有项目的配置不兼容。在这种情况下，使用 `--legacy-peer-deps` 选项可以按照旧版 npm（v6 及以下版本）的逻辑处理 peer 依赖。也就是说，npm 将不会自动安装 peer 依赖项，也不会因 peer 依赖项冲突而中止安装过程。\n\n一个使用 `--legacy-peer-deps` 的例子：\n\n```\nnpm i --legacy-peer-deps\n```\n\n该命令将使用旧版 npm 的逻辑来处理和安装项目的依赖项及其 peer 依赖。当您在更新一个较旧的项目时，或者遇到 peer 依赖冲突导致无法安装新依赖时，这个选项可能会有所帮助。"},{"title":"map和forEach使用指北","url":"/2020/10/21/map和forEach使用指北/","content":"### forEach\n`Array.prototype.forEach()` 是 JavaScript 中数组迭代的一种方法。`forEach()` 方法对数组的每个元素执行指定的操作，通常使用函数作为参数。它不会返回新数组，仅用于数组元素的操作和迭代。\n\n以下是使用 `arr.forEach()` 的最佳实践：\n\n1. 函数参数\n\n当使用 forEach() 时，传递一个函数作为参数。该函数可以是一个命名函数或箭头函数，这取决于你的需求和喜好。 箭头函数使语法更简洁，但请注意，它们不绑定自己的 `this`，有时这可能会导致问题。\n\n```javascript\n// 使用箭头函数\narr.forEach((element) => {\n  console.log(element);\n});\n\n// 使用命名函数\nfunction processElement(element) {\n  console.log(element);\n}\n\narr.forEach(processElement);\n```\n\n2. 接收可以传递给回调函数的额外参数\n\nforEach() 的回调函数还可以接收第二个参数，即当前元素的索引。 这可以帮助你在需要时检查数组的迭代状态。\n\n```javascript\narr.forEach((element, index) => {\n  console.log(`Element at index ${index} is: ${element}`);\n});\n```\n\n3.不要在迭代过程中修改原始数组\n\n使用 forEach() 迭代时不要修改原始数组。这可能会导致意料之外的结果。 如果需要改变原始数组，请考虑使用其他数组方法，如 map() 或 filter()。\n\n```javascript\n// 不推荐：在迭代过程中修改原始数组\narr.forEach((element, index) => {\n  arr[index] *= 2;\n});\n\n// 推荐：使用 map() 创建新数组\nconst newArr = arr.map((element) => element * 2);\n```\n\n4. 使用 `thisArg` 参数\n\nforEach() 还支持第二个参数 `thisArg`，这允许你为回调函数绑定 `this`。使用时需小心，因为箭头函数和其他类型的回调可能有不同的行为。\n\n```javascript\nconst myObj = {\n  counter: 0,\n  incrementCounter: function(num) {\n    this.counter += num;\n  },\n};\n\nconst numbers = [1, 2, 3, 4, 5];\nnumbers.forEach(function(num) {\n  this.incrementCounter(num);\n}, myObj);\n\n\n5. 错误处理\n\n使用 `Array.prototype.forEach()` 时，注意处理回调中可能抛出的异常。当你需要捕获异常时，可以在回调函数内部使用 try-catch。\n\n```javascript\narr.forEach((element, index) => {\n  try {\n    // Your code here, it might throw an error\n  } catch (error) {\n    console.error(`Error processing element at index ${index}: ${error.message}`);\n  }\n});\n```\n\n综上，这些最佳实践有助于你更有效地使用 Array.prototype.forEach() 进行数组迭代。\n\n\n### map\n- 当我们需要对数组内容做批量修改、同时修改的逻辑又高度一致时，就可以调用 map 来达到我们的目的\n\n\n### for\n- 从性能上看，for 循环遍历起来是最快的\n\n\n### 数组初始化\n\n#### 一维-fill\n- 当给 fill 传递一个入参时，如果这个入参的类型是引用类型，那么 fill 在填充坑位时填充的其实就是入参的引用\n\n#### 二维数组初始化\n- for"},{"title":"内部数据和外部数据拎拎清","url":"/2020/10/21/内部数据和外部数据拎拎清/","content":"\n- global state\n- local state\n","tags":["工作有感"]},{"title":"泛型","url":"/2020/10/21/泛型/","content":"\n>闲聊八卦，朋友来了一句：\n.net的泛型和Java的泛型有啥区别，为啥.net可以做基元类型的泛型，而Java不可以，以及跟C++的模板啥区别?\n然后我就懵了，这。。。毕业后一直摸的是动态语言，菜菜的我因为最近正好也要熟悉下我们这边服务端（Java），就认真的查了查朋友的问题\n（PS：朋友的后续聊天：C++的模板也会有问题，他带来了代码的膨胀，他带来了代码的膨胀；Java的泛型也有自身的问题，Java的泛型做的是类型擦除，这样对于基元类型要做一次装箱；.Net的泛型我觉得好看,但是Java之所以没有这么做，我觉得是因为历史原因；所以千万别只局限js；所以有时候真要追求性能，我们就会自己写数据结构）\n\n\n> 泛型编程是自 STL（标准模板库）纳入到 C++ 标准以后才逐渐流行起来的新范式，核心思想是“一切皆为类型”，或者说是“参数化类型”“类型擦除”，使用模板而不是继承的方式来复用代码，所以运行效率更高，代码也更简洁。\n在 C++ 里，泛型的基础就是 template 关键字，然后是庞大而复杂的标准库，里面有各种泛型容器和算法，比如 vector、map、sort，等等。\n\n### 论文指路：\n- http://stepanovpapers.com/genprog.pdf\n- https://www.microsoft.com/en-us/research/publication/design-and-implementation-of-generics-for-the-net-common-language-runtime/?from=http%3A%2F%2Fresearch.microsoft.com%2Fpubs%2F64031%2Fdesignandimplementationofgenerics.pdf\n\n### TypeScript-文档指路： \nhttps://www.tslang.cn/docs/handbook/generics.html\n","tags":["TypeScript"]},{"title":"函数的表示","url":"/2020/10/09/函数的表示/","content":"> 参考资料：\n1.函数图解（SICP-1.2.6 ）\n2.https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-pure-function-d1c076bec976\n3.https://medium.com/@jamesjefferyuk/javascript-what-are-pure-functions-4d4d5392d49c\n\n纯函数（Pure functions）：\n\nFunctions have some input (their arguments) and return some output (the result of applying them).\n具有一些输入（参数）以及返回一些输出（调用结果）的函数。\n\n- Given the same input, will always return the same output.\n- Produces no side effects.\n\n```\nMath.abs(-2)\n```\n\n可以描述为接受输入并产生输出的小型机器\n\n使用纯函数的好处：\n> One of the major benefits of using pure functions is they are immediately testable. They will always produce the same result if you pass in the same arguments.\n\n\n非纯函数（Non-pure functions）：\nIn addition to returning a value, applying a non-pure function can generate side effects, which make some change to the state of the interpreter or computer. A common side effect is to generate additional output beyond the return value, using the print function.\n\n除了返回一个值之外，调用非纯函数会产生副作用，这会改变解释器或计算机的 一些状态。一个普遍的副作用就是在返回值之外生成额外的输出\n\nSide effects include, but are not limited to:\n- Making a HTTP request\n- Mutating data\n- Printing to a screen or console\n- DOM Query/Manipulation\n- Math.random()\n- Getting the current time\n\n\n```\nMath.random()\nconsole.log(1)\nconsole.log(console.log(1))\n```\n调用console.log的嵌套表达式，会凸显出它的非纯特性\n\n\n签名（Signatures）：\nA description of the arguments that a function can take is called the function's signature.\n函数的可接受参数的描述叫做函数的签名。\n\n\n<pre>\nMath.abs(number)\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/abs\nconsole.log(...)\nhttps://developer.mozilla.org/zh-CN/docs/Web/API/Console/log\n\n</pre>\n\n> 借助抽象，不关系底层的具体计算过程，在根高层次shanghai思考问题； 函数是最基本的一种代码抽象方式","tags":["函数","SICP-Py"]},{"title":"list-style","url":"/2020/09/08/list-style/","content":"> 文档指路：https://developer.mozilla.org/zh-CN/docs/Web/CSS/list-style\n","tags":["css"]},{"title":"表达式-语句-值-ES6-python","url":"/2020/09/07/表达式-语句-值-ES6-python/","content":"\n> 探究下不同语言中，表达式/语句是否有值的问题 ～ （问题来源于SICP(1.2.5)中对表达式和语句的阐述）\n\n> 参考文档 —— SICP(1.2.5) + https://blog.csdn.net/aimingoo/article/details/51136511\n\nSICP(1.2.5) —— In general, statements are not evaluated but executed; they do not produce a value but instead make some change.\n\n比如在python当中：数字（以及表达式）自己在\tPython\t程序的上下文中会求解为值\n ```\n >>> x = 3\ndoes not return a value nor evaluate a function on some arguments, since the purpose of assignment is instead to bind a name to a value.\n ```\n\n但是在JS当中：\n ```\n> a = 1\n1\n ```\n我们会看到如上输出\n```\nThe value of a StatementList is the value of the last value producing item in the StatementList. For example, the following calls to the eval function all return the value 1:\n\nThe production IfStatement : if ( Expression ) Statement else Statement is evaluated as follows:\n\nLet exprRef be the result of evaluating Expression.\nIf ToBoolean(GetValue(exprRef)) is true, then\na. Return the result of evaluating the first Statement.\nElse,\neval(\"1;;;;;\")\neval(\"1;{}\")\neval(\"1;var a;\")\n```\n具体对语句产生值的问题，可以看 https://blog.csdn.net/aimingoo/article/details/51136511 里面的阐释（说明了ES6中对这部分的处理）\n"},{"title":"SICP-notes","url":"/2020/09/03/SICP-notes/","content":"\n> 基于https://www-inst.eecs.berkeley.edu//~cs61a/sp12/book/课程\n\n### python篇\n\n- python3进入命令行模式之后：\n1. ctrl + D 退出\n2. ctrl + P 上一个\n2. ctrl + N 下一个\n\n###\n\n- 语句（描述操作） + 表达式（描述产生值的运算）\n老生常谈之语句和表达式，在python中，python解释器执行语句和求解表达式\n```\nfrom urllib.request import urlopen\n```\n\n函数封装了操作数据的逻辑～\n\n## Course\n#### Lisp\nComputer-划掉 Science-划掉 （engineering ｜ art）\nthe essence of what you're doing \nthe tools that you use\n\nwhat is true\nhow to\n\nprocess\nprocedure\nrules\n\ntechniques for control complexity 在大型系统中控制复杂度的技术\n\n计算机科学处理的是理想化的组件\n计算机科学是工程中的抽象形式\n\n约束-对大脑的约束\n\n指令性\n解释性\n\n```\n基本过程\n基础数据\n\n组合\n抽象\n\n通用模式 - common pattern\n```\n\n\n控制复杂度\n\n- Black-box abstract\n输入 - 输出\n简化问题，方便别人使用，构建更大的盒子\n\nseal_sdk_core\n上传 ｜ topic_ui => pdf_template | basic_ui_table => 可插拔统计模块 => 业务沉淀归类\n\n- 约定接口 （面向对象编程，stream）\n\n- 新语言（隐藏部分细节，强调部分细节） - 选择lib,选择framework，选择生态\n\n\nprimitive elements\nmeans of combination | abstraction\n\n前端兼容性\n\n- 出问题的地方\n- 不同浏览器对不规范写法的容忍度\n\n\n### js - 在线版\n- https://sicp.sourceacademy.org/\n- 21年完成的","tags":["SICP"]},{"title":"vue源码求索","url":"/2020/09/03/vue源码求索/","content":"\n#### 对Vue项目的探索\n\n\n#### 分支篇\n先看tag,目前是v2.6.12是最大tag版本号，可知release最新的版本即为2.6.12\n\n\n#### package.json篇\n\n## 工具函数\n- https://github.com/vuejs/vue/blob/dev/dist/vue.js#L14-L379\n- https://github1s.com/vuejs/vue/blob/dev/src/shared/util.js\n- https://juejin.cn/post/7024276020731592741#heading-0\n\n\n## core/util/debug.js\n- 2.x\n- src/core/util/debug.js\n- nestjs中的components就是参考这个","tags":["vue"]},{"title":"算法设计与分析-学习笔记","url":"/2020/08/20/算法设计与分析-学习笔记/","content":"\n1. 基础知识： 算法的基本概念及伪码描述，函数的渐近的界\n2. 基础知识：序列求和方法，递推方程求解\n","tags":["算法设计与分析"]},{"title":"csshoudini","url":"/2020/08/18/csshoudini/","content":"\n> 指路：https://github.com/w3c/css-houdini-drafts\n\n#### essays\n- https://www.smashingmagazine.com/2016/03/houdini-maybe-the-most-exciting-development-in-css-youve-never-heard-of/\n#### doc\n- https://developer.mozilla.org/zh-CN/docs/Web/Guide/Houdini\n- https://drafts.css-houdini.org/\n\n#### isReady\n- https://ishoudinireadyyet.com/\n- https://github.com/GoogleChromeLabs/houdini-samples (no more updates)\n\n\n#### description\n- Css houdini\n- the extensible web Manifesto\n- 在web上做你任何想做的\n\n- Web components\n- Web assembly\n- Css Houdini\n\n阿里汉仪智能黑体\n\n向前兼容（考虑未来趋势，方案）\n\nstyling API for reusable components\n@justineo\n顾轶灵\n\ntightly coupled & limited\n\nauthor ／ reader balance\ndeveloper/user\n\nweb documents\nweb application\n","tags":["css"]},{"title":"样式的一些问题","url":"/2020/08/12/样式的一些问题/","content":"\n#### 基本概念\n\n<pre>\n顶线（top）\n中线（middle）\n基线（baseline）\n底线（bottom）\n</pre>\n\n行距（line-height）———— 两行文字任意一条线的距离\n\nfont-size ———— 顶线到底线\n\nline-height = font-size + 半行距*2 = font-size + 行距\n\n#### CSS3 object-fit/object-position - CR\nMethod of specifying how an object (image or video) should fit inside its box. object-fit options include \"contain\" (fit according to aspect ratio), \"fill\" (stretches object to fill) and \"cover\" (overflows box but maintains ratio), where object-position allows the object to be repositioned like background-image does.\n\n\n不支持IE11\n","tags":["CSS"]},{"title":"无障碍","url":"/2020/08/12/无障碍/","content":"\n\n### role属性\nrole是无障碍阅读，是给有阅读障碍的人设置的属性，有阅读障碍的人可以用读屏软件来解析\n\n<pre>\nIn programing, Semantics refers to the meaning of a piece of code — for example \"what effect does running that line of JavaScript have?\", or \"what purpose or role does that HTML element have\" (rather than \"what does it look like?\".)\nFor example, the <h1> element is a semantic element, which gives the text it wraps around the role (or meaning) of \"a top level heading on your page.\"\n\n\nThe aria-invalid attribute is used to indicate that the value entered into an input field does not conform to the format expected by the application.This may include formats such as email addresses or telephone numbers. aria-invalid can also be used to indicate that a required field has not been filled in.The attribute should be programmatically set as a result of a validation process.\n\nThis attribute can be used with any typical HTML form element; it is not limited to elements that have an ARIA role assigned.\n\nWAI-ARIA is a specification written by the W3C, defining a set of additional HTML attributes that can be applied to elements to provide additional semantics and improve accessibility wherever it is lacking. There are three main features defined in the spec:\n\n\n\t•\tRoles — These define what an element is or does. Many of these are so-called landmark roles, which largely duplicate the semantic value of HTML5 structural elements e.g. role=\"navigation\" (<nav>) or role=\"complementary\" (<aside>), but there are also others that describe different pages structures, such as role=\"banner\", role=\"search\", role=\"tabgroup\", role=\"tab\", etc., which are commonly found in UIs.\n\t•\tProperties — These define properties of elements, which can be used to give them extra meaning or semantics. As an example, aria-required=\"true\"specifies that a form input needs to be filled in to be valid, whereas aria-labelledby=\"label\" allows you to put an ID on an element, then reference it as being the label for anything else on the page, including multiple elements, which is not possible using <label for=\"input\">. As an example, you could use aria-labelledby to specify that a key description contained in a <div>is the label for multiple table cells, or you could use it as an alternative to image alt text — specify existing information on the page as an image's alt text, rather than having to repeat it inside the alt attribute. You can see an example of this at Text alternatives.\n\t•\tStates — Special properties that define the current conditions of elements, such as aria-disabled=\"true\", which specifies to a screenreader that a form input is currently disabled. States differ from properties in that properties don't change throughout the lifecycle of an app, whereas states can change, generally programmatically via JavaScript.\nAn important point about WAI-ARIA attributes is that they don't affect anything about the web page, except for the information exposed by the browser's accessibility APIs (where screenreaders get their information from). WAI-ARIA doesn't affect webpage structure, the DOM, etc., although the attributes can be useful for selecting elements by CSS.\n\n</pre>\n"},{"title":"跨域问题","url":"/2020/08/11/跨域问题/","content":"\n> HTTP access control (CORS) 跨域问题是工作中，开发环境下，常遇到的一个问题\n\n * 名词解释\n\n#### 预检请求\nPreflighted requests(options)\n触发条件：\n- It uses methods other than GET, HEAD or POST. Also, if POST is used to send request data with a Content-Type other than application/x-www-form-urlencoded, multipart/form-data, ortext/plain, e.g. if the POST request sends an XML payload to the server using application/xmlor text/xml, then the request is preflighted.\n\n- It sets custom headers in the request (e.g. the request uses a header such as X-PINGOTHER)\n\n浏览器在发起跨域请求的时候会带着一个`Origin` header，那么其实就是个custom headers，那么也就会先触发一个Preflighted requests， Fetch Standard 也有提到。\n\n指路：Fetch Standard（https://fetch.spec.whatwg.org/#cors-preflight-request）\n3.2.2. HTTP requests\nA CORS request is an HTTP request that includes an `Origin` header. It cannot be reliably identified as participating in the CORS protocol as the `Origin` header is also included for all requests whose method is neither `GET` nor `HEAD`.\n\nA CORS-preflight request is a CORS request that checks to see if the CORS protocol is understood. It uses `OPTIONS` as method and includes these headers:\n\n✔MDN`Access-Control-Request-Method`\nIndicates which method a future CORS request to the same resource might use.\n\n✔MDN`Access-Control-Request-Headers`\nIndicates which headers a future CORS request to the same resource might use.\n\n\n* 为什么要发预检请求？\n我们都知道浏览器的同源策略，就是出于安全考虑，浏览器会限制从脚本发起的跨域HTTP请求，像XMLHttpRequest和Fetch都遵循同源策略。浏览器限制跨域请求一般有两种方式：\n\t1.\t浏览器限制发起跨域请求\n\t2.\t跨域请求可以正常发起，但是返回的结果被浏览器拦截了\n一般浏览器都是第二种方式限制跨域请求，那就是说请求已到达服务器，并有可能对数据库里的数据进行了操作，但是返回的结果被浏览器拦截了，那么我们就获取不到返回结果，这是一次失败的请求，但是可能对数据库里的数据产生了影响。\n为了防止这种情况的发生，规范要求，对这种可能对服务器数据产生副作用的HTTP请求方法，浏览器必须先使用OPTIONS方法发起一个预检请求，从而获知服务器是否允许该跨域请求：如果允许，就发送带数据的真实请求；如果不允许，则阻止发送带数据的真实请求。\n\n\n### CORS settings attributes\ncanvas合成图片时候的跨域问题\nhttps://developer.mozilla.org/zh-CN/docs/Web/HTML/Attributes/crossorigin\n\n### due to access control checks\nCOS新的测试桶，部分safari浏览器，会报这个，因为使用了通配符 * 作为allow的origin; 修改之后即可；","tags":["CORS"]},{"title":"升https","url":"/2020/08/11/升https/","content":"\n* 名词解释\n\n#### SSL\nSSL (Secure Sockets Layer) and its successor, TLS (Transport Layer Security), are protocols for establishing authenticated and encrypted links between networked computers. Although the SSL protocol was deprecated with the release of TLS 1.0 in 1999, it is still common to refer to these related technologies as “SSL” or “SSL/TLS.” The most current version is TLS 1.3, defined in RFC 8446(https://tools.ietf.org/html/rfc8446) (August 2018).\n- 为互联网通信提供安全及数据完整性保障\n- SSL证书是CA对用户公钥的认证\n\n#### CA\nA certificate authority (CA), also sometimes referred to as a certification authority, is a company or organization that acts to validate the identities of entities (such as websites, email addresses, companies, or individual persons) and bind them to cryptographic keys through the issuance of electronic documents known as digital certificates. A digital certificate provides:\nCA机构，是承担公钥合法性检验的第三方权威机构，负责指定政策、步骤来验证用户的身份，并对SSL证书进行签名，确保证书持有者的身份和公钥的所有权。\n\n- Authentication, by serving as a credential to validate the identity of the entity that it is issued to.\n- Encryption, for secure communication over insecure networks such as the Internet.\n- Integrity of documents signed with the certificate so that they cannot be altered by a third party in transit.\n\n\n![](ca-diagram-b.png)\n\ncite(https://www.ssl.com/faqs/what-is-a-certificate-authority/)\n\n### protocol-relative url的问题\n- https://www.paulirish.com/2010/the-protocol-relative-url/\n- 尽量避免使用\n```\nUpdate 2014.12.17:\n\nNow that SSL is encouraged for everyone and doesn’t have performance concerns, this technique is now an anti-pattern. If the asset you need is available on SSL, then always use the https:// asset.\n\nAllowing the snippet to request over HTTP opens the door for attacks like the recent Github Man-on-the-side attack. It’s always safe to request HTTPS assets even if your site is on HTTP, however the reverse is not true.\n\nMore guidance and details in Eric Mills’ guide to CDNs & HTTPS and digitalgov.gov’s writeup on secure analytics hosting.\n```\n\n### cases\n```\ncurl https://xxxx.xxx.cn\ncurl: (60) SSL: no alternative certificate subject name matches target host name 'xxxx.xxx.cn'\nMore details here: https://curl.haxx.se/docs/sslcerts.html\n\ncurl failed to verify the legitimacy of the server and therefore could not\nestablish a secure connection to it. To learn more about this situation and\nhow to fix it, please visit the web page mentioned above.\n```\n进入Chrome看，可以点击小锁，看具体的证书信息\n\n### SSL证书生成\n- 17年开始，如果不是https,chrome会被标记不安全 苹果要求都是https；不用https，很容易被运营商劫持\n- 证书的安全级别 证书的更新\n- 七牛云（一年1900） 阿里云 腾讯云\n- 拿到证书，scp上传到服务器上\n```\nmv ssl /www/\n/nginx/conf.d server部分配置ssl\n# 运维，安全\nhelp.aliyun.com\n```\n\n### https | http\n#### ajax-using-https-on-an-http-page\n- https://stackoverflow.com/questions/1105934/ajax-using-https-on-an-http-page\n#### how-can-i-make-an-http-request-from-an-https-website\n- https://stackoverflow.com/questions/53211319/how-can-i-make-an-http-request-from-an-https-website\n\n\n#### cookies set不了的问题\n- https://stackoverflow.com/questions/62578201/how-to-fix-this-set-cookie-was-blocked-due-to-user-preferences-in-chrome-sta\n- https://angel.co/today/stories/chrome-83-arrives-with-redesigned-security-settings-third-party-cookies-blocked-in-incognito-21796\n","tags":["HTTP","SSL"]},{"title":"jquery-design","url":"/2020/08/11/jquery-design/","content":"\n> 一般我看源码的tricks，找到core.js,一些精简的库，cmd+J,cmd+K,cmd+0（VSCode）;得到方法折叠，然后再一层层展开看结构；\n> jQuery 阶段性的选择，在那个阶段，解决了那个阶段的问题；\n> github彻底移除jquery - blog( why | how )\n\n## 设计理念\n### 回归增强\n- Regressive Enhancement\n- 为系统的特性设定基线，并应用到较老的设备和浏览器中\n### dir\n- 3.1.0\n```\n➜  jquery tree\n.\n├── AUTHORS.txt\n├── LICENSE.txt\n├── README.md\n├── brower.json\n├── dist\n│   ├── core.js\n│   ├── jquery.js\n│   ├── jquery.min.js\n│   ├── jquery.min.map\n│   ├── jquery.slim.js\n│   ├── jquery.slim.min.js\n│   └── jquery.slim.min.map\n├── external\n│   └── sizzle\n│       └── dist\n│           └── LICENSE.txt\n├── package.json\n└── src\n    ├── ajax\n    │   ├── jsonp.js\n    │   ├── load.js\n    │   ├── parseXML.js\n    │   ├── script.js\n    │   ├── var\n    │   │   ├── location.js\n    │   │   ├── nonce.js\n    │   │   └── rquery.js\n    │   └── xhr.js\n    ├── ajax.js\n    ├── attributes\n    │   ├── attr.js\n    │   ├── classes.js\n    │   ├── prop.js\n    │   ├── support.js\n    │   └── val.js\n    ├── attributes.js\n    ├── callbacks.js\n    ├── core\n    │   ├── DOMEval.js\n    │   ├── access.js\n    │   ├── init.js\n    │   ├── parseHTML.js\n    │   ├── ready-no-deferred.js\n    │   ├── ready.js\n    │   ├── readyException.js\n    │   ├── support.js\n    │   └── var\n    │       └── rsingleTag.js\n    ├── core.js\n    ├── css\n    │   ├── addGetHookIf.js\n    │   ├── adjustCSS.js\n    │   ├── curCss.js\n    │   ├── hiddenVisibleSelector.js\n    │   ├── showHide.js\n    │   ├── support.js\n    │   └── var\n    │       ├── cssExpand.js\n    │       ├── getStyles.js\n    │       ├── isHiddenWithinTree.js\n    │       ├── rmargin.js\n    │       ├── rnumnonpx.js\n    │       └── swap.js\n    ├── css.js\n    ├── data\n    │   ├── Data.js\n    │   └── var\n    │       ├── acceptData.js\n    │       ├── dataPriv.js\n    │       └── dataUser.js\n    ├── data.js\n    ├── deferred\n    │   └── exceptionHook.js\n    ├── deferred.js\n    ├── deprecated.js\n    ├── dlimensions.js\n    ├── effects\n    │   ├── Tween.js\n    │   └── animatedSelector.js\n    ├── effects.js\n    ├── event\n    │   ├── ajax.js\n    │   ├── alias.js\n    │   ├── focusin.js\n    │   ├── support.js\n    │   └── trigger.js\n    ├── event.js\n    ├── exports\n    │   ├── amd.js\n    │   └── global.js\n    ├── jquery.js\n    ├── manipulation\n    │   ├── _evalUrl.js\n    │   ├── buildFragment.js\n    │   ├── getAll.js\n    │   ├── setGlobalEval.js\n    │   ├── support.js\n    │   ├── var\n    │   │   ├── rcheckableType.js\n    │   │   ├── rscriptType.js\n    │   │   └── rtagName.js\n    │   └── wrapMap.js\n    ├── manipulation.js\n    ├── offset.js\n    ├── queue\n    │   └── delay.js\n    ├── queue.js\n    ├── selector-native.js\n    ├── selector-sizzle.js\n    ├── selector.js\n    ├── serialize.js\n    ├── traversing\n    │   └── var\n    │       └── findFilter.js\n    ├── traversing.js\n    ├── var\n    │   ├── ObjectFunctionString.js\n    │   ├── arr.js\n    │   ├── class2type.js\n    │   ├── concat.js\n    │   ├── document.js\n    │   ├── documentElement.js\n    │   ├── fnToString.js\n    │   ├── getProto.js\n    │   ├── hasOwn.js\n    │   ├── indexOf.js\n    │   ├── pnum.js\n    │   ├── push.js\n    │   ├── rcssNum.js\n    │   ├── rnotwhile.js\n    │   ├── slice.js\n    │   ├── support.js\n    │   └── toString.js\n    └── wrap.js\n\n24 directories, 110 files\n```\n#### $\n$ 本质是个函数\n\n```\n$\njQuery.noConflict()\n$\njQuery\n```\njQuery在占用$之前，先保存了原来的$,调用jQuery.noConflict()时会把原来保存的变量还原\n\n#### 选择器\n- 层级选择器\n- 子选择器\n- 过滤器\n- 表单相关\n\n#### example\ndata() 方法向被选元素附加数据，或者从被选元素获取数据。\nself.find('#xxx tr:last').data().id = rows.sub_categories[i].id;\nself.find(\"#xxx\").children().eq(i).data(\"id\")\n\n#### 扩展\n我们可以扩展jquery来实现自定义方法—— 编写jquery插件\n```\n$.fn.testfunc = function() {\n  this.css('color', '#fffceb');\n  return this; // 因为jquery对象支持链式操作，扩展方法也要能继续链式下去\n}\n$.fn.testfunc.defaults = {\n  color: '#ffffff'\n}\n```\n默认值处理： || && (可以这么处理)\n\n编写插件原则：\n1. 给$.fn绑定函数，实现插件的代码逻辑；\n2. 插件函数最后要return this，以支持链式调用；\n3. 插件函数要有默认值，绑定在$.fn.<pluginName>.defaults上；\n4. 调用时可传入设定值以便覆盖默认值\n5. 过滤特定元素\n\n#### 事件\n- https://api.jquery.com/click/\n- click 如果事件处理函数里面有延迟执行，可能会被浏览器拦截\n\n#### 动画\n\n### 一些jquery的项目\n- The No Hassle JavaScript Colorpicker（bgrins.github.io/spectrum/）\n- \n\n## basics\n### module.js\n```\n;(function(){\n  'use strict'\n})();\n# 自执行函数\n# 第一个;是为了如果代码混淆之后，前面的代码如果没有分号，可以避免问题；\n# 为什么要放在这个里面，避免全局污染；如果直接var a = 1; 则 window.a = 1;\n```\n\n## Others\nReact17:\n```\nbefore17:\ndocument.addEventListener() 来监听事件\n17:\nrootNode.addEventListener()\n\n# 解决了多版本 React 的问题\n# 在和 JQuery 一起使用时，降低事件冲突的可能性\n```\n\n#### ajax\n- https://api.jquery.com/jQuery.ajax/\n```\nasync (default: true)\nType: Boolean\nBy default, all requests are sent asynchronously (i.e. this is set to true by default). If you need synchronous requests, set this option to false. Cross-domain requests and dataType: \"jsonp\" requests do not support synchronous operation. Note that synchronous requests may temporarily lock the browser, disabling any actions while the request is active. As of jQuery 1.8, the use of async: false with jqXHR ($.Deferred) is deprecated; you must use the success/error/complete callback options instead of the corresponding methods of the jqXHR object such as jqXHR.done().\n```","tags":["jquery"]},{"title":"为团队构建一个脚手架生成工具","url":"/2020/08/06/为团队构建一个脚手架生成工具/","content":"> vite真的好用，no more ~~~ update 2022.02\n\n\n## scaffolding - 脚手架\n- build process | code formatting | linting | testing |  type checking\n- code style - PR中，可以直接关掉，最初加上规则就行，后续不需要花更多时间讨论\n- https://btholt.github.io/project-fox-game-site/ - 里面有完整构建一个项目的流程，一些抽象出来的概念，可参考\n## 团队基础工程化的建设\n- 模块化\n- 组件化\n- 规范化\n- 自动化\n\n### 规范\n#### 约定\n- 命名\n#### 代码风格\n- 符号书写风格（缩进，括号，运算符，空格，空行，引号，逗号，分号）\n- 语法风格（变量命名，逻辑结构，函数签名）\n- 函数参数个数｜行最大字符数｜函数长度｜函数逻辑复杂度｜JS文件长度控制\n\n- eslint - devDependencies\n- scripts里面定义检查范围\n- .eslintrc.js 设置检查规则\n- 具体可见```eslint版本问题```博文\n\n\n### 自动化\n#### 打包\n- requireJS,seaJS ｜ AMD,CMD规范\n\n- nodeJS - 开发环境工具脚本 ｜ 代码检查&&文件编译&&依赖管理&&内容打包&&单元测试&&持续集成 ｜ 代码可维护性\n\n#### npm\n- 见npm博文(npm使用指北)\n\n\nVue为主的团队\nPC+移动\nnode\nelectron\n\n\n1.业务项目\n2.核心逻辑业务（UI/utils）\n3.node项目\n4.electron项目\n\n- vue相关项目——业务型\n@vue/cli\n文档指导型（the standard build toolchain for Vue applications - 2018， evan you）\nvite —— 后续探索 （webpack本身拖拉机的特质，vite超跑）\n\n- node项目\n\n\n\n- electron项目\n\n## cli相关\n- 推荐command line interface guidelines：https://clig.dev/\n- https://www.npmjs.com/package/meow\n\n\n## haoma\n\n\n## vite\n### minify\n\n#### esbuild - minify\n- https://esbuild.github.io/api/#minify\n\n#### terser - minify\n- https://terser.org/docs/api-reference#minify-options\n\n#### terser vs rebuild\n- https://vitejs.cn/config/#build-minify\n- https://github.com/privatenumber/minification-benchmarks\n\n\n### concept\n- JS库 - 隐藏复杂浏览器差异\n- JS框架 - 使复杂强大的应用开发过程易于管理\n\n\n## basics\n#### lib - output\n- 匿名函数自调用，函数定义，函数表达式  xx.js => ;(function func() { })(); | (function func() { }()); - 没有差别，括号在里面可以算是分组运算符\n- Return the result of evaluating Expression. This may be of type Reference\n- This algorithm does not apply GetValue to the result of evaluating Expression\n- AST 结果\n\n### dotenv\n\n从一个 .env 文件中加载环境变量到 process.env 对象中。\n\n在开发环境中，我们通常需要在应用程序中使用各种敏感信息，例如数据库连接字符串、API 密钥等。\n将这些敏感信息直接硬编码到源代码中是不安全的，可能导致泄漏或被恶意攻击者利用。\n因此，我们通常会使用环境变量来存储这些信息，并在应用程序中引用它们。\n\n而 dotenv 库则提供了一种更方便的方式来加载环境变量。它可以自动从一个名为 .env 的文件中读取环境变量，并将其添加到 process.env 对象中。\n这样，我们就可以以类似于硬编码的方式使用环境变量，同时又能保护这些敏感信息不被泄露或恶意利用。\n\n\n#### yaml\n- https://www.npmjs.com/package/yaml\n```\nimport { parse } from 'yaml'\nconst path = require('path');\nconst fs = require('fs');\n\nexport const getEnv = () => {\n  return process.env.RUNNING_ENV\n}\n\nexport const getConfig = () => {\n  const environment = getEnv()\n  const yamlPath = path.join(process.cwd(), `./.config/.${environment}.yaml`)\n  const file = fs.readFileSync(yamlPath, 'utf8')\n  const config = parse(file)\n  return config\n}\n```\n\n#### cross-env - 指定运行环境来使用对应环境的配置变量"},{"title":"linux使用经验总结","url":"/2020/08/06/linux使用经验总结/","content":"### 学习参考资料\nhttps://github.com/jlevy/the-art-of-command-line/blob/master/README-zh.md\n- the-art-of-command-line\n\n\n### 报错解决\n\n```\ntouch h(1).txt\n```\n- -bash: syntax error near unexpected token `('\n- zsh: no matches found: 嘿嘿(1).txt\n因为括号的原因啦，需要转义，加\\; 也可以加引号；\n\n\n> 一些和系统平台无关的command\n\n#### !$，表示上一个命令行的最后一个参数。\n\n#### !!，表示上一个命令的完整命令\n\n#### gzip\n平时构建出来的文件，想看看gzip之后大小\n```gzip xxx.js```\n\n- AWS - 改变S3自身存储服务数据（主要是日志的）的压缩方式-从gzip日志切换到ztsd日志，使得存储成本降低30%\n- ztsd - Zstandard - Facebook 开源的快速无损压缩算法，应用于zlib级别的实时压缩场景，并且具有更好的压缩比\n- ztsd - 可以以压缩速度为代价提供更强的压缩比，速度与压缩率的比重可通过增量进行配置\n#### tree\n```\nman tree\n```\nmac 上想使用，用brew安装\n(比tree更好看的是 [exa](https://the.exa.website/install/macos))\n\n- 场景（查看项目里面的文件，排除node_modules）\n```\ntree - I \"node_modules\" -f | grep -C3 index.md\n```\n也可以用把结果输出后，用编辑器进行更复杂的搜索\n#### chmod\n```\nchmod -R 777 \n```\n设置当前目录及子目录所有文件=>所有人可读写可执行\n\n#### cp\n```\ncp -r /root/firekylin/www/static/pic /root/firekylin_1.x/www/static/pic \n```\n\n#### z\n文件夹跳转\n\n#### vidir\n可以批量修改文件名\n\n#### grep\ncat del2.log | grep  -oP \"\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*\" > del3.log\n\n\n#### 命令行操作\n<pre>\nCtrl+b 或左箭头键 左移一个字bai符（移至前一个字符）du\nCtrl+f 或右箭头键 右移一个字符（移至后一个字符）\nCtrl+a 移至行首\nCtrl+e 移至行尾\nEsc b 左移一个单词\nEsc f 右移一个单词\nDel 删除光标所在处的字符\nCtrl+d 删除光标所在处的字符\nBACKSPACE或Ctrl+h 删除光标左边的字符\nCtrl+k 删除至行尾\n\n所以：\nCtrl + a\nCtrl + k\n删除一整行\n</pre>\n\n\n#### Network Time Proctocol - NTP\n- 如果系统时间存在误差，可以起Cron任务，配置NTP服务，定时同步\n```\nrpm -q ntp\nyum -y install ntp\nsystemctl enable ntpd\nsystemctl start ntpd\n```\n\n#### top\n这个是个蛮重要的，一般机器情况看下这个基本上就知道了(Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况)\n\n- 改变画面更新频率\n　　l - 关闭或开启第一部分第一行 top 信息的表示\n　　t - 关闭或开启第一部分第二行 Tasks 和第三行 Cpus 信息的表示\n　　m - 关闭或开启第一部分第四行 Mem 和 第五行 Swap 信息的表示\n　　N - 以 PID 的大小的顺序排列表示进程列表（第三部分后述）\n　　P - 以 CPU 占用率大小的顺序排列进程列表 （第三部分后述）\n　　M - 以内存占用率大小的顺序排列进程列表 （第三部分后述）\n　　h - 显示帮助\n　　n - 设置在进程列表所显示进程的数量\n　　q - 退出 top\n\nMac上面，<strong>“活动监视器是”</strong>GUI的面板\nWindows,类似于任务管理器。\n\n\n\n#### nohup\n参考资料：https://developer.ibm.com/zh/tutorials/l-lpic1-103-5/\n\n\n#### curl\ncurl - transfer a URL\ncurl(CommandLine Uniform Resource Locator)\ncurl  is  a tool to transfer data from or to a server, using one of the supported protocols (DICT, FILE, FTP, FTPS, GOPHER, HTTP, HTTPS,  IMAP, IMAPS,  LDAP,  LDAPS,  POP3,  POP3S,  RTMP, RTSP, SCP, SFTP, SMB, SMBS, SMTP, SMTPS, TELNET and TFTP).\ncURL是一个多功能工具。当然，它可以下载网络内容，但同时它也能做更多别的事情。\n\ncurl is powered by  libcurl  for  all  transfer-related  features.\ncURL 技术支持库是：libcurl。这就意味着你可以基于 cURL 编写整个程序，允许你基于 libcurl 库中编写图形环境的下载程序，访问它所有的功能。\n\ncurl offers a busload of useful tricks like proxy support, user authentication, FTP upload, HTTP post, SSL connections, cookies, file  transfer  resume,  Metalink,  and more.\ncURL 宽泛的网络协议支持可能是其最大的卖点。cURL 支持访问 HTTP 和 HTTPS 协议，能够处理 FTP 传输。它支持 LDAP 协议，甚至支持 Samba 分享。实际上，你还可以用 cURL 收发邮件。\n\ncURL 也有一些简洁的安全特性。cURL 支持安装许多 SSL/TLS 库，也支持通过网络代理访问，包括 SOCKS。这意味着，你可以越过 Tor 来使用cURL。\ncURL 同样支持让数据发送变得更容易的 gzip 压缩技术。\n\n#### fx\n- https://github.com/antonmedv/fx\n```\nfx data.json\n# 不展开\ncurl ... | fx # 点击可展开，可搜索 .xxx.xxx\n# 全部展开\ncurl ... | fx .\n```\n- 查问题的时候，能方便看到json数据\n#### wget\nWget - The non-interactive network downloader.\n\n\n#### netstat\n```\nnetstat -- show network status\n# 查看连接当前服务器的用户IP，前5名\nnetstat -nat | awk '{print $5}' | awk -F ':' '{print $1}' | sort | uniq -c | sort -rn | head -n 5\n\n```\n\n\n\n#### alias\n自定义指令\n注意，如果使用了zsh,则改动bash的配置就不生效了,只需要处理下.zshrc文件即可\n```\nopen -e .zshrc \nsource .zshrc\n```\n- source命令是在Linux和Unix系统中用来重新加载shell环境变量和函数的命令。在更改了环境变量或者函数定义的情况下，可以使用source命令或者其等效的.（点）符号让这些更改立即生效，而无需重新启动终端\n- 重启终端可以让所有更改的环境变量或函数完全生效\n#### fx(https://github.com/antonmedv/fx)\n能够格式化JSON文本\n#### 日志\ntail/lnav\n- tail 默认最后10行\n- tail -f(循环读取)\n\n### 具体场景\n####  查看目录下文件/文件夹个数\n```\n# 文件\n_posts git:(master) ✗ ls -l | grep \"^-\" | wc -l\n     149\n# 文件夹\n_posts git:(master) ✗ ls -l | grep \"^d\" | wc -l\n     135\n\n# 包括子文件夹\nls -lR\n```\n\n### export\nLinux export 命令用于设置或显示环境变量。\n\n在 shell 中执行程序时，shell 会提供一组环境变量。export 可新增，修改或删除环境变量，供后续执行的程序使用。export 的效力仅限于该次登陆操作。\n```\nexport [-fnp][变量名称]=[变量设置值]\n```\n\n### 基本操作\n```\ndate | cal | df | free( free - Display amount of free and used memory in the system 显示内存使用情况的统计信息)\n[root@VM-12-3-centos ~]# free\n              total        used        free      shared  buff/cache   available\nMem:        1882008      501288       80272         520     1300448     1196596\n[root@VM-12-3-centos ~]# df -Th\nFilesystem     Type      Size  Used Avail Use% Mounted on\ndevtmpfs       devtmpfs  908M     0  908M   0% /dev\ntmpfs          tmpfs     919M   24K  919M   1% /dev/shm\ntmpfs          tmpfs     919M  496K  919M   1% /run\ntmpfs          tmpfs     919M     0  919M   0% /sys/fs/cgroup\n/dev/vda1      ext4       59G  5.9G   51G  11% /\ntmpfs          tmpfs     184M     0  184M   0% /run/user/0\n[root@VM-12-3-centos ~]# df -Th /data\nFilesystem     Type  Size  Used Avail Use% Mounted on\n/dev/vda1      ext4   59G  5.9G   51G  11% /\n\n# -h (--human) 方便阅读的数据单位格式\n# -T (--print-type) print file system typeq\n```\nfree里面有个buffer(缓冲区)，例如打印场景；在Linux中，你会发现系统运行的时间越长，占用的内存就越多。这并不是说Linux用完了所有内存，而是Linux利用所有的可用内存尽可能地进行缓冲；\n卸载设备会将所有剩余的数据写入设备，以便能够将其安全地移除。如果在移除前没有先卸载，则存在数据并未完全写入该设备的可能性。\n### 存储介质\nmount：挂载文件系统\numount：卸载文件系统\nfsck：检查和修复文件系统\nfdisk：操作分区\nmkfs：创建新的文件系统\ndd：转换和复制文件\ngenisoimage（mkisofs）：创建ISO 9660映像文件\nwodim（cdrecord）：擦除和刻录光学存储介质\nmd5sum：计算MD5校验和\n\n\n### 定时任务\n```\ncron - 周期性执行\nat - 单一时刻执行一次任务\n\n```\n\n### /etc/init.d\n\n\n## 名词解释\n> man XXX / xxx --help \n\n1. su / sudo (man su / man sudo)  su 使用的是root的密码，sudo使用的是当前用户的密码\n2. default setting 默认设置\n3. enable adapter  授权适配\n4. at the boot prompt (boot:引导，启动)\n5. sed：stream editor for filtering and transforming text\n   ```\n   A stream editor is used to perform basic text transformations on an input stream (a file or\n     input from a pipeline).  While in some ways similar to an editor which permits scripted edits (such as ed),  sed  works by  making only one pass over the input(s), and is consequently more efficient.  But it is sed's ability to filter text\n     in a pipeline which particularly distinguishes it from other types of editors.\n    ```\n特点：1、非交互式编辑器；\n     2、没有破坏性，不修改原文件，除非使用shell的重定向符来保存结果；\n     3、sed也支持sed脚本。\n其工作原理为：将一行文字读到内存空间（该内存空间称为sed的模式空间）里面去，做完处理之后，再输出到屏幕上。\nsed 的模式空间：即能被sed匹配到的字符串被存放到的内存空间。\n6. command prompt 命令提示符;\n7. subsystem 子系统，分系统;\n8. X11 forwarding \n9. 动态主机配置协议（Dynamic Host Configuration Protocol, DHCP）是一个局域网的网络协议，使用UDP协议工作，主要有两个用途：给内部网络或网络服务供应商自动分配IP地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段。\n10. SSH 为 Secure Shell 的缩写，由 IETF 的网络工作小组（Network Working Group）所制定；SSH 为建立在应用层和传输层基础上的安全协议。SSH 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH最初是UNIX系统上的一个程序，后来又迅速扩展到其他操作平台。SSH在正确使用时可弥补网络中的漏洞。SSH客户端适用于多种平台。几乎所有UNIX平台—包括HP-UX、Linux、AIX、Solaris、Digital UNIX、Irix，以及其他平台—都可运行SSH。\n11. archive 归档\n\n\n\n<pre>\nsu：Swith user  切换用户，切换到root用户\ncat: Concatenate  串联\nuname: Unix name  系统名称\ndf: Disk free  空余硬盘\ndu: Disk usage 硬盘使用率\nchown: Change owner 改变所有者\nchgrp: Change group 改变用户组\nps：Process Status  进程状态\ntar：Tape archive 解压文件\nchmod: Change mode 改变模式\numount: Unmount 卸载\nldd：List dynamic dependencies 列出动态相依\ninsmod：Install module 安装模块\nrmmod：Remove module 删除模块\nlsmod：List module 列表模块\nalias :Create your own name for a command\nbash :GNU Bourne-Again Shell  linux内核 \ngrep:global regular expression print\nhttpd :Start Apache\nipcalc :Calculate IP information for a host\nping :Send ICMP ECHO_Request to network hosts\nreboot: Restart your computer\nsudo:Superuser do\n \n\nFIFO = First In, First Out \nGRUB = GRand Unified Bootloader \nIFS = Internal Field Seperators \nLILO = LInux LOader \nMySQL = My最初作者的名字SQL = Structured Query Language \nPHP = Personal Home Page Tools = PHP Hypertext Preprocessor \nPS = Prompt String \nPerl = \"Pratical Extraction and Report Language\" = \"Pathologically Eclectic Rubbish Lister\" \nPython Monty Python's Flying Circus \nTcl = Tool Command Language \nTk = ToolKit \nVT = Video Terminal \nYaST = Yet Another Setup Tool \napache = \"a patchy\" server \napt = Advanced Packaging Tool \nar = archiver \nas = assembler \nbash = Bourne Again SHell \nbc = Basic (Better) Calculator \nbg = BackGround \ncal = CALendar \ncat = CATenate \ncd = Change Directory \nchgrp = CHange GRouP \nchmod = CHange MODe \nchown = CHange OWNer \nchsh = CHange SHell \ncmp = compare \ncobra = Common Object Request Broker Architecture \ncomm = common \ncp = CoPy \ncpio = CoPy In and Out \ncpp = C Pre Processor \ncups = Common Unix Printing System \ncvs = Current Version System \ndaemon = Disk And Execution MONitor \ndc = Desk Calculator \ndd = Disk Dump \ndf = Disk Free \ndiff = DIFFerence \ndmesg = diagnostic message \ndu = Disk Usage \ned = editor \negrep = Extended GREP \nelf = Extensible Linking Format \nelm = ELectronic Mail \nemacs = Editor MACroS \neval = EVALuate \nex = EXtended \nexec = EXECute \nfd = file descriptors \nfg = ForeGround \nfgrep = Fixed GREP \nfmt = format \nfsck = File System ChecK \nfstab = FileSystem TABle \nfvwm = F*** Virtual Window Manager \ngawk = GNU AWK \ngpg = GNU Privacy Guard \ngroff = GNU troff \nhal = Hardware Abstraction Layer \njoe = Joe's Own Editor \nksh = Korn SHell \nlame = Lame Ain't an MP3 Encoder \nlex = LEXical analyser \nlisp = LISt Processing = Lots of Irritating Superfluous Parentheses \nln = LiNk \nlpr = Line PRint \nls = list \nlsof = LiSt Open Files \nm4 = Macro processor Version 4 \nman = MANual pages \nmawk = Mike Brennan's AWK \nmc = Midnight Commander \nmkfs = MaKe FileSystem \nmknod = MaKe NODe \nmotd = Message of The Day \nmozilla = MOsaic GodZILLa \nmtab = Mount TABle \nmv = MoVe \nnano = Nano's ANOther editor \nnawk = New AWK \nnl = Number of Lines \nnm = names \nnohup = No HangUP \nnroff = New ROFF \nod = Octal Dump \npasswd = PASSWorD \npg = pager \npico = PIne's message COmposition editor \npine = \"Program for Internet News & Email\" = \"Pine is not Elm\" \nping =  Packet InterNet Grouper \npirntcap = PRINTer CAPability \npopd = POP Directory \npr = pre \nprintf = PRINT Formatted \nps = Processes Status \npty = pseudo tty \npushd = PUSH Directory \npwd = Print Working Directory \nrc = runcom = run command, shell \nrev = REVerse \nrm = ReMove \nrn = Read News \nroff = RunOFF \nrpm = RPM Package Manager = RedHat Package Manager \nrsh, rlogin, = Remote \nrxvt = ouR XVT \nsed = Stream EDitor \nseq = SEQuence \nshar = SHell ARchive \nslrn = S-Lang rn \nssh = Secure SHell \nssl = Secure Sockets Layer \nstty = Set TTY \nsu = Substitute User \nsvn = SubVersioN \ntar = Tape ARchive \ntcsh = TENEX C shell \ntelnet = TEminaL over Network \ntermcap = terminal capability \nterminfo = terminal information \ntr = traslate \ntroff = Typesetter new ROFF \ntsort = Topological SORT \ntty = TeleTypewriter \ntwm = Tom's Window Manager \ntz = TimeZone \nudev = Userspace DEV \nulimit = User's LIMIT \numask = User's MASK \nuniq = UNIQue \nvi = VIsual = Very Inconvenient \nvim = Vi IMproved \nwall = write all \nwc = Word Count \nwine = WINE Is Not an Emulator \nxargs = eXtended ARGuments \nxdm = X Display Manager \nxlfd = X Logical Font Description \nxmms = X Multimedia System \nxrdb = X Resources DataBase \nxwd = X Window Dump \nyacc = yet another compiler compile\n\n</pre>\n\n<pre>\nEOF = end of file(https://en.wikipedia.org/wiki/End-of-file)\nRPC = Remote Procedure Call(Remote Procedure Call (RPC) is a protocol that provides the high-level communications paradigm used in the operating system.)\n</pre>\n\n\n#### rpm\n- https://rpm.org/about.html\n- RPM软件包管理器（RPM）是一个强大的命令行驱动的软件包管理系统，能够安装、卸载、验证、查询和更新计算机软件包。\n- Install on RPM-based Linux (CentOS, Fedora, OpenSuse, Red Hat)\n\n#### dump\n- 备份文件系统\n- Fedora - https://installati.one/fedora/34/dump/\n\n#### lsbrelease\n- https://refspecs.linuxfoundation.org/LSB_3.0.0/LSB-PDA/LSB-PDA/lsbrelease.html\n\n\n#### telnet\n- 协议\n- TCP/IP协议族中的一员\n- Internet远程登陆服务的标准协议和主要方式\n\n#### netcat\nnc -l port\n\n#### 查目录名称\n- ls -l | grep ^d | awkj 'console.log($9)'\n\n\n#### kill pkill\n结束指定进程：kill [进程ID]\n按进程名结束进程：killall [进程名]\n需要注意的是，kill命令默认发送的是SIGTERM信号，也可以使用“-9”选项发送SIGKILL信号，但是SIGKILL信号不会给进程机会执行清理工作，直接终止进程可能会导致数据丢失等问题。\n\npkill命令则更加方便一些，它允许你使用进程名或者其他属性来选择要结束的进程，比如：\n结束指定进程名的进程：pkill [进程名]\n结束指定用户的所有进程：pkill -u [用户名]\n需要注意的是，pkill使用的也是SIGTERM信号，同样可以使用“-9”选项发送SIGKILL信号。\n\n\n### ack\n- apt-get install ack-grep\n- brew install ack\n- 搜索代码很好用\n\n\n### autojump\n- macos13 - brew安装会提示\n\n### lsb_release -a\n在Linux中，\"lsb_release -a\"这个命令被用来查看系统的相关信息。其中的\"lsb\"是\"Linux Standard Base\"的缩写，它代表了一套Linux系统的标准规范，旨在增强Linux的兼容性\n```\nLSB Version:    :core-4.1-amd64:core-4.1-noarch\nDistributor ID: CentOS\nDescription:    CentOS Linux release 8.5.2111\nRelease:        8.5.2111\nCodename:       n/a\n```","tags":["Linux系统使用系列"]},{"title":"zsh使用tips","url":"/2020/08/06/zsh使用tips/","content":"> 从 macOS Catalina 版开始，zsh (Z shell) 是所有新建用户帐户的默认 Shell。\nbash 是 macOS Mojave 及更低版本中的默认 Shell。(https://support.apple.com/zh-cn/HT208050)\n\n> 终端中输`man zsh` 即可了解更多，这篇主要聊聊 `oh my zsh` (指路官网: https://ohmyz.sh/)\n\n#### 安装\n```\nsh -c \"$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\"\n```\n\ntips:如果遇到了网络问题，可以配置下映射\n```\n199.232.68.133 raw.githubusercontent.com\n```\n\n> 即装即用，git马上就能自动补全分支名称了（为什么呢？）我们看下官方模块中的插件部分\n<pre>\ngit-auto-fetch\ngit-escape-magic\ngit-extras\ngit-flow-avh\ngit-flow\ngit-hubflow\ngit-prompt\ngit\ngitfast\ngithub\ngitignore\n</pre>\n再查看下.zshrc文件\n```\n➜  ~ cat .zshrc | grep git\n# See https://github.com/ohmyzsh/ohmyzsh/wiki/Themes\n# Example format: plugins=(rails git textmate ruby lighthouse)\nplugins=(git)\n```\n想要配置更多功能，把插件名字加到zshrc文件里面即可,空格隔开\n```\nplugins=(git gitignore)\n```","tags":["工具篇"]},{"title":"vscode插件使用合集","url":"/2020/08/06/vscode插件使用合集/","content":"### 当扩展很慢的时候\n- Developer：show running extensions (发现哪些导致慢)\n- https://code.visualstudio.com/updates/v1_32#_bundling-extensions-with-webpack?wt.mc_id=devto-blog-jopapa  - 官方提供了打包功能\n#### 写在前面\n调出——显示所有命令（cmd + shift + P）\n然后搜索 code\n选择 install code command in path \n这样就可以在shell中直接通过code xxx 调起vscode 来\n\n\n#### vscode常用快捷键：\n- 显示所有命令（cmd + shift + P）\n- 转到文件（cmd + P）\n- 在文件中查找（cmd + shift + F）\n- 开始调试（F5）\n\n#### Plugin: vscode-faker\n使用场景:\n目标，生成一行行的名字如下\n```\nexport default `\nAbbott\nTurner\nKutch\nReichert\nFunk\nMante\nHammes\nHowell\n`.trim().split(/\\s+/g)\n```\n用这些名字，生成一个name的数组，那么，怎么生成一行一个名字呢？\n\n<strong>vscode-faker</strong> + 多行选中功能\n\n1. 利用多行选择和faker\n2. alt+shift (先点击第一行，按完快捷键后，再点击最后一行)\n3. 再cmd+shift+p调出faker，选中要生成的类型即可\n\n####  Plugin: open in browser\n\n我的家里电脑的chrome浏览器之前点击open in browser 一直没有反应，升级了之后就好了（但是也是只在没有打开过浏览器页面的情况下生效\n\n那么open in browser or view in browser 的原理是什么呢？ 为什么会产生我家里电脑那种情况呢？\n\n插件评级星星边上有repository，可以通过这个点到github里面去看他们具体的实现\n```\nconst opn = require('opn');\n\nexport const open = (path: string, browser: string = '') => {\n  // const name = browser ? browser : standardizedBrowserName(defaultBrowser());\n  // const name = standardizedBrowserName(browser);\n  opn(path, { app: browser })\n    .catch(_ => {\n      vscode.window.showErrorMessage(`Open browser failed!! Please check if you have installed the browser ${browser} correctly!`);\n    });\n};\n```\n```\nhttps://www.npmjs.com/package/opn //opn链接，现已更名open\n```\n\nPS: 一般情况下，我要打开静态资源，会起个静态资源服务，就OK了，http-server\n\n#### svg viewer\n可以看svg图片\n\n\n#### koroFileHeader\n团队注释规范，可以制定好规范，提供配置给团队成员使用\n\n\n#### 插件推荐\nhttps://github.com/varHarrie/varharrie.github.io/issues/10","tags":["工具篇"]},{"title":"zoc7","url":"/2020/08/06/zoc7/","content":"\n> 平时上机器用**zoc7**, zoc7对于Mac系统的开发者来说，还是蛮好用的，之前scp传东西，操作比较繁琐，用iterm2通过设置来实现sz,rz命令的方案又并不是很好使，用了zoc7之后，上服务器的操作省了蛮多心的；\n\n\n#### 样式修改：\noptions=>edit session profile\n![](zoc71.png)\n\n#### 增加自定义的输入命令，比如我的通用的密码\nUser buttons: 里面 可以add\n![](zoc72.png)\n\n\n## 其他\nwindterm\ntabby - https://tabby.sh/ - 有点问题，连公司的，特别卡\nwarp - https://www.warp.dev/\n\nzen term macos平台，目前很好用，但是收费，可以使用lite版本的 - 不卡顿","tags":["工具篇"]},{"title":"npm-link来调试","url":"/2020/08/05/npm-link来调试/","content":"> 主体项目拆分出了UI库和核心逻辑js库，在UI库里面调试阶段，除了example，可能还得连具体代码，所以利用npm link进行调试\n\n在被引用的包项目里面运行，执行之后，被引用的包会被链接到全局，路径是 {prefix}/lib/node_modules/<package>\n```\nnpm link\n```\n在用包的项目里面运行,这样被引用的包会被链接到用包项目的node_modules下面\n```\nnpm link seal_topic_ui\n```\n\n之后，只要在被引用包里面有修改，修改会直接生效\n\n\n#### tips:查看prefix\n```\nnpm config get prefix\n```\n\n#### 最佳实践\n`npm link` 是一个非常有用的命令，它可以帮助开发者在本地开发和测试 Node.js 的模块或者 CLI 工具。`npm link` 可以在全局和本地项目之间创建一个符号链接，这使得开发者可以在不发布和安装 npm 包的情况下进行开发和测试。下面是一些使用 `npm link` 的最佳实践。\n\n1. 在开发模块时使用`npm link`：\n\n   首先，导航到要链接的项目目录：\n\n   ```\n   cd /path/to/your/module\n   ```\n\n   然后，在项目根目录下运行命令：\n\n   ```\n   npm link\n   ```\n\n   这将在全局 node_modules 目录下创建一个符号链接。（你可以通过运行 `npm root -g` 查找全局 node_modules 目录。）\n\n   接下来，在你的依赖模块项目中使用 `npm link your-module` 来创建一个指向刚刚链接的模块的符号链接。将 `your-module` 替换为模块的名称。\n\n   ```\n   cd /path/to/your/dependent/project\n   npm link your-module\n   ```\n\n   现在，在依赖项项目中，更改模块的代码和功能都会实时反映出来。\n\n2. 在开发 CLI 工具时使用`npm link`：\n\n   如果你正在开发一个 CLI 工具，则可以将其链接到全局路径，使其能够在本地生效。\n\n   ```\n   cd /path/to/your/cli/tool\n   npm link\n   ```\n\n   这时，你就可以在终端中使用这个命令（CLI 工具）了，任何对工具的更改都会即时更新。\n\n3. 从全局环境中取消链接：\n\n   如果你想从全局环境中删除链接，可以在 `npm link` 的反向操作中使用 `npm unlink` 命令：\n\n   ```\n   cd /path/to/your/module\n   npm unlink\n   ```\n\n   然后，在依赖目录中取消链接：\n\n   ```\n   cd /path/to/your/dependent/project\n   npm unlink your-module\n   ```\n\n4. 使用 .npmrc 配置文件：\n\n使用 `.npmrc` 配置文件可以轻松地将有关链接的配置应用于所需项目。例如，在全局 node_modules 目录中指定一个特定的位置。\n\n在以上示例中，在全局 npm 配置文件（你可以用 `npm config ls` 或者 `npm config edit` 找到它）的路径下添加以下行：\n\n```\nprefix = /path/to/your/custom\n     \n```\n\n5. `npm link` 时请注意版本冲突。因为 `npm link` 是在全局环境中创建了链接，确保在多个项目之间共享同一份代码时，不会引入不同版本的包。\n\n6. 为了避免安全问题，请不要在生产环境下使用 `npm link`。当你在生产环境部署代码时，请始终使用 `npm install`。`npm link` 的主要目的是为了在开发过程中提高效率和便利性。\n\n遵循这些最佳实践，你可以更高效地使用 `npm link` 进行 Node.js 项目的开发和测试。","tags":["npm 系列"]},{"title":"nginx配置问题处理","url":"/2020/08/03/nginx配置问题处理/","content":"> nginx（Engine X） 高性能的web服务器\n  排名指路：https://w3techs.com/technologies/cross/web_server/ranking\n  官网指路：http://nginx.org/en/\n\n<pre>\n轻量级： CPU，内存占用少（工作模式：进程池 + 单线程 => 消除了进程，线程切换的成本）\nOne master and several worker processes; worker processes run under an unprivileged user;\n（在进程之上，master进程用来管理进程池，监控进程，自动恢复发生异常的worker，保持进程池的稳定和服务能力）\ncite: https://time.geekbang.org/column/article/117492\n</pre>\n#### nginx - 作为web代理服务器 - 负载均衡，流量切换 - lua的脚本支持\n```\n- 对session和cookie的处理较弱\n- 支持的协议有限（http）\n- lua脚本的变更和nginx配置的修改需要重新启动，无法热更新\n- 无可视化配置页面\n```\n- 可以作为流量网关，nginx层流量代理，负载均衡到Gateway做业务层的转发处理\n\n#### nginx 怎么找\n1. ps -ef | grep nginx (ps:显示系统进程)\n2. whereis nginx 软件安装路径(whereis -- locate programs;The whereis utility checks the standard binary directories for the specified programs, printing out the paths of any it finds.The path searched is the string returned by the sysctl(8) utility for the ``user.cs_path'' string)\n3. which nginx 运行文件所在路径(which -- locate a program file in the user's path;The which utility takes a list of command names and searches the path for each executable file that would be run had these commands actually been invoked.)\n4. cd / && find - name 'nginx.conf'\nnginx.conf => 基本的\nvhost => 应用的\n\n#### nginx 403\n```\nchmod -R 777\nps aux | grep \"nginx: worker process\" | awk '{print $1}'\n```\n<pre>\nnginx \nroot\n</pre>\n\n`vim nginx.conf`把 user  改成 root,即可;\n\n#### firekylin nginx\n```\nln -s /root/firekylin/nginx.conf /etc/nginx/conf.d/firekylin.conf\n```\nnginx.conf里面：\n```\nln -s是一个Linux/Unix命令，用于创建软链接（Symbolic Link或称为Symlink）。软链接是一种类似于Windows系统中快捷方式的文件，它指向另一个文件或目录。其中，源文件或目录可以是绝对路径或相对路径，也可以是一个完整的URL。软链接可以跨越不同的文件系统，而硬链接只能在同一文件系统中使用。\n\n软链接的用途：\n\n- 简化文件路径名称\n- 提高文件管理的灵活性与安全性\n- 简化开发与维护工作\n\n软链接的语法为：\n\n```\nln -s source_file link_file\n```\n\n其中，source_file是源文件或目录的路径，link_file是链接文件的路径。执行此命令后，link_file将指向source_file，并且可以作为source_file的别名在系统中使用。\n```\n\n<pre>\n~   #波浪线表示执行一个正则匹配，区分大小写\n\n# location ~ /static/ {\n# etag  on;\n# expires  max;\n# } \n</pre>\n\n把     \n<pre>\n# etag  on;\n# expires  max;\n</pre>\n\n都注释了，还是403\n\n把`location ~ /static/ {}`\n也注释了，就生效了\n\n文档指路：http://nginx.org/en/docs/beginners_guide.html\n\n\n#### kill nginx 服务\nnohup = No HangUP\n```\nps -ef|grep nginx\ncd /usr/local/nginx/sbin\nls\n./nginx -t\n./nginx -s reload\n\nkill -QUIT 28761\nnohup /usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf \ntail -2000f nohup.out\nps -ef|grep nginx\n# 日志\n# reload无效的时候\n```\n\n#### 前端history路由模式\n```\nlocation / {\n  try_files $uri $uri/ /index.html;\n}\n```\n\n\n\n#### 正则匹配\n\n#### http server优先级\n\n线上出过一个问题，之前一直没生效的CXP的配置生效了；原因是server优先级高于http,修改了server里面的一些跨域的配置；\n\n## 应用场景\n### 本地起nginx代理解决资源跨域或者连本地服务调试（嵌入移动端的页面）问题\n```\nnginx -v # 查看本机是否安装nginx, 如果没有安装homebrew安装下；\nbrew info nginx # 可获得nginx文件的配置位置\ncd /usr/local/etc/nginx\ncode nginx.conf # 打开nginx配置文件\n# 增加nginx server 80 下面的配置，这样test.company.cn就会访问到本地我们起的http://127.0.0.1:8886服务上 \nhttp {\n    include       mime.types;\n    default_type  application/octet-stream;\n\n   log_format  main  '$remote_addr - $remote_user [$time_local] \"$request\" '\n                      '$status $body_bytes_sent \"$http_referer\" '\n                      '\"$http_user_agent\" \"$http_x_forwarded_for\"';\n    server_names_hash_bucket_size 128;\n    client_header_buffer_size 32k;\n    large_client_header_buffers 4 32k;\n    client_body_buffer_size    8m;\n    server_tokens off;\n    ignore_invalid_headers   on;\n    recursive_error_pages    on;\n    server_name_in_redirect off;\n    sendfile        on;\n    tcp_nopush     on;\n    tcp_nodelay    on;\n    #keepalive_timeout  0;\n    keepalive_timeout  65;\n    server {\n        listen 80;\n        server_name test.company.cn;\n\n        location / {\n            proxy_pass http://127.0.0.1:8886;\n        }\n    }\n}\n# 修改系统hosts:\n127.0.0.1 test.company.cn\n127.0.0.1 localhost\n\n# 这样，在浏览器里面输入test.company.cn就可以访问我们本地起的服务 http://127.0.0.1:8886 了；\n```\n\n### tengine\n- http://tengine.taobao.org/\n旧项目，接口server\nServer: Tengine/2.2.3\n\n新项目：接口server\nServer: openresty/1.15.8.3\n\n### 301\n```\ncurl -i 'https://xxxx/qqq/thursday/xxxx'\nHTTP/1.1 200 Connection established\n\nHTTP/1.1 301 Moved Permanently\nServer: nginx\nDate: Thu, 21 Apr 2022 08:55:36 GMT\nContent-Type: text/html\nContent-Length: 169\nConnection: keep-alive\nLocation: http://xxxx/qqq/thursday/xxxx/\nAccess-Control-Allow-Origin: *\nAccess-Control-Allow-Credentials: true\nAccess-Control-Allow-Methods: GET, POST, OPTIONS\nAccess-Control-Allow-Headers: DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type\nCache-Control: no-cache\n\n<html>\n<head><title>301 Moved Permanently</title></head>\n<body>\n<center><h1>301 Moved Permanently</h1></center>\n<hr><center>nginx/1.18.0</center>\n</body>\n</html>\n\n```\n- 因为测试环境，前端多个项目配置了一个规则，规则这么配置的\n```\nlocation ~* ^/(qqq|xxx|xxxe|)/(env1|env2|env3|env4)/?(\\w*) {\n                root /neworiental/latest/;\n                add_header 'Access-Control-Allow-Origin' '*';\n                add_header 'Access-Control-Allow-Credentials' 'true';\n                add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS';\n                add_header 'Access-Control-Allow-Headers' 'DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type';\n                add_header 'Cache-Control' 'no-cache';\n                index index.html; \n                try_files $uri $uri/ /$1/$2/$3/index.html;\n        }\n```\n- 这个时候，如果https://xxxx/qqq/thursday/xxxx 后面不加“/”，不是 https://xxxx/qqq/thursday/xxxx/ 的话，则会被重定向，因为nginx匹配规则有问题\n\n\n## 配置实践\n- 入口 html 文件设置 no-cache，其他资源文件设置 max-age 的缓存方式\n- best-practice\n\n#### 参考阅读\n- https://mp.weixin.qq.com/s/0P8_lnVf2_zMzIBJ20qajA","tags":["nginx"]},{"title":"mysql-emoji表情支持","url":"/2020/08/01/mysql-emoji表情支持/","content":"> 单位遇到的一个服务端解决的小问题，怎么存表情符号\n\n### 推荐阅读\n- https://www.yuque.com/antfe/featured/meaiwxzy9h4ztshl#p56EL\n- 讲了emoji编码和如何处理emoji\n\n###\n- https://unicode.org/Public/emoji/15.0/emoji-sequences.txt","tags":["mysql"]},{"title":"node错误信息分析","url":"/2020/07/24/node错误信息分析/","content":"> 运行命令的时候，经常会报错，怎么处理这些错误呢？\n\n#### example1:\n```\n➜  hah git:(master) ✗ hexo server\n(node:64862) ExperimentalWarning: The fs.promises API is experimental\nFATAL { [Error: EEXIST: file already exists, mkdir '/Users/xxx/hah']\n  errno: -17,\n  code: 'EEXIST',\n  syscall: 'mkdir',\n  path: '/Users/xxx/hah' }\n```\n\n##### nodejs 错误查询指路（官方文档）：\n\n中文：http://nodejs.cn/api/errors.html#errors_error_code\n英文：https://nodejs.org/api/errors.html#nodejs-error-codes\n\n##### nodejs 错误查询指路（代码指路）：\n选择所使用的版本的tag\nnode/deps/uv/include/uv.h\n![nodepath](nodepath.png)\n\nnode/deps/uv/include/errno.h\n\n##### 发现是系统错误：\nmanual指南：https://man7.org/linux/man-pages/man3/errno.3.html\n\n##### 查了下文档\n为什么会抛这个系统错误呢，初步估计可能和node版本相关，便查了下hexo的文档\n<pre>\nNode.js (Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本)\n➜  blog git:(master) ✗ node --version\nv10.10.0\n</pre>\n所以得升级node版本\n- hexo trouble shooting - https://hexo.io/docs/troubleshooting.html\n\n#### 一些基本操作\nnode退出：ctrl+C(两次) ctrl+D(两次) .exit\n\n### 项目配置\nhttps://nodejs.org/api/report.html\n可以导出文件\n增加 --json >stats.json\n\n\n\n"},{"title":"three-virtues","url":"/2020/07/22/three-virtues/","content":"\n> According to Larry Wall(1), the original author of the Perl programming language, there are three great virtues of a programmer; Laziness, Impatience and Hubris\n\n- Laziness: The quality that makes you go to great effort to reduce overall energy expenditure. It makes you write labor-saving programs that other people will find useful and document what you wrote so you don't have to answer so many questions about it.\n- Impatience: The anger you feel when the computer is being lazy. This makes you write programs that don't just react to your needs, but actually anticipate them. Or at least pretend to.\n- Hubris: The quality that makes you write (and maintain) programs that other people won't want to say bad things about.\n\n## 实然 ｜ 应然\n\n## notes - 饿了么\n- 云计算 - 表面是技术，内核是业务，因为有商业价值\n\n- 技术核心价值 - 1.对于验证成功或者接近成熟的业务，做Scale，快速规模化（1-10，20-100） 2.帮业务团队快速试错\n\n- 低代码 -> 另一种方式的体力活\n\n- 抽象业务｜抽象组织 - 抽象能力\n\n- 邮件 - 通知｜存档｜文明吵架哈哈哈哈\n\n- 倾听者\n\n- 工程师 - 纯粹！\n\n- 控制情绪，消化情绪（时间稀释）\n\n- work around -》 补偿机制\n\n- 业务时判断耦合还是内聚的依据（高内聚-业务形态）\n\n- avoid solving problem by creating a bigger one \n\n- 活下来 -> architecture -> scale\n\n- 当然，上面不适合技术驱动的情况\n\n- 拆分与否 - 牵一发而动大部分的时候，就有问题了\n\n- 单体是个极端；微服务或者单一原则是另外一个极端\n\n- 从业务的合理性去拆分\n\n- 逻辑角度｜数学角度\n\n- 中台就是业务驱动的\n\n\n### photography\n- 距离的驾驭 - 半画幅比全画幅相对自由\n- 大字难于结密而无间，小字难于宽绰而有余\n\n\n### story\n- 用故事来构建产品的意义\n\n### 决策逻辑\n- 标准化的探索成本巨大\n- 运营和消费互联网技术的结合很难，涉及线上和线下，各个环节的耦合\n- 产业标准化 - 标准数字化 - 数字智能化\n- 业务理解力 - 产业，业态，公司，项目\n- 成本到最后是一个固定成本，可以忽略\n\n#### make yourself indispensable by contributing honestly\n- find your way","tags":["方法论-科学哲学-map"]},{"title":"谈谈debug","url":"/2020/07/06/谈谈debug/","content":"\n\n#### vscode中debug\n#####  原理说明： vscode把debug功能的实现交付给插件完成的（vscode提供了Debug Adapter Protocol —— DAP）\n插件=>把调试和vscode的界面和交互结合\nvscode=》用户在界面的操作，vscode通过DAP唤起插件，插件完成最终的操作\n\n文档指路：\nhttps://microsoft.github.io/debug-adapter-protocol/\nhttps://code.visualstudio.com/api/extension-guides/debugger-extension\n\n\n##### 操作指南\n- cmd + shift + D \n- 点击调试按钮，选择环境\n\n\n#### ndb-firekylin调试\nhttps://zhuanlan.zhihu.com/p/41315709\n\n\n#### Vue相关问题快速排查之debug\n\n涉及一些Vue本身相关的问题，首先查文档，略微查下源码，能解决的就解决了；还是有疑问的，对相关疑问点进行debug调试\n\n\n借助vue-cli3：\nhttps://cli.vuejs.org/zh/guide/prototyping.html\n快速原型开发\n你可以使用 vue serve 和 vue build 命令对单个 *.vue 文件进行快速原型开发，不过这需要先额外安装一个全局的扩展：\nnpm install -g @vue/cli-service-global\nvue serve 的缺点就是它需要安装全局依赖，这使得它在不同机器上的一致性不能得到保证。因此这只适用于快速原型开发。\n#\nvue serve\nUsage: serve [options] [entry]\n\n在开发环境模式下零配置为 .js 或 .vue 文件启动一个服务器\n\n\nOptions:\n\n  -o, --open  打开浏览器\n  -c, --copy  将本地 URL 复制到剪切板\n  -h, --help  输出用法信息\n你所需要的仅仅是一个 App.vue 文件：\n<template>\n  <h1>Hello!</h1>\n</template>\n然后在这个 App.vue 文件所在的目录下运行：\nvue serve\nvue serve 使用了和 vue create 创建的项目相同的默认设置 (webpack、Babel、PostCSS 和 ESLint)。它会在当前目录自动推导入口文件——入口可以是 main.js、index.js、App.vue 或 app.vue 中的一个。你也可以显式地指定入口文件：\nvue serve MyComponent.vue\n如果需要，你还可以提供一个 index.html、package.json、安装并使用本地依赖、甚至通过相应的配置文件配置 Babel、PostCSS 和 ESLint。\n\n\ntemplate文件：\n开发的ide是vscode,所以可以安装相应的snippets\n\n1.可以有一些插件\n2.可以自定义用户snippet（https://code.visualstudio.com/docs/editor/userdefinedsnippets）\n There is also support for tab-completion: Enable it with \"editor.tabCompletion\": \"on\", type a snippet prefix (trigger text), and press Tab to insert a snippet.\n(可以增加如下配置)\n\n#### node-assert\nwebpack-debug\n\nDevTools=>Devices=>Target build/build.js\n\n\n#### ndb\nndb\nhttps://chromedevtools.github.io/devtools-protocol/\n\n#### 平台｜环境｜工具｜方法\n- 浏览器，hybrid，nodejs,小程序，electron\n- local| online\n- chrome devtools | charles | spy-debugger | whistle | vConsole\n- console | breakpoint | sourceMap | proxy\n\n## chrome\n#### 动态修改样式\n- .cls\n- computed -> 跳转到styles\n- 强制激活伪类 - 选中具有伪类的元素 点击:hov\n- 强制激活伪类 - DOM树右键菜单，选择Force State\n#### console\n- .table 和 .dir 可根据场景，选择打印，方便观察\n- %d %o %s %c 占位符- 字符串替换 - 增加样式，格式\n\n#### sourcemap\n- mappings => 映射 https://www.murzwin.com/base64vlq.html\n\n#### performance\n- frames帧线程\n- main主线程，JS执行｜html/css解析，完成绘制\n- raster 完成某个layer或者tile的绘制\n- https://googlechrome.github.io/devtools-samples/jank/\n- FPS | CPU | NET - 概览分析，看性能节点\n\n#### lighthouse\n- LCP - 加载性能\n- FID - 交互性\n- CLS - 视觉稳定性","tags":["debug+proxy篇"]},{"title":"Firekylin重建记","url":"/2020/07/03/Firekylin重建记/","content":"\n1. 博客因为mysql部分开放了远程访问，密码过于简单，导致被清库了；无库备份，或者sql执行语句的日志，所以之前的都没了。\n\n2. 之后每篇博客都先notability里面写好，再上传firekylin的管理端\n\n3. give me a lesson:安全很重要，备份很重要；自己搭的博客系统里面，不要使用自己的通用密码等信息，防止被攻击后，泄露重要信息；赶紧给自己的notability也给做了个备份，万一iCloud出问题了，可就真的是所有资料都没有了\n\n4. 也借着这个机会，重新整理下博客，提高质量\n\n\n\n> Continue----\n1. 删除了mysql远程可登陆的账号后，还是又被清了库，推测被植入了程序，准备重装机器\n\n#### 重装系统之后，安装基础的：\n\n1. nodejs\n```\ncurl --silent --location https://rpm.nodesource.com/setup_8.x | sudo bash -\nyum -y install nodejs\n```\n\n然后\n```npm i -g n```\n\nn lts\n\n2. pm2\n```npm install pm2 -g```\n\n\n3. mysql\n```\nwget http://dev.mysql.com/get/mysql-community-release-el7-5.noarch.rpm\nrpm -ivh mysql-community-release-el7-5.noarch.rpm\nyum install mysql-community-server -y\n```\n\n启动mysql服务：\n```service mysqld restart```\n\n设置root密码：\n```/usr/bin/mysqladmin -u root password 'hahaGG89@Firekylin'```\n\n\n4. 安装nginx:\nyum install nginx -y\n\n\n5. 安装git:\nyum install git -y\n\n走仓库版安装：\nhttps://github.com/firekylin/firekylin/wiki/%E4%BB%93%E5%BA%93%E7%89%88%E5%AE%89%E8%A3%85\n\n放弃本地所有提交：\ngit checkout .\n\n\n#### firekylin 本身安全问题加强：url legacy && whatwg url\n （代码提交变更）\n\n\n #### firekylin startup代码解析\n 启动完成后，在浏览器里输入 http://localhost:8360/ 即可访问首页填写配置信息\n使用浏览器直接访问你的Blog地址即可看到 Firekylin 的安装程序。填入你的 MySQL 信息并设置好管理员账号后点击完成。\n\n基于firekylin的代码对这个过程进行一个详细解析：\n\n\n\n#### CSDN博客导出到firekylin的思路\n看了看有64篇，因为想导出很久以前这个系列，保留发布时间，对内容做一些删减，所以找一个快速的方法来处理\n\n1.比较老的文章，在文章管理点开是富文本编辑器\n2.新一点的，在文章管理点开是md文件\n\n\n拿到的东西\n1.最优：直接处理了直接插库\n2.拿到格式合适的一篇篇的添加文章（那还不如直接复制粘贴加审阅）\n\n","tags":["安全篇"]},{"title":"input-file的type-图像篇","url":"/2020/06/06/input-file的type-图像篇/","content":"![](inputfile.png)\nhttps://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/file\n\n## basic\n### File API\n- https://w3c.github.io/FileAPI/\n- https://juejin.cn/post/6857065289532735502\n### 超好用的Blob对象\nhttps://github.com/akira-cn/FE_You_dont_know/issues/12\n\n\n\n## 其他\n- https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/Input\n- input的type为search\n- 用于搜索字符串的单行文字区域。输入文本中的换行会被自动去除。在支持的浏览器中可能有一个删除按钮，用于清除整个区域。拥有动态键盘的设备上的回车图标会变成搜索图标\n- 如果想去除X，可以通过样式设置\n```\ninput::-webkit-search-cancel-button,\ninput::-ms-clear {\n  display: none;\n}\ninput[type=search] {\n    -webkit-appearance: none;\n}\n```\n- form \n```\naction\n处理表单提交的 URL。这个值可被 <button>、<input type=\"submit\"> 或 <input type=\"image\"> 元素上的 formaction 属性覆盖。\n```","tags":["基础篇"]},{"title":"Vue组合式API","url":"/2020/05/21/Vue组合式API/","content":"> 使用场景：抽取的公共项目写example的时候会用\n\n\n#### 引用方式\n```\ndependencies:\n    \"@vue/composition-api\" \"^0.5.0\"\n```\n<pre>\n\"@vue/composition-api@^0.5.0\":\n  version \"0.5.0\"\n  resolved \"http://XXX/repository/npmjs.org/@vue/composition-api/-/composition-api-0.5.0.tgz#2dbaa02a5d1f5d0d407d53d5529fe444aa8362f3\"\n  integrity sha1-LbqgKl0fXQ1AfVPVUp/kRKqDYvM=\n  dependencies:\n    tslib \"^1.9.3\"\n</pre>\n```\nimport Vue from 'vue'\nimport VueCompositionAPI from '@vue/composition-api'\n\nVue.use(VueCompositionAPI)\n// 使用 API\nimport { ref, reactive } from '@vue/composition-api'\n```\n","tags":["工作经验总结系列","Vue杂谈"]},{"title":"Vue杂谈","url":"/2020/05/20/Vue杂谈/","content":"> 最近招人不太好招，稍微平衡了下标准，具体应用OK的也可，负责的项目以Vue为主，Vue部分会拉着几个官方文档问，比较好做分层\n\n### 2.x我会问的一些问题\n\n- vue-cli 本身这边有xxx-cli,所以看见简历上有写vue-cli的，会分两部，是否有写过 ？ 写过=>具体经验和设计的问题 ： 没有=>拉着文档（https://cli.vuejs.org/zh/guide/plugins-and-presets.html#%E6%8F%92%E4%BB%B6）问一些问题\n    - 有没有开发过插件，着重经验和思考（https://cli.vuejs.org/zh/dev-guide/plugin-dev.html）   \n    - 更深：对基于插件架构的理解\n    - 对于vue-cli的依赖的分析\n\n- vue-router history || hash ，历史模式的话会问一些配置问题，hash模式会问下原理，都蛮有意思的，可拓展性很强；文档（https://router.vuejs.org/zh/guide/essentials/history-mode.html#%E5%90%8E%E7%AB%AF%E9%85%8D%E7%BD%AE%E4%BE%8B%E5%AD%90）\n\n- 跨域问题，着重经验及对此类问题是否有探究和思考（ https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS）聊得有趣的可以更深入了解下计网的基础\n\n- https://cn.vuejs.org/v2/guide/components-edge-cases.html#%E8%AE%BF%E9%97%AE%E5%AD%90%E7%BB%84%E4%BB%B6%E5%AE%9E%E4%BE%8B%E6%88%96%E5%AD%90%E5%85%83%E7%B4%A0\n文档：\n> 这里记录的都是和处理边界情况有关的功能，即一些需要对 Vue 的规则做一些小调整的特殊情况。不过注意这些功能都是有劣势或危险的场景的。我们会在每个案例中注明，所以当你使用每个功能的时候请稍加留意。\n代码评审的注意下这部分提到的使用的界限\n\n- 实现一个全选功能，看看对数据驱动思维的理解程度，具体到API层面，可以利用computed（get, set）来实现，还能利用好这个API的缓存优化特性；\n\n- 逻辑完备性 - 条件渲染处理数据有无场景\n\n\n## retiring 系列\n- vue-resource - 可以看看官方发的文章，为什么要retiring it\n\n\n## review\n#### 2022 year in review\n- vapor mode : Vapor Mode是我们一直在尝试的另一种编译策略，其灵感来自Solid。给予相同的Vue SFC，Vapor Mode将其编译成JavaScript输出，与当前基于Virtual DOM的输出相比，性能更强，使用的内存更少，需要的运行时支持代码更少。\n- https://blog.vuejs.org/posts/2022-year-in-review\n\n### 网站分析\n- https://web-check.xyz/","tags":["工作经验总结系列","Vue杂谈"]},{"title":"thinkJS有感","url":"/2020/05/19/thinkJS有感/","content":"#### require-context\n\n#### split(/\\s*,\\s*/)\n\n#### symbol && string\n- https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/iterator\n- Symbol.iterator为每一个对象定义了默认的迭代器。该迭代器可以被 for...of 循环使用 \n\n## docker\n- https://zhuanlan.zhihu.com/p/37082611\n- https://github.com/thinkjs/cn.thinkjs.org/blob/bbd47c35e2e03e048e38b8891f18ce350bde27a9/3.0/deploy.md#docker","tags":["thinkJS"]},{"title":"minimal-coffee","url":"/2020/05/19/minimal-coffee/","content":"## coffee terms\n\n\n## Eureka mmg 意式调磨\n### 清零法\n- 拿掉电源，拿下豆仓\n- 旋钮顺时针扭动到比较紧，同时摸着中间的螺丝感受，直到中间螺丝无法转动\n- 这个时候，回调半格为0刻度\n- 从0刻度，再回调1-2格为意式研磨度，具体按照萃取结果进行微调\n\n### 残粉\n- 每次前1-2s不要，然后再接\n\n## Rancilio Sliva 基本配置\n### basket size\n- the baskets come with the v6 are 7g and 14g\n- 7g - 40-100-101 - model number\n- 14g - 40-100-102 - model number\n- 18g - 40-100-103 - model number\n- 8g - 40-100-106 - model number\n- 16g - 40-100-107 - model number\n\n\n### 使用注意\n- 先开冲煮键，再按电源开关\n- 蒸汽使用快要结束时，关闭蒸汽键，然后再关闭蒸汽旋扭，再按热水键，放出热水，直到加热灯亮起，防止锅炉过热\n\n## espresso\n### 机器的清洁和保养！！！\n\n### 粉量\n- 多了，7，8秒才出液，30s总萃取液量少\n- 少了，3秒就喷，30秒总萃取液体量多\n- 正常5秒左右出液\n- 粉多了 - 粉饼干，瓷实\n\n### 研磨度\n- 过细 - 30S总萃取量少，且苦味杂味重 - 不流，苦，味道杂\n- 过粗 - 过萃的黑水，出液喷出来那种 - 喷，量大，味道淡，风味不明显\n- 正常 - 风味平衡，流速油状\n\n### 填压手法和力度\n- 力道垂直，有一定力道\n- 具体手法\n- 一把平，压一下，转一下\n- 压粉力度重：歪，萃取时不流\n- 压粉力度轻：萃取不足，喷了\n\n### 水温\n- rancilio sliva 的话，蒸汽用过之后如果萃取，要先放水，降温，避免过热\n- 水温高： 液体颜色深 - 过苦，焦糊味，烟熏\n- 水温低： 泡沫少 - 口感寡淡，酸，涩，风味不明显\n\n### baristahustle\n- https://www.baristahustle.cn/info/13 产出量\n- https://www.baristahustle.cn/info/12 浓度\n- https://www.baristahustle.cn/info/11 粉量\n\n## the world atlas of coffee - summary \n### intro\n- commodity coffee | speciality ","tags":["coffee"]},{"title":"git总结","url":"/2020/05/18/git总结/","content":"\n> 每天和 git 打交到的时间算是前几位了，总结一些问题，不断更新。。。\n\n- 技术层面 git help XXX 能解决几乎所有疑惑，经验方面，遇到和解决的问题越多，思考也就越多；团队管理和规范推行方面，充分尊重工程师的感受，考虑团队的情况\n\n#### 看过很多项目，或者解决定位线上问题 —— 快速清理无用的调试工作区\n\n```\ngit clean\ngit checkout --\n```\n\n#### 二分查找，定位问题commit\n-  git bisect \n\n#### gitlab 项目管理\n\n分支保护（代码提交合并权限问题）\n\nsettings => repositoryprotected branches => expand\n\nhttps://mirrors.edge.kernel.org/pub/software/scm/git/docs/git.html\n\ngitlab continuous integration\n/settings/integrations\n\n#### 分支名称自动补全\n\n指路：https://ohmyz.sh/（oh my zsh）\n\n#### git 清除本地无远端的分支（清除本地所有分支）\n\n- 强制删除所有分支\n  `git branch |xargs git branch -D`\n\n- 本地修改过未提交的不会删除\n  `git branch |xargs git branch -d`\n\n#### 迁了一次仓库，团队人员变迁，所以目前一些项目的文档和说明及 package.json 不是很准确\n\ngit remote show origin\n\n#### rebase/merge\n\n推 rebase 的经验，可以写一篇小论文了。。。\nrebase 伴侣 => --force-with-lease\n\n文档指南：\n重写历史的时候可以使用的命令及需要注意什么\nhttps://git-scm.com/book/en/v2/Git-Tools-Rewriting-History\n\n- merge\n- https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E9%AB%98%E7%BA%A7%E5%90%88%E5%B9%B6\n\n#### git 报错分析\n\n```\nerror: src refspec master does not match any.\nerror: failed to push some refs to 'https://github.com/anitakym/blog.git'\n```\n\n没有提交内容，要 add 和 commit （引起该错误的原因是，目录中没有文件，空目录是不能提交上去的）\n\n### 重写历史需注意\n\nhttps://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E9%87%8D%E5%86%99%E5%8E%86%E5%8F%B2\n\n### github/gitlab\n\n```\ncurl -s <github_url> | vim -\n```\n\n通过管道把 curl 命令的输出传给 VIM，以方便在 VIM 中查看较长的输出。\n\n### 好用的命令行工具\n\ntig(https://jonas.github.io/tig/)\n\n```\nbrew install tig\n```\n\n### 查看 working tree 的状态\n\ngit-status - Show the working tree status\n切换分支的时候，注意查看\n\n### gitk(the git repository browser)\n\nhttps://git-scm.com/docs/gitk/\n\n### .gitignore 规则生效\n\n如果一旦纳入版本管理，可以先删除本地缓存，然后提交\n\n```\ngit rm -r --cached .\ngit add .\ngit commit -m 'update .gitignore'\n```\n\n.gitignore 参考\nhttps://docs.github.com/en/github/getting-started-with-github/getting-started-with-git/ignoring-files\n\n### 导出某个项目的作者\n\n```\n\"authors\": \"git log --format='%aN <%aE>' | sort -u > AUTHORS\"\n```\ngit shortlog -s -n\n### 新建项目\n\nrm -rf .git\n\n### 项目过大问题，或者误提交大文件\n\n```\n# 找出大文件\ngit verify-pack -v .git/objects/pack/pack-*.idx | sort -k 3 -g | tail -5\n# 找出对应文件位置名称，XXX为第一步查出来的第一列的hash\ngit rev-list --objects --all | grep XXXXXXXXXXXX\n# 用filter-branch 清理文件\ngit filter-branch --index-filter 'git rm --cached --ignore-unmatch <your-file-name>'\n# 系列操作\nrm -rf .git/refs/original/\ngit reflog expire --expire=now --all\ngit fsck --full --unreachable\ngit repack -A -d\ngit gc --aggressive --prune=now\ngit push --force [remote] master\n```\n\n### 跨项目关联推送分支\n\nA 是模版项目\nB 是用了模版项目的业务项目\n\n- 模版项目 A 更新了基础配置，可以切一个分支，feature/update-basic\n- 在 B 中也新建一个分支 feature/update-basic\n- 将 A 的远端源切换成 B\n- 推送本地 feature/update-basic 分支到远端即可\n\n### 修改提交 message\n\n切记，如果推送到了远端，保证一定不是协作分支，不然最好确保都是本地操作\n\n```\n# 显示倒数n次的commit msg\ngit rebase -i HEAD~n\n# 要修改哪个，就把pick改成edit\ngit commit --amend\n# 改完之后保存并退出\ngit rebase --continue\n```\n\n### commit message\n```\nhttps://www.npmjs.com/package/@commitlint/config-conventional#type-enum\n```\n### 关联远端仓库\n```\n# 先查看下\ngit remote -v\n# 再设置\ngit remote remove origin\ngit remote add origin xxx\n# 都可\ngit remote set-url origin xxx\n```\n注意区分上面的概念\n```\n用git remote add <name> <url>添加一个远程仓库，其中name可以任意指定（对应上面的origin部分）\n不额外添加远程仓库，而是给现有的远程仓库添加额外的URL。使用git remote set-url -add <name> <url>，给已有的名为name的远程仓库添加一个远程地址\n```\n上面两个操作，对应pull，push的时候，操作不一样，因为pull，push的时候需要指定repo\n### tag\n文档指路：https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E6%89%93%E6%A0%87%E7%AD%BE、\n```\n# 引自文档\nGit 支持两种标签：轻量标签（lightweight）与附注标签（annotated）。\n\n轻量标签很像一个不会改变的分支——它只是某个特定提交的引用。\n\n而附注标签是存储在 Git 数据库中的一个完整对象， 它们是可以被校验的，其中包含打标签者的名字、电子邮件地址、日期时间， 此外还有一个标签信息，并且可以使用 GNU Privacy Guard （GPG）签名并验证。 通常会建议创建附注标签，这样你可以拥有以上所有信息。但是如果你只是想用一个临时的标签， 或者因为某些原因不想要保存这些信息，那么也可以用轻量标签。\n```\n```\n# annotated\ngit tag -a v1.0.1 -m \"for sth, update sth\"\ngit show v1.0.1\n# lightweight\ngit tag v1.0.2\ngit tag\n# 对某个提交打标签\ngit tag -a v1.0.3 xxxxx-commit-hash\n# 推送\ngit push origin --tags\n# 删除\ngit tag -d v1.0.1\ngit push origin --tags\n# 删除\ngit push origin --delete v1.0.1\n\n```\n\n### husky\n```\n\"lint-staged\": {\n    \"*.js\": [\n      \"prettier --write\",\n      \"eslint --fix\",\n      \"git add\"\n    ]\n  },\n  \"pre-commit\": \"lint:staged\"\n```\n### yorkie\n- \"githooks management forked from husky\"\n- \"authors\": [\n    \"Typicode <typicode@gmail.com>\",\n    \"Evan You\"\n  ],\n\n## .git\n```\n# v8 - README.md\nFor fetching all branches, add the following into your remote\nconfiguration in `.git/config`:\n\n        fetch = +refs/branch-heads/*:refs/remotes/branch-heads/*\n        fetch = +refs/tags/*:refs/tags/*\n```\n\n## git branch \n- https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF\n- git branch -vv\n\n## Divergent history\ngit log --oneline --decorate --graph --all\n## 工具\n### sourcetree\n#### 搜索某个人提交\nView - Search View - User\ngit log --author==\"xxxx\"\n\n\n### github\n快捷键： t , w  快速进入搜索\n\n### resolving Deltas\n- https://stackoverflow.com/questions/4689844/what-is-git-actually-doing-when-it-says-it-is-resolving-deltas\n- 解压和校验整个 repo 数据库\n\n### tfs\n- tfs 删除仓库,版本控制,先把自己添加到用户里面，再给自己加上删除的权限，就可以删除了\n\n#### 不想cd到具体目录，但是想查信息\n```git -C \"/Users/xxxx/Development/Projects/xxx/xxxx\" status === git --work-dir=\"/Users/xxxx/Development/Projects/xxx/xxxx\" --git-dir=\"/Users/xxxxx```\n\n#### git prune\nerror: The last gc run reported the following. Please correct the root cause\nand remove .git/gc.log.\n\ngit prune && git gc # Remove loose objects\ngit fsck --lost-found\n\n#### sourcetree 里面我这边自动开了推送所有的tags\n```\n--tags\nAll refs under refs/tags are pushed, in addition to refspecs explicitly listed on the command line.\n```\n`git push --tags`\n推送所有tags\n\n`git help tag`\n`git help push`\nnpm list -g --depth 0\n\n#### GitStats - git history statistics generator\nhttps://gitstats.sourceforge.net/\n\n#### git fetch -p\n- 清除已删除的远程分支\n\n#### git升级\n```\nwget http://opensource.wandisco.com/centos/7/git/x86_64/wandisco-git-release-7-2.noarch.rpm\nrpm -ivh wandisco-git-release-7-2.noarch.rpm \nyum install git\n```\n\n## 推荐阅读\n- https://github.com/nnja/advanced-git\n","tags":["工作经验总结系列","git系列"]},{"title":"jenkins-对配置文件对变更进行跟踪管理","url":"/2020/05/07/jenkins-对配置文件对变更进行跟踪管理/","content":"\n### 先聊聊Jenkins吧\n- jenkins pipeline脚本\n- 集成打包问题\n- CI/CD工具，Jenkins or Gitlab CI/CD or Github CI/CD\n- 历史趣事\n\n\n#### 参数化构建\n- git parameter\n给git可选参数\n- choice parameter\n比如传入一些构建时需要的参数\n\n上面两个都需要下载对应的插件\n\n#### node环境\n- nodejs插件：\n在插件管理面搜nodejs,安装即可（https://plugins.jenkins.io/nodejs/）\n\n- 在系统管理->全局工具配置->nodejs\n新建一个nodejs环境\n\n- Provide Node & npm bin/ folder to PATH\n选择node版本\n### 对配置文件对变更进行跟踪管理\nJob Configuration History\n对配置文件的变更进行跟踪管理\n\n- 安装这个插件：\n在manage jenkins => manage plugins里面选择 available ，search Job Configuration History；选择安装并重新启动jenkins即可（PS，会有“仅在没有job的时候重新启动的选项”）\n\n- 使用\n在Jenkins=>job config history里面可以查看系统/job的config的变更\n也可以在具体的job里面查看当前配置的变更，可以快速回滚配置\n具体操作指南可见文档：(https://plugins.jenkins.io/jobConfigHistory/)\n\n### node集成插件\nhttps://plugins.jenkins.io/nodejs/\n\n### 拓展\n#### JenkinsX\nhttps://jenkins-x.io/docs/reference/pipeline-syntax-reference/\n\n\n#### Android\n- active choices reactive parameter\n- groovy script\n\n#### job配置的导出导入\n- https://wiki.jenkins.io/display/JENKINS/Administering+Jenkins#AdministeringJenkins-Moving/copying/renamingjobs\n- 同Jenkins可以直接copy from\n - jenkins-cli.jar\n - https://www.jenkins.io/doc/book/managing/cli/\n ```\n # manage jenkins | jenkins-cli | get-job\n java -jar jenkins-cli.jar -s 【domain】 -auth 【account】:【pwd】 get-job 【job name】> 【job name】.xml\n ```\n ```\n➜  Downloads java -jar jenkins-cli.jar -s http://xxxxxx:xxxx/ -auth xxxxxx:1234 get-job seal-troy-frontend > seal-troy-frontend.xml\n➜  Downloads code seal-troy-frontend.xml \n➜  Downloads java -jar jenkins-cli.jar -s http://xxxxxx:xxxx/ -auth xxxxxx:1234 create-job seal-troy-frontend-copy < seal-troy-frontend.xml\n ```\n \n #### jenkins 版本的升级和回退需要注意\n 因为插件是依赖于Jenkins的版本的，所以如果回退Jenkins版本，可能会导致依赖于更高版本的已装插件的不可用；\n - case ，multijob插件，然后基于这个创建了一个jobA, Jenkins版本被回退到不支持multijob的版本，这个时候，表现为 jobA无法搜索到，但是去服务器上面查，能查到项目的workspace和jobs的配置文件，拿着xml配置文件create-job的时候，\n ```\n ERROR: Unexpected exception occurred while performing create-job command.\ncom.thoughtworks.xstream.mapper.CannotResolveClassException: com.tikal.jenkins.plugins.multijob.MultiJobProject\n ```\n 就发现，哦multijob这儿出问题\n ```\n This plugin is a MultiJob plugin.\nWarning: This plugin has dependencies on other plugins that require Jenkins 2.289.1 or newer. Jenkins will refuse to load the dependencies requiring a newer version of Jenkins, and in turn loading this plugin will fail.\n ```","tags":["jenkins&&travis"]},{"title":"npm私有仓库的搭建及发版基本方法","url":"/2020/04/13/npm私有仓库的搭建及发版基本方法/","content":"\n> 让运维老师帮忙用Nexus搭了我们NPM私仓库，严格说，给我们提供了NPM的支持\n\n私仓——使用需要配置源，个人电脑使用推荐nrm\n\n## 私仓的使用\n\n#### 源的配置\n写到脚本里面：\n```\nnpm --registry http://xxxxx/repository/npmjs.org/\n\"setup\": \"npm install --force --registry http://xxxxx/repository/npmjs.org\",\n```\n设置全局：\n```\nnpm help config // 查询config具体用法\nnpm config set registry http://xxxxx/repository/npmjs.org/\nnpm config get registry\n```\n```\npackage.json\n包在npm私有仓库中的的完整路径, 指明tgz包的版本，安装指定版本的npm包\n  \"_resolved\": \"http:/xxx/repository/npmjs.org/xxxx/-/xxxx-1.1.9.tgz\",\n也就是包_resolved字段里面那个值，我们发布了包之后，在管理端也能看到地址\n\n```\n#### nrm\n文档指路：https://www.npmjs.com/package/nr\n\n#### nexus配置\n获取包的源和发布包的源可以在nexus里面配置\n\n#### 发包版本控制\ntips: 注意正式版本和发测试版本包的时候，发包规则的设定，可以用npm publish --tags=beta来发测试版本\n\n\n## 私仓的搭建（基于nexus）\n\n\n\n### npm发包\n1.注册账号\n2.package.json (name,version=>最少字段)\n3.main/module/files-需要发布的本地目录/\n\n\ntips:\n1.发npm包时候，源就是npm的;注意publish的源的设置\n2.推荐工具：nrm\n3.keyword方便搜索的\n\n\n### nexus部署服务器磁盘空间不够处理\n\n1. 可以在Blob Stores里面看下磁盘占用情况，确认占用多的是哪些类型（jar or npm包 ？）\n2. 配置cleanup policies，在设置按钮的 Repository-Cleanup Polices选项下，选择 +Create Cleanup Policy，然后配置一个你认为没问题的策略，这个里面还可以preview，看看这个策略下，哪些会被删除；\n3. 进入Repository里面，根据1确认的 repositry，点击进去，在settings里面，修改Cleanup选项，刚刚配置的策略添加到applied里面即可；\n4. 点击system-tasks,点击 +Create task(type Admin-compact blob store)，可以选择手动触发，然后手动run一下，即进入清理模式；这个时候可以通过状态判断是否清理完成，我这边100多个G，大概running了1个多小时快2个小时才跑完；\n\n#### error\n```\njavax.servlet.ServletException: com.orientechnologies.orient.core.exception.OLowDiskSpaceException: Error occurred while executing a write operation to database 'component' due to limited free space on the disk (3898 MB). The database is now working in read-only mode. Please close the database (or stop OrientDB), make room on your hard drive and then reopen the database. The minimal required space is 4096 MB. Required space is now set to 4096MB (you can change it by setting parameter storage.diskCache.diskFreeSpaceLimit) . DB name=\"component\"\n```\n- 跑task清理\n- {安装目录}/bin/nexus.vmoptions - storage.diskCache.diskFreeSpaceLimit = 2048\n\n\n### nexus文档指路（sonatype）\n#### repository manager(注意根据自己搭建的版本选择文档)\n- https://guides.sonatype.com/repo3/quick-start-guides/proxying-maven-and-npm/\n- https://help.sonatype.com/repomanager3\n- https://help.sonatype.com/repomanager2\n\n","tags":["工作经验总结系列"]},{"title":"MacOS使用Tips","url":"/2020/04/06/MacOS使用Tips/","content":"> 写在开头：macOS是基于BSD Unix的，所以很多命令和Linux有细微的差别，如（ps, ls, tail, awk, sed）,比如我们```man ps```,会显示：BSD General Commands Manual。如果我们写跨平台的bash脚本的时候，需要注意一些命令，仔细的做好测试\n\n#### 查看版本信息\nsw_vers\n\n#### pbcopy/pbpaste\n```\nls ~ | pbcopy\npbcopy < test.txt\ncurl xxx | pbcopy\npbpaste >> test.txt\n```\n\n#### mdfind 对标spotlight\n```\nmdfind -onlyin ~/Documents xxx\n```\n#### mdls  list metadata (such as photo EXIF info)\n\n\n#### 命令行中打开finder\n```open .```\n//打开应用\n```open -a /Applications/Whatever.app```\n\n#### 文件名大小写区分\nwindows 和 mac\n系统里面文件名不区分大小写\n\n\nLinux里面则会区分大小写\n\ncase-sensitive-paths-webpack-plugin\n\nhttps://www.npmjs.com/package/case-sensitive-paths-webpack-plugin\n\n(vue项目本身，文件和文件夹命名，都是kebab-case的，这样也直接避免了这个问题)\n\n#### brew\nbrew -ls\nbrew - 下载不带界面的命令行的工具和第三方库\nbrew cask - 下载带界面的应用软件\nbrew install curl\nbrew cask install chrome \n\n#### screencapture\ncmd+shift+3/4\n（3全屏，4选择器）\ncmd+shift+4+Space（窗口）\n```screencapture --help```\n\n#### 关闭mac输入法首字母大写\n\n系统偏好设置\n键盘\n文本\n\n去掉首字母大写的即可\n\n#### 共享目录访问\n1.打开finder\n2.cmd+K\n3.smb://xxxx/xxx\n\n#### 浏览器中打开文件\ncmd + O\n选择文件即可\n#### 查找系统安装字体\nbrew install fontconfig\nfc-list :zang-zh\nfc-list : file family | grep \\/Library\n\n搜索：字体册\nFont Book.app\n\n#### 推荐app\n可参考：https://github.com/jaywcjlove/awesome-mac/blob/master/README-zh.md\n\n翻译类：\nGoogle DeepL translator - https://www.deepl.com/app/thanks\n极光词典（Mac和IOS都可以使用）\n工具类：\nmagnet（https://magnet.crowdcafe.com/?utm_source=help）—— 分窗口软件\nshadowsocks\ncharles（抓包）\ndash（查文档）\nvscode（代码编辑）\nAlfred（全局搜索）\nSwitchHosts（host配置）- 或者编辑/etc/hosts文件\nNotability（笔记）\n命令行：\npandoc（文件格式转换）\n\n#### 文档手写签名\n用预览功能：\n打开PDF文档后，点击工具=>注解=>签名（管理签名），\n\n#### 隔空投送\n- 修改本机名称：系统偏好设置=>共享，修改即可；\n\n\n#### 快捷键\ncmd + M 最小化窗口\ncmd + T 新Tab\ncmd + W 关闭窗口\ncmd + Q 退出程序\ncmd + Space 切换输入法\ncmd + 拖动非最前面窗口，可以避免拖动导致的激活\ncmd + Del 移到废纸篓\nctrl + cmd + Space 输入emoji\n\n#### 活动监视器\nactivity monitor （spotlight里面搜索）\n#### 方法\n> 因为想把有道云笔记迁移到notability上，但是有道云笔记只支持在PC客户端进行全部导出到操作，所以需要从PC快速分享文件到Mac上\n\n首先保证windows电脑和Mac 在同一局域网\n- window上： 运行-> cmd -> ifconfig -> 得到本机在局域网到ip\n- window上： 右键文件夹-> 属性 ->共享-> 高级 -> 共享此文件夹 -> 确定\n- Mac 上: 在 Finder 到前往里面选择’连接服务器’, 输入 smb://10.200.170.52（你获得的windows电脑的ip）,点连接， 然后输入windows的管理员的名称和密码即可（在windows的设置->账户信息里面可以查到）。\n\n\n## windows - 公司无线edu\n- 网络和共享中心-设置新的连接和网络-手动连接到无线网络\n- 网络名一定得为EDU，不然搜索不到\n- 网络名-EDU + 安全类型-WPA2-企业 —— 加密类型AES\n- 下一步 - 更改连接设置\n- 安全 - 设置 - 取消掉通过高验证证书来验证服务器的身份｜ 取消自动用Windows的账号登录\n- 安全 - 高级设置 - 802.1X设置 - 选择“指定身份验证模式（P）”\n```\nhttps://baike.baidu.com/item/WPA2/4913331\nWPA2 = IEEE 802.11i = IEEE 802.1X/EAP + WEP(选择性项目)/TKIP/CCMP\n\n大多数企业和许多新的住宅 Wi-Fi 产品都支持 WPA2。截止到 2006 年 03 月，WPA2 已经成为一种强制性的标准。WPA2 需要采用高级加密标准 (AES) 的芯片组来支持。\nWPA2 有两种风格：WPA2 个人版和 WPA2 企业版。WPA2 企业版需要一台具有 IEEE 802.1X 功能的 RADIUS (远程用户拨号认证系统) 服务器。没有 RADIUS 服务器的 SOHO 用户可以使用 WPA2 个人版，其口令长度为 20 个以上的随机字符，或者使用 McAfee 无线安全或者 Witopia Secure MyWiFi 等托管的 RADIUS 服务。\n```\n(http://en.wikipedia.org/wiki/Advanced_Encryption_Standard) - AES\n### CLT\nCommand Line Tools (CLT) 是一个适用于 macOS 的开发者工具集，它包含了许多编程语言的编译器、二进制库以及开发者基础模板等一系列必备工具，如 git、gcc、make、ld 等。它可以让开发人员在 macOS 上轻松构建与运行他们的项目。\n\nCLT 的一个替代品是 Xcode – 一个完整的 macOS/iOS 原生软件开发套件。不过，如果你不需要 Xcode 中包含的精细 UI 和 IDE 功能，只需使用基本的命令行工具，那么安装 CLT 是个更轻量级的选择。\n\n要在 macOS 上为 Xcode 安装 Command Line Tools，可以根据以下步骤操作：\n\n1. 打开“终端”（位于“实用工具”文件夹内，或使用“Spotlight”快速搜索“Terminal”。\n\n2. 在终端输入以下命令安装 CLT：\n\n```\nxcode-select --install\n```\n\n3. 将会弹出一个提示窗口，询问是否需要安装 Command Line Tools。点击“安装”以开始安装过程。\n\n4. 安装过程需要一段时间（取决于你的网络速度和系统资源）。安装完成后，终端将显示一个消息通知。\n\n5. 安装完成后，可以运行以下命令确认安装成功和检查已安装的 CLT 版本：\n\n```\nxcode-select -p\n```\n\n请注意，为了保持项目与工具的最新版本，并确保安全性和稳定性，建议您在可能的情况下将 Xcode 和 CLT 更新到最新版本。当 macOS 或 Xcode 有新版本可用时，通常会跟随推出更新的 Command Line Tools。更新 CLT 大部分情况下跟随 Xcode 的更新，或者在 Xcode 中可以单独更新。如果你单纯地使用 CLT 而不安装 Xcode，可以通过运行 `xcode-select --install` 命令来更新。","tags":["MacOS"]},{"title":"Chrome开发使用合集","url":"/2020/03/12/Chrome开发使用合集/","content":"\n#### Chrome基本原理\n- 任何一个软件的帮助，里面可以搜索，快速找到某个功能，Chrome的帮助里面的搜索做的尤其的好（书签的搜索在里面也能搜）\n- 窗口了 - 任务管理器 - Chrome\n  - 按进程ID倒序，然后在浏览器里面打开新的标签页，观察任务管理器里面的变化\n  - 从 A 标签页中打开 B 标签页（A,B同域下的），就会使用同一个渲染进程(用a标签或者window.open)，而分别打开这两个标签页，又会分别使用不同的渲染进程(打开新标签页，再输入网址；或者在A页面右键->在新标签页中打开链接)![](tags.png)\n  - Chrome 浏览器会将浏览上下文组中属于同一站点的标签分配到同一个渲染进程中 (https://html.spec.whatwg.org/multipage/browsers.html#groupings-of-browsing-contexts)\n  - rel= noopener a标签里面使用这个属性，可以切掉关联（引用关系）\n  ```\n  <a href=\"http://www.imaginingme.cn/img/avatar.jpeg\" target=\"_blank\" class=\"\" rel=\"noopener\">imaginingme</a>\n  ```\n  - 站点隔离: iframe —— 看是否属于同一站点，判断是否开新的渲染进程\n\n  - 同站（same-site） 和同源（same-origin）—— 同源策略对同一站点的限制: A,B 标签页同站非同源，依然无法通过 opener 来操作父标签页中的 DOM —— 受同源策略的限制\n\n#### chrome://chrome-urls/\n里面有Chrome urls的合集\n\n#### 开发者工具\n- developers.google.cn/web/tools/chrome-devtools/javascript/breakpoints\n- developers.google.cn/web/tools/chrome-devtools/javascript/reference\n\n#### 查看调用堆栈\n- 显示不断进行的函数调用顺序\n- 底部\n- 第一个运行的函数\n#### chrome canary\n\n\n#### Disable cache\n只有在开发者工具打开的时候，才会生效; 鼠标上去可以看到提示：disable cache（while devtools is open）\n\n#### 搜索\n- ctrl/cmd + P 搜索特定文件\n\n#### samesite问题\n服务端利用cookies写入一些信息，\n* 禁用samesite\n<pre>\nchrome://flags/\nsame-site(两个都改成disabled)\n</pre>\n<pre>\nSameSite by default cookies\nTreat cookies that don't specify a SameSite attribute as if they were SameSite=Lax. Sites must specify SameSite=None in order to enable third-party usage. – Mac, Windows, Linux, Chrome OS, Android\n\n#same-site-by-default-cookies\nCookies without SameSite must be secure\nIf enabled, cookies without SameSite restrictions must also be Secure. If a cookie without SameSite restrictions is set without the Secure attribute, it will be rejected. This flag only has an effect if \"SameSite by default cookies\" is also enabled. – Mac, Windows, Linux, Chrome OS, Android\n\n#cookies-without-same-site-must-be-secure\n\n# 当一个页面嵌入iframe里面，这个时候，里面set-cookie的行为，会受到安全策略的影响\n# 场景，growingio的热力图\n![](https://img.imaginingme.cn/This%20Set-Cookie%20header%20didn%27t%20specify.png)\n\n</pre>\n- https://web.dev/schemeful-samesite/?utm_source=devtools\n\n#### 如果cookie写入有问题\n- 可以点开set-cookie里面，三角形感叹号里面的提示，一般就是浏览器不让set的原因\n- https://angel.co/today/stories/chrome-83-arrives-with-redesigned-security-settings-third-party-cookies-blocked-in-incognito-21796\n- 83开始，隐私模式下，第三方cookie是被block的\n#### preserve-log\n![](preservelog.png)\n\n#### chrome devtools protocol\nhttps://chromedevtools.github.io/devtools-protocol/tot/Browser/\n\n\n#### net-internals/dns\nchrome://net-internals/#dns\n刷DNS缓存\n","tags":["工具篇"]},{"title":"charles的使用","url":"/2020/03/11/charles的使用/","content":"\n#### 官方文档指路\nhttps://www.charlesproxy.com/documentation/\n阅读指南：内容本身是比较简单的，如果需要的话，可以安装chrome 的 Google 翻译插件，点击翻译此页面，整个文档就被翻译了（需要开代理，不然可能用不了）\n#### 问题解决\n1. charles 突然打开就是一片空白\n\n这个时候把电脑的shadowsocks代理给关掉了就好了\n\n\n2. 怎么修改请求\n\n在需要拦截的请求上面右击，选择breakpoints，再次抓到请求的时候，就会拦截，这个时候可以修改请求了（request， response都能改，先抓到的是options，然后是post请求）\n（cmd + shift +4 截屏）\n\n\n按Execute就会继续往下走\n\n\n3. 配置APP预发环境测试的请求抓取\n\n为了解决跨域问题，需要做下面的配置\n![](charles1.png)\n\n- Rewrite Settings\n    - enable rewrites\n- Rewrite Rules\n    - Modify Header(Access-Control-Allow-Headers)\n    - Remove Header(Access-Control-Allow-Origin)\n\n```\nAccess-Control-Allow-Headers\nOrigin, Content-Type, Cookie, X-CSRF-TOKEN, Accept, Authorization, X-XSRF-TOKEN, Origin, Content-Type, Cookie, X-CSRF-TOKEN, Accept, Authorization, X-XSRF-TOKEN,currentStudentCode\n```\n\n\nhttps://www.jianshu.com/p/75126f57e933\n\n具体手机端的配置见上面链接里面的文档\n\n\n#### 基本原理-手机端\nCharles - 代理软件 - SSL/流量控制/重发，修改请求等\n> 手机通过电脑进行网络访问，因而，电脑的host设置，对手机的请求也有效（移动端配置host要root权限）；离线发布时候，可以把请求直接映射到某个服务器\n\n- 手机和电脑同一网络环境\n- Charles - proxy - proxy settings - proxies \n- 勾选 enable transparent http poxying ， 端口号设置\n- 手机代理设置： 端口号和电脑设置的保持一致\n\n\n#### https请求抓取\n- 原理，Charles对客户端伪装成服务器，对服务器伪装成客户端\n- Help -> 添加Charles的根证书\n设备上下载完证书，点击证书，如果提示到设置里面安装，则可以在设置里面全局搜索：“证书”｜“安装证书”，就可以找到安装的地方了；\n- 问题解决：https://blog.csdn.net/liushaofang/article/details/106421834\n\n\n#### host\n- Tools \n- Map Remote Settings\n- 选择enable map remote\n- Add \n- (记得选择 Preserve host in header fields)\n```\n502 Bad Gateway\nThe proxy server received an invalid response from an upstream server. Sorry for the inconvenience.\nPlease report this message and include the following information to us.\nThank you very much!\n如果不选择，会有相关报错\n```\n\n## http://proxy.man/ssl\n#### 电脑端\n- https://proxyman.io\n#### 手机端：\n- ip + 端口号 进行wifi代理配置\n\n- 安装证书 http://proxy.man/ssl\n\n- 设置里面搜索 => 可信\n\n### postman\n- 可发可抓\n- https://learning.postman.com/docs/sending-requests/capturing-request-data/capturing-http-requests/\n\n## Proxy\n- macos proxy -> 设置为系统代理\n- switchyomega 指定网页的代理服务为Charles（把端口改成 proxy settings 里面显示的端口）\n- switchomega -> auto switch\n- ssl proxying (https - 证书里的公钥加密请求，私钥加密响应数据) - 抓明文数据，把证书换成Charles的 - ssl proxying settings - help-ssl proxying-install charles root certificate\n- breakpoints(修改内容，然后再execute)\n- start throttle ｜ throttle settings\n- web interface settings - 通过web网页控制，用于远程的时候，比较方便\n- external proxy settings - 设置转发的代理服务器，这样Charles抓包之后会再转发给别的代理服务器，用于科学上网也需要代理服务器的场景\n\n\n## Tools\n- no cache -> 会用本地的缓存，但是每次都协商\n- block cookies\n- map remote\n- map local - 线上调试本地代码（替换静态资源） 或者mock数据（map local | local path）\n- mirror - 把响应内容保存在本地 可配合map local 使用\n- rewrite\n- block list - 模拟请求失败\n- allow list\n- DNS spoofing - 类似于修改hosts，终端生效可以通过 export https_proxy=127.0.0.1:8888 export http_proxy=127.0.0.1:8888 , 当然ping 不会走代理，终端去代理可以用 unset https_proxy http_proxy\n- client process - 在notes里面显示发送请求的客户端进程\n- compose new - 有点像postman了；右键compose也可以编辑发送\n- repeat - 重发请求（advanced repeat）- 用来测试接口\n\n## View\n- 左下角 - filter\n- Focused hosts\n- 右键focus\n- highlight rules - 类似于 chrome devtools里面的has0response-header filter\n\n## Edit\n- find - 搜索功能\n## preferences\n- Charles窗口永远放在上面\n\n### 参考阅读\n- https://mp.weixin.qq.com/s?__biz=Mzg3OTYzMDkzMg==&mid=2247492108&idx=1&sn=525ad9bf283055d39d3c528ab1c94419&chksm=cf032d37f874a421d64bcc10e70393c8a90f97a26e4b9c4e71fd0311748e49032c6494f9bad5&token=965494574&lang=zh_CN#rd\n- 用 Charles 断点调试 HTTPS 请求，原理揭秘\n","tags":["工具篇"]},{"title":"MouseEvent","url":"/2020/03/07/MouseEvent/","content":"> 鼠标事件（The MouseEvent interface represents events that occur due to the user interacting with a pointing device (such as a mouse).）\n\n* MDN指路：https://developer.mozilla.org/zh-CN/docs/Web/API/MouseEvent\n\nMouseEvent 包括\n- click\n- dblclick\n- mouseup\n- mousedown\n\nMouseEvent derives from UIEvent \nUIEvent derives from Event\n\n一些具体的事件都派生自 MouseEvent：WheelEvent 和DragEvent。\n\nProperties\nThis interface also inherits properties of its parents, UIEvent and Event.\n\n其中：\n- MouseEvent.clientX Read only\nThe X coordinate of the mouse pointer in local (DOM content) coordinates.\n- MouseEvent.clientY Read only\nThe Y coordinate of the mouse pointer in local (DOM content) coordinates.\n- MouseEvent.offsetX Read only\nThe X coordinate of the mouse pointer relative to the position of the padding edge of the target node.\n- MouseEvent.offsetY Read only\nThe Y coordinate of the mouse pointer relative to the position of the padding edge of the target node.\n- MouseEvent.pageX Read only\nThe X coordinate of the mouse pointer relative to the whole document.\n- MouseEvent.pageY Read only\nThe Y coordinate of the mouse pointer relative to the whole document.\n- MouseEvent.screenX Read only\nThe X coordinate of the mouse pointer in global (screen) coordinates.\n- MouseEvent.screenY Read only\nThe Y coordinate of the mouse pointer in global (screen) coordinates.\n\n#### concept\n screenX/screenY：相对屏幕区域左上角定位，若发生滚动行为，则相对该区域定位\n pageX/pageY：相对网页区域左上角定位\n clientX/clientY：相对浏览器可视区域左上角定位\n offsetX/offsetY：相对父节点区域左上角定位，若无父节点则相对<html>或<body>定位\n\n## KeyboardEvent\n- https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent\n- 键盘事件是由焦点系统控制的，一般来说，操作系统也会提供一套焦点系统，但是现代浏览器一般都选择在自己的系统内覆盖原本的焦点系统\n- 焦点系统认为整个 UI 系统中，有且仅有一个“聚焦”的元素，所有的键盘事件的目标元素都是这个聚焦元素\n- 浏览器也提供的API来处理焦点，focus,blur\n- 键盘事件为了跟 pointer 设备保持一致，也规定了从外向内传播的捕获过程\n```\nNote: KeyboardEvent events just indicate what interaction the user had with a key on the keyboard at a low level, providing no contextual meaning to that interaction. When you need to handle text input, use the input event instead. Keyboard events may not be fired if the user is using an alternate means of entering text, such as a handwriting system on a tablet or graphics tablet.\n```\n- key | code    keyCode ()\n\n## FocusEvent\n- https://developer.mozilla.org/en-US/docs/Web/API/FocusEvent\n- https://javascript.info/focus-blur\n- https://w3c.github.io/uievents/#events-focusevent-doc-focus","tags":["Event"]},{"title":"awk","url":"/2020/03/02/awk/","content":"> 上服务器查一些简单的日志，整理一些需要的数据，用到awk\n> man awk => 用法指南(pattern-directed scanning and processing language)\n> 能够直接支持正则表达式(grep和sed也是)\n\n### 历史\n1979年，在unix系统上出现了一个名为AWK的宏与文本处理语言，被普遍认为是一种脚本语言；\n创建者命名为：样式扫描和处理语言\nAWK主要用于处理文本，也是现在正则表达式的前身\nAWK的设计思想收到SNOBOL的影响\n### 闲聊\n- vim和sed,awk的区别\nvim是交互式的，文件操作模式\nsed,awk是非交互式的，行操作模式\n\n- sed一般用于对文本内容做替换\n```\nsed 's/要被取代的字串/新的字串/g'\n```\n\n- awk一般用于对文本内容进行统计，按照需要的格式进行输出\n\n- awk更像是脚本语言，用于相对比较规范的文本处理，统计数量并输出指定字段，sed用于将不规范的文本，处理成比较规范的文本\n\n### 使用场景\n```\nps -ef | grep 关键字 | awk '{print $2}' | xargs kill -9\n```\n\n```\n# 分析日志\ngrep+awk+sed\n# 不过现在都有运维平台了，我们这边日志都落到了ES，所以用的少了\n```\n\n```\n# 找到当前运行的vim程序并关闭\nps aux | grep vim | grep -v grep | awk '{print $2}' | xargs kill\n```\n\n```\n# https://www.kernel.org/doc/Documentation/filesystems/proc.txt\n\n# 使用grep查找Pss指标后，再用awk计算累加值\n$ grep Pss /proc/[1-9]*/smaps | awk '{total+=$2}; END {printf \"%d kB\\n\", total }'\n```\n\n```\n# 对imaginingme.cn进行网络通信检查\nping imaginingme.cn | awk 'match($0, /time=(.*)ms|timeout/) { print (RLENGTH > 7)  ? substr($0, RSTART+5, RLENGTH-8) : 9999; fflush() }'\n```\n\n### 推荐书籍\n- http://linux.vbird.org/linux_basic/\n可以在线查找，是繁体的","tags":["工具篇"]},{"title":"object-keys","url":"/2020/02/02/object-keys/","content":"Object.keys","tags":["基础篇"]},{"title":"mysql基本操作","url":"/2020/01/06/mysql基本操作/","content":"\n### 客户端/服务端\n- MySQL数据库实例 - 代表着MySQL服务器程序的进程\n- mysqld - 启动的MySQL服务器进程的默认名称\n- mysql - 客户端进程的默认名称\n### 安装\n- 安装目录\n```\nmacos(类unix)\n/usr/local/mysql\nwin\nC:\\Program Files\\MySQL\\MySQL Server 8.0\n```\n\n### bin目录下的可执行文件\n- 将该bin目录的路径加入到环境变量PATH中\n\n### 启动MySQL服务器程序\n- unix里启动服务器程序\n- mysqld\n- mysqld_safe\n- mysql.server\n- mysqld_multi\n\n### 启动MySQL客户端程序\n- mysql | mysqldump | mysqlcheck | mysqladmin ...\n- `mysql>` 客户端提示符\n- 断开客户端与服务器的连接并且关闭客户端（quit， exit，\\q）\n\n### 重启服务：\n```service mysqld restart```\n\n### 当密码不记得的时候：\n```vim /etc/my.cnf```\n增加一行：```skip-grant-tables ```\n\n### 增加用户：\n```mysql -u root -h 127.0.0.1 -p```\n```\nshow database;\nuse mysql;\nselect user,password,host from user;\ncreate user 'test'@'%' indentified by 'test';\ngrant all privileges on firekylin.* to 'test'@'%' with grant option;\nFLUSH PRIVILEGES;\n```\n\n### 删除某个库：\n```drop database;```\n\n\n```mysqladmin```\n\n\n#### log_bin\n\n### err\n#### \nMac上：ERROR 2002 (HY000): Can’t connect to local MySQL server through socket ‘/tmp/mysql.sock’ (2)\n```\n which mysql \n brew info mysql \n```\n\n#### ER_NOT_SUPPORTED_AUTH_MODE\n```\nALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '123456';\nALTER USER 'root' IDENTIFIED WITH mysql_native_password BY '123456';\n```\n\n### 数值类型\n#### 整数类型 \n- 进制\n- 8个比特位代表一个字节\n- 用若干个字节表示一个证书\n\n#### MySQL的整数类型\n- 类型\n- 占用的存储空间（单位：字节）\n- 无符号数值的取值范围\n- 有符号数取值范围（有符号数需要一个比特位表示正负号）\n- 含义\n\n#### 浮点数类型\n- 符号部分 指数部分 尾数部分\n- 类型\n- 占用的存储空间（单位：字节）\n- 绝对值最小非0值\n- 绝对值最大非0值\n- 含义\n- FLOAT | DOUBLE\n- 更多的小数是无法直接转换成二进制的，比如0.3，它转换成的二进制小数就是一个无限小数，所以只能进行一些舍入来近似表示，所以计算机的浮点数有时是不精确的\n- 设置最大位数和小数位数 FLOAT（M，D） DOUBLE（M，D）\n- M表示该小数最多需要的十进制有效数字个数，D表示该小数的小数点后的十进制数字个数\n- M和D都是可选的，如果省略了，它们的值按照机器支持的最大值来存储\n\n\n### binlog\n- binlog日志文件 \n- 前四个字节固定的： 0xfe626963\n- 由若干个事件构成的\n- 事件1 - 格式描述事件format description event\n- 事件 - event header | event data\n- 基于语句statement和基于行row的binlog\n\n\n## 数据库管理工具\n- MySQL workbench\n- dbeaver - https://github.com/dbeaver/dbeaver\n```\nmac\nhttps://formulae.brew.sh/cask/dbeaver-community\n```","tags":["mysql"]},{"title":"cheerio","url":"/2019/11/29/cheerio/","content":"\n#### Cheerio\n官方文档指路：https://github.com/cheeriojs/cheerio/wiki/Chinese-README\n\nFast, flexible, and lean implementation of core jQuery designed specifically for the server.\n\n极其灵活：cheerio使用了@FB55编写的非常兼容的htmlparser2，因此它可以解析几乎所有的HTML和XML\n\n\nconst cheerio = require('cheerio');\nconst $ = cheerio.load('<ul id=\"fruits\">...</ul>');\n\n\nconst $ = cheerio.load('<ul id=\"fruits\">...</ul>', {\n    normalizeWhitespace: true,\n    xmlMode: true\n});\n\n\nThese parsing options are taken directly from htmlparser2, therefore any options that can be used in htmlparser2 are valid in cheerio as well. The default options are:\n{\n    withDomLvl1: true,\n    normalizeWhitespace: false,\n    xmlMode: false,\n    decodeEntities: true\n}\n\n\n#### htmlparser2\nForgiving html and xml parser\n","tags":["node","jQuery"]},{"title":"spectrum","url":"/2019/11/21/spectrum/","content":"> spectrum 是一个 online community 的开源项目，里面的技术栈可以参考习\n\n#### 项目结构和技术栈\n摘自官方README.md\n<pre>\nCodebase\nTechnologies\nWith the ground rules out of the way, let's talk about the coarse architecture of this mono repo:\n\nFull-stack JavaScript: We use Node.js to power our servers, and React to power our frontend apps. Almost all of the code you'll touch in this codebase will be JavaScript.\nBackground Jobs: We leverage background jobs (powered by bull and Redis) a lot. These jobs are handled by a handful of small worker servers, each with its own purpose.\nHere is a list of all the big technologies we use:\n\nRethinkDB: Data storage\nRedis: Background jobs and caching\nGraphQL: API, powered by the entire Apollo toolchain\nFlowtype: Type-safe JavaScript\nPassportJS: Authentication\nReact: Frontend React app\nFolder structure\nspectrum/\n├── api        # API server\n├── athena     # Worker server (notifications and general processing)\n├── chronos    # Worker server (cron jobs)\n├── desktop    # desktop apps (build with electron)\n├── docs\n├── email-templates\n├── hermes     # Worker server (email sending)\n├── hyperion   # Rendering server\n├── mercury    # Worker server (reputation)\n├── public     # Public files used on the frontend\n├── shared     # Shared JavaScript code\n├── src        # Frontend SPA\n└── vulcan     # Worker server (search indexing; syncing with Algolia)\n\n</pre>\n\n## study\n#### resolutions\n```\n\"resolutions\": {\n    \"immutable\": \"3.7.4\",\n    \"draft-js\": \"npm:draft-js-fork-mxstbr\",\n    \"jest-environment-node\": \"22.4.3\",\n    \"jest\": \"22.4.3\",\n    \"fbjs\": \"0.8.16\",\n    \"event-stream\": \"3.3.4\"\n  },\n# 允许您覆盖特定嵌套依赖项的版本。 有关完整规范，请参见选择性版本解析 RFC。\n# https://github.com/yarnpkg/rfcs/blob/master/implemented/0000-selective-versions-resolutions.md\n# 注意，yarn install —flat 命令将会自动在 package.json 文件里加入 resolutions 字段\n- resolutions 字段是一个 Yarn 的特性，它允许你在项目中覆盖依赖包的版本。这在处理一些由冲突版本引发的问题时非常有用。npm 本身并不支持这个字段。\n```\n\n#### immutable-js \n- https://immutable-js.com/\n\n#### draft.js\n- https://draftjs.org/","tags":["websocket","源码学习系列"]},{"title":"Konva","url":"/2019/11/19/Konva/","content":"> 作业批改（教学），海报生成（运营）是两个主要使用场景，需要借助canvas；Konva是目前采用的一个库\n\n### canvas\nThe HTML <canvas> element provides an empty graphic zone on which specific JavaScript APIs can draw (such as Canvas 2D or WebGL).\n\nThe default size of the canvas is 300 px × 150 px (width × height).\n\n官方文档指路：https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/canvas\n\n\n### canvas tips\n- 页面像素大于阈值（根据不同端的不同设备不一样）的情况下，canvas是不能绘画出来的。\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n</head>\n<body>\n    <canvas id=\"canvas\" width=\"16385\" height=\"16380\"></canvas>\n    <script>\n        const canvas = document.getElementById('canvas');\nconst ctx = canvas.getContext('2d');\n\nctx.fillStyle = 'green';\nctx.fillRect(10, 10, 150, 100);\n\n    </script>\n</body>\n\n</html>\n```\n如上，就是Chrome(\"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.125 Safari/537.36\")浏览器,当超过这个阈值后，绘画当方框无法显示出来。\n\n- 走势图高级绘图板的开发（画线图形算法，橡皮擦（兼容全系浏览器））—— 数据多的时候，保持性能。\n\n### canvas - font - 字体字号设置\n- https://bucephalus.org/text/CanvasHandbook/CanvasHandbook.html#font\n- https://bucephalus.org/text/CanvasHandbook/CanvasHandbook.html#css-fonts\n- 可以按CSS的写法规范去设置","tags":["图形图像","工作经验总结系列"]},{"title":"protobuf","url":"/2018/10/16/protobuf/","content":"## 文档指南\n- https://developers.google.com/protocol-buffers\n- github: https://github.com/protocolbuffers/protobuf\n\n## 说明\n- Google Protocol Buffer\n- 数据序列化协议\n- 压缩和传输效率极高，语法也简单\n- 是独立的协议系统，所以它和开发语言、运行平台都没有关系，可以用在扩展的序列化结构数据格式。目前提供了 C++、Java、Python 、Ruby、Go 等语言的开发接口 API\n- protobuf使用的是二进制格式，因此，每种语言都需要有个生成器。\n- 使用protobuf时，需要事先在proto文件中声明结构每一个需要序列化和反序列化数据的服务都需要添加相应的proto文件，然后使用生成器生成一个包含数据的对象\n- Protobuf 对于 1M 以下的 message 有很高的效率，但是当 message 大于 1M 的时候，Protobuf 的效率会逐步降低\n\n\n## 应用\n- 用于 RPC 系统和持续数据存储系统\n- gRPC 把 Protobuf 作为底层的编解码协议\n- gRPC也使用了协议缓冲区（也称为protobuf），它提供了一种将结构化数据定义和序列化为高效的二进制格式的方法。由于它们是二进制格式的，所以它们的传输量相对更小，可以快速在线上传输。\n- 对于性能要求高并且数据量大的应用而言，protobuf常常是最佳的选择\n\n### protobuf.js\n用的时候，不要用protobuf.min.js\n\nreads output from proto2json as a schema\nencodes objects to buffers\ndecodes buffers to objects"},{"title":"HTTP相关问题","url":"/2018/09/17/HTTP相关问题/","content":"\n## History\n\n\n\n## TCP\n> 连接是两端的状态维护\n> 连接的断开比建立略微复杂，因为资源的constructor比destructor要简单（因为destructor要考虑所有资源的安全有序释放）\n## 基础\n### 结构\n报文：\n- 请求行 （POST /good HTTP/1.1）\n- 请求首部\n- 请求的正文实体\n\nHTTP请求的报文好了之后，浏览器或者移动端APP会把它交给传输层\n- Socket\n- 浏览器 ｜ 移动端-HTTP客户端工具\n- HTTP 基于TCP，面向连接的方式发送请求，基于Stream二进制流的方式传送，到了TCP层，会把二进制流变成一个报文段发送给服务器\n- TCP头｜IP头\n## 状态码\n\n#### 502网关问题\n#### 415（unsupported media type）（content-type）\n415 Unsupported Media Type 是一种HTTP协议的错误状态代码，表示服务器由于不支持其有效载荷的格式，从而拒绝接受客户端的请求。\n\n格式问题的出现有可能源于客户端在 Content-Type 或 Content-Encoding 首部中指定的格式，也可能源于直接对负载数据进行检测的结果。\n\nJava\n\n500 内部报错\n\n#### 503 service unavailable\n\n服务端错误状态码，表示服务器尚未处于可以接受请求的状态\n\n通常造成这种情况的原因是由于服务器停机维护或者已超载。注意在发送该响应的时候，应该同时发送一个对用户友好的页面来解释问题发生的原因。该种响应应该用于临时状况下，与之同时，在可行的情况下，应该在 Retry-After 首部字段中包含服务恢复的预期时间。\n缓存相关的首部在与该响应一同发送时应该小心使用，因为 503 状态码通常应用于临时状况下，而此类响应一般不应该进行缓存。\n\ncite(https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/503)\n\n#### 204\n- 204 No Content\n- 只需要返回成功与否，204可以节约多余的数据传输\n- DELETE ｜ 客户端上传端信息给服务器，不关心相应\n- http://clients1.google.com/generate_204\n\n#### 414\n- https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/414\n- 414 URI Too Long\n```\n当客户端误将 POST 请求当作 GET 请求时，会带有一个较长的查询字符串(query)；\n当客户端堕入重定向循环黑洞时，例如，指向自身后缀的重定向URI前缀(a redirected URI prefix that points to a suffix of itself)；\n当客户端对服务器进行攻击，试图寻找潜在的漏洞时。\n```\n\n## 相关库\n\n### axios\n文档指南，各种用法（https://github.com/axios/axios#axios-api）\n#### Features（支持Promise API）\n- Make XMLHttpRequests from the browser(从浏览器中创建 XMLHttpRequests)\n- Make http requests from node.js(从 node.js 创建 http 请求)\n- Supports the Promise API(支持 Promise API)\n- Intercept request and response(拦截请求和响应)\n- Transform request and response data(转换请求数据和响应数据)\n- Cancel requests(取消请求)\n- Automatic transforms for JSON data(自动转换 JSON 数据)\n- Client side support for protecting against XSRF(客户端支持防御 XSRF)\n- 不支持IE（11及以下）\n\n#### Cancellation\nYou can cancel a request using a cancel token.\n\nThe axios cancel token API is based on the withdrawn cancelable promises proposal.\n\nYou can create a cancel token using the CancelToken.source factory as shown below:\n```\nconst CancelToken = axios.CancelToken;\nconst source = CancelToken.source();\n\naxios.get('/user/12345', {\n  cancelToken: source.token\n}).catch(function (thrown) {\n  if (axios.isCancel(thrown)) {\n    console.log('Request canceled', thrown.message);\n  } else {\n    // handle error\n  }\n});\n\naxios.post('/user/12345', {\n  name: 'new name'\n}, {\n  cancelToken: source.token\n})\n\n// cancel the request (the message parameter is optional)\nsource.cancel('Operation canceled by the user.');\nYou can also create a cancel token by passing an executor function to the CancelToken constructor:\n\nconst CancelToken = axios.CancelToken;\nlet cancel;\n\naxios.get('/user/12345', {\n  cancelToken: new CancelToken(function executor(c) {\n    // An executor function receives a cancel function as a parameter\n    cancel = c;\n  })\n});\n\n// cancel the request\ncancel();\n```\nNote: you can cancel several requests with the same cancel token.\n\n* example\n```\nconst CancelToken = axios.CancelToken\nconst pending = []\nconst defaultConfig = {}\n\ndefaultConfig.cancelToken = new CancelToken(function executor(c) {\n  pending.push(c)\n})\n\n// 需要避免多次请求的时候执行下面代码\nwhile (pending.length > 0) {\n  pending.pop()('请求中断')\n}\n```\n## CORS\n- Fetch/XMLHTTPRequest都遵循同源策略\n- https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS\n#### preflighted requests\n- https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/OPTIONS\n- 浏览器发起的预检请求 - 为了防止对服务器数据产生副作用的请求方法，浏览器会用OPTIONS方法发起一个预检请求，获知服务器是否允许这个跨域请求，允许就发送真实请求，不允许，则阻止真实请求；\n- Method: OPTIONS\n```\n* It uses methods other than GET, HEAD or POST. Also, if POST is used to send request data with a Content-Type other than application/x-www-form-urlencoded, multipart/form-data, ortext/plain, e.g. if the POST request sends an XML payload to the server using application/xmlor text/xml, then the request is preflighted.\n* It sets custom headers in the request (e.g. the request uses a header such as X-PINGOTHER)\n```\n```\n跨域资源共享标准（ cross-origin sharing standard ）允许在下列场景中使用跨域 HTTP 请求：\n\t•\t前文提到的由 XMLHttpRequest 或 Fetch 发起的跨域 HTTP 请求。\n\t•\tWeb 字体 (CSS 中通过 @font-face 使用跨域字体资源), 因此，网站就可以发布 TrueType 字体资源，并只允许已授权网站进行跨站调用。\n\t•\tWebGL 贴图\n\t•\t使用 drawImage 将 Images/video 画面绘制到 canvas\n```\n\n## GET \n### URL长度\n- Http Get方法提交的数据大小长度并没有限制，HTTP协议规范没有对URL长度进行限制。这个限制是特定的浏览器及服务器对它的限制。\n```\nnet::ERR_CONNECTION_RESET 200\nhttps://spectrum.imgix.net/communities/8f3cb70e-0b51-4c7b-8a69-3d27f1c16887/logo-grid.png.0.393240430324705?w=1280&h=384&dpr=2&q=100&expires=1573084800000&ixlib=js-1.4.1&s=74b9ab44b425ebcfd87e1e0b1af56d8b\n```\n#### 说明\nGET请求限制传递参数长度为2k，长度过长会重置连接（只有IE）\n下面就是对各种浏览器和服务器的最大处理能力做一些说明\nMicrosoft Internet Explorer (Browser)\nIE浏览器对URL的最大限制为2083个字符，如果超过这个数字，提交按钮没有任何反应。Firefox (Browser)\n对于Firefox浏览器URL的长度限制为65,536个字符。\nSafari (Browser)\nURL最大长度限制为 80,000个字符。\nOpera (Browser)\nURL最大长度限制为190,000个字符。\nGoogle (chrome)\nURL最大长度限制为8182个字符。\nApache (Server)\n能接受最大url长度为8,192个字符。\nMicrosoft Internet Information Server(IIS)\n能接受最大url的长度为16,384个字符。\n\n### cacheable\n- https://developer.mozilla.org/en-US/docs/Glossary/Cacheabl\n```\nA cacheable response is an HTTP response that can be cached, that is stored to be retrieved and used later, saving a new request to the server. Not all HTTP responses can be cached, these are the following constraints for an HTTP response to be cached:\n\t•\tThe method used in the request is itself cacheable, that is either a GET or a HEAD method. A response to a POST or PATCH request can also be cached if freshness is indicated and the Content-Location header is set, but this is rarely implemented. (For example, Firefox does not support it per https://bugzilla.mozilla.org/show_bug.cgi?id=109553.) Other methods, like PUT or DELETE are not cacheable and their result cannot be cached.\n\t•\tThe status code of the response is known by the application caching, and it is considered cacheable. The following status code are cacheable: 200, 203, 204, 206, 300, 301, 404, 405, 410, 414, and 501.\n\t•\tThere is no specific headers in the response, like Cache-Control, that prevents caching.\nNote that some non-cacheable requests/responses to a specific URI may invalidate previously cached responses on the same URI. For example, a PUT to pageX.html will invalidate all cached GET or HEAD requests to the same URI.\nWhen both, the method of the request and the status of the response, are cacheable, the response to the request can be cached:\nGET /pageX.html HTTP/1.1\n(…) \n\n200 OK\n(…)\n\n\nA PUT request cannot be cached. Moreover, it invalidates cached data for request to the same URI done via HEAD or GET:\nPUT /pageX.html HTTP/1.1\n(…)\n\n200 OK\n(…)\n\nA specific Cache-Control header in the response can prevent caching:\nGET /pageX.html HTTP/1.1\n(…)\n\n200 OK\nCache-Control: no-cache\n(…)\n```\n- 206 - https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/206 - Partial Content\n- The 206 (Partial Content) status code indicates that the server is successfully fulfilling a range request for the target resource by transferring one or more parts of the selected representation that correspond to the satisfiable ranges found in the request's Range header field (Section 3.1).\n\n## HTTPS - SSL\n\n可见“升https”博文\n\n### Connection\n- https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Keep-Alive\n- (HTTP/2 does not use the Connection header field to indicate\n   connection-specific header fields)\n\n\n## JSON\n```\nJS object notation\n\n轻量级的数据交换格式\n相对于xml非常轻\n\n字符串是JSON的表现形式\n\n符合JSON格式的字符串叫JSON字符串\n\nXML\n\nJSON 易于阅读，解析，网络传输效率高，跨语言交换数据\n\n把语言写的东西做成服务，调用服务提供数据\n\nimport json\n\njson.loads(json_Str)\n\nJson字符串对应到python\n字典\n\nJSON object,array\n\n数组其实就是一个集合\n\n由字符串到某个语言下的数据结构（反序列化）\n\nJson\t\t\tpython\nobject\tdict\narray\t\t\tlist\nstring\tstr\nnumber \tint\nnumber\tfloat\ntrue\t\t\tTrue\nfalse\t\tFalse\nnull\t\t\tNone\n\n一种语言是其它语言的语法糖\n很多是C的语法糖\n语言就是一种工具\n\n序列化\nJson.dumps()\n\n终端其实看不大出来是不是字符串\n\n\n序列化之后直接存到mysql不太好，还是要弄成对象数据结构存，nosql(mongo) 可以存序列化之后的\n\nJSON 对象 （放在js中是成立的，但是放在python中，是没有的）\nJSON\nJSON 字符串\n\nJSON 也是ecmascirpt的一个实现\n\n\n\n\nA              \t\t\t\t\tJSON                 \t\t\t\tB\nA语言的数据类型\t\tJSON数据类型（中间数据类型）\tB语言的数据类型\n\nJSON有自己的数据类型，虽然它和javascirpt的数据类型有些相似\n\nREST服务的标准格式（JSON）\n\n```\n\n### 301 302\n\nHTTP状态码301和302都是重定向代码，但它们在使用场景上会有所不同：\n\n- 301 Moved Permanently：这是一个永久重定向，意味着资源已被永久移动至新的位置。你应该在以下场景使用301重定向：\n  - 当网站的URL结构被修改，原来的URL并不再使用时。\n  - 如果你的网站从HTTP升级到HTTPS。\n  - 如果你有两个相似的网页，并希望将其中一个合并到另一个页面，301重定向可以让你有效地将访问量和搜索引擎等级传递给新的页面。\n- 302 Found (HTTP 1.1) / Moved Temporarily (HTTP 1.0)：这是一个临时重定向，表示资源被临时移动到了新的位置，但在将来可能会返回到原来的位置。你应该在以下场景使用302重定向：\n  - 当你的网站或某个特定页面正在进行维护，你希望用户暂时访问备用页面时。\n  - 当进行A/B测试以分析网页性能时。\n\n在所有这些情况中，重定向均确保了用户能够找到他们试图访问的页面，同时保持页面的搜索引擎排名。\n\n### HAR\n- 用HTTP Archive（HAR）文件的一些开发过程。其中包括以下几个方面：\n\n1. **HAR Compilation**：这可能涉及创建和编译HAR文件。HAR文件是一种JSON格式的文件，它记录了浏览器和服务器之间的HTTP交互。这些文件可用于分析网络性能，定位问题等。\n\n2. **HAR Obfuscation**：这可能涉及对HAR文件中的特定信息进行混淆或移除。对于包含敏感信息的HAR文件，混淆处理在分享或公开这些文件时是非常必要的。\n\n3. **HAR Construction**：这可能涉及使用特定的编程语言或工具构造HAR文件。创建HAR文件需要对HTTP协议和相关的网络知识有一定的理解。\n\n4. **HAR Reference Parties Construction**：这可能涉及创建HAR参考方。具体的含义和用法可能依赖于特定的应用环境。\n   \n5. **Association of HAR editing**：这可能涉及在编辑HAR文件时建立与其他文件或数据的关联。这可能需要使用特定的编辑工具或程序库。\n\n\n### PROPFIND\nHTTP \"PROPFIND\"方法是对使用WebDAV协议的资源进行访问的一种方式。WebDAV协议是HTTP/1.1的扩展，它允许客户设备对网络存储空间进行读写操作。\n\nPROPFIND方法用于获取URI标识的资源属性，包括但不限于创建日期、修改日期、内容类型、内容长度等。这些属性被封装在一个XML中，并在PROPFIND响应中被返回。\n\n广泛使用的场景包括：\n1. 文件共享：比如在Dropbox, Google Drive等云存储服务中，客户端使用PROPFIND方法获取文件及文件夹的属性信息，如文件大小、最后修改时间等。\n\n2. 内容管理系统：如WordPress，用PROPFIND方法获取文章或页面的元数据。\n\n3. 在一些封装较复杂的Web服务中，客户端可以用PROPFIND请求获取资源的一些属性信息，如权限列表、协作者列表等。\n\n要注意的是，虽然PROPFIND方法在HTTP/1.1协议中已经被定义，但并非所有的Web服务器或HTTP client都实现了对PROPFIND的支持。","tags":["HTTP"]},{"title":"响应式","url":"/2016/09/12/响应式/","content":"> 目前做的都是复杂的web应用，其实不太会有响应式的需求，如果有要对端的支持，权衡成本收益，对投入端的开发，对开发的组件包的设计，具体的可能会做一些适配，大屏，中屏，小屏。\n\n* 文章指路：https://www.alistapart.com/articles/responsive-web-design/\n\n#### 名词解释:\n- portrait-横屏\n- landscape-竖屏\n- flexible layout-弹性布局\n\n* 一篇较好的文章指路：http://beforweb.com/node/6/page/0/2\n\n> 下面是以前实习时候，所里的一次小培训，让服务提供商讲的，天气很热，不太好吃的食堂，记的乱乱的笔记\n> comment: 现在看来不太具有参考意义了，但是能看出前端发展的进程\n\n- 名词：自适应、响应式\n- 手机版WebAPP页面制作\n\n#### 手机版应用分为三类：\n- WebApp（html5技术；又叫wap版；全平台通用）\n- NativeApp （android、ios专用开发平台，安装在手机上）\n- HybridApp （nativeapp+webapp）\n\n* comment:谁能想到后来到小程序呢，引流情况下的首选场景\n* comment:hybrid的模式总归是会存在的\n\n#### Webapp手机网页特点：\n- Html5按照横向320倍率等比放大页面全部元素，声明及页面信息如下：\n```\n<!doctype html>\n<html>\n<head>\n<meta charset=\"utf-8\">\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no\">\n<title>无标题文档</title>\n</head>\n```\n<pre>\nIphone的放大倍率：\n4-4s 326dpi (2x) 640 x 960  16：11接近4：3   2倍\n5-5s 326dpi (2x) 640 x 1136   16：9   2倍\n6 326dpi 750 x 1334   16：9   约2.3倍\n6plus 401dpi 1080 x 1920   16：9   约3.4倍\n</pre>\n\n- 要做成宽度自适应页面，考虑手机横屏问题。\n- 设计师在设计时为了保证图片的清晰度会设计640px甚至更高分辨率的页面，制作时切图按照设计师提供的分辨率切图片，写html是将图片高度换算成320px，对于背景是重复显示还是拉伸根据图片情况而定，会用到css3的background-size属性。\n- Js交互要符合手机操作方式 swiper3.0  （http://www.swiper.com.cn/）\n- 手机字体使用px，请根据设计分辨率换算成基准320分辨率下的字号，行距一般为字号的两倍。\n\n* comment:iphone已经11pro了，swiper已经6.0了（ https://swiperjs.com/）\n* comment:hybrid的模式总归是会存在的\n* comment:手机屏幕的尺寸也有了变革，也多了刘海儿\n\n#### 手机版CSS3全局样式初始化:\n```\nhtml, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td,\narticle, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video { margin:0; padding:0; border: 0;} a,area{blr:expression(this.onFocus=this.blur())} a { text-decoration:none;} a:hover { text-decoration:none;} html, body { font-family:Helvetica,\"微软雅黑\"; -webkit-text-size-adjust:none; -moz-text-size-adjust:none; -ms-text-size-adjust:none; text-size-adjust:none; } /*Reset Android and IOS font*/ input { border-radius:0; } /*Reset IOS input style*/ div, span, h1, h2, h3, h4, h5, h6, p, a, img, dl, dt, dd, ol, ul, li, form { list-style:none; } @-webkit-viewport { width:device-width; } @-moz-viewport { width:device-width; } @-ms-viewport { width:device-width; } @-o-viewport { width:device-width; } @viewport { width:device-width; } .boxcenter { margin:0 auto;} .fl_all { float:left; display:inline-block } .fr_all { float:right; display:inline-block }\n</pre>\n```\n* comment:其实是不推荐这种的，对样式的初始化，会造成之后的一些问题，这种全局的覆盖样式，如果自己写了组件包，包的表现形态会收到影响\n\n#### 响应式页面制作\nHtml5页面 + 手机版meta页面信息声明 + CSS3（兼容性问题，IE7-8可通过第三方插件兼容响应式）\n* comment:ie的问题现在除了特殊的行业和需要支持的场景，一般不再需要考虑了，有趣的是，一个做直播的朋友，PC端的，说其实他们还是需要支持IE，想到了乡土中国这本书，很有意思。\n\n#### @mediascreen查询语句：\n- 常用写法：\n\n```\n.container { max-width:1200px; min-width:980px; }\n.fl_pc { float:left; display:inline-block }\n.fr_pc { float:right; display:inline-block }\n.col_2in1 { width:50%; *width:49.9% }\n.col_3in1 { width:33.3% }\nbody{ background:#fff; } /*正常 白色 */\n@media screen and (max-width:992px){ body{ background:red; } } /*高度小于992px时 红色 */\n@media screen and (min-width: 768px) and (max-width: 991px){ body{ background:black; } } /*高度大于768px小于991时 黑色 */\n@media (max-width:767px) and (orientation: landscape){body{ background:green; } } /*高度小于767px且为竖屏时 绿色 适用于pad竖屏查询*/ 注意从上至下顺序，越往下优先级越高！\n```\n- CSS3初始化，在手机版基础上增加如下内容：\n```\n.col_4in1 { width:25%; *width:24.9% }\n.col_5in1 { width:20%; *width:19.9% }\n.col_6in1 { width:16.6% } .pchide { display:none; } .mhide { display:block; }\n/* screen 992 */\n@media screen and (max-width:992px){ .container { max-width:990px; min-width:300px; padding:0; } .fl_pc { float:none; display:block } .fr_pc { float:none; display:block } .col_2in1 { width:auto; *width:auto } .col_3in1 { width:auto  } .col_4in1 { width:auto; *width:auto } .col_5in1 { width:auto; *width:auto } .col_6in1 { width:auto } .pchide { display:block; } .mhide { display:none; } }\n```\n- 由手机清晰度引发的兼容性问题，ie8以下对css3不兼容：\n```\nbackground-size  解决办法，避免使用背景或使用@media hack： @media \\0screen\\,screen\\9 { @media screen and (max-width:992px){   .....   } }\n```\n- ie8以下对响应式不兼容：\n<!--[if lt IE 9]> <script type=\"text/javascript\" src=\"js/respond.js\"></script> <![endif]-->\na. 必须写在<link href=\"css/style.css\" rel=\"stylesheet\" type=\"text/css\" />所有样式表的下边，才能生效！\nb. 必须放到web服务器上才能生效。\n- respond.js（https://github.com/scottjehl/Respond/）\n\n* comment: 14年基本上就停止更新了，后面做了两次patch\n\n#### 动画减弱检测\n\n- https://developer.mozilla.org/zh-CN/docs/Web/CSS/@media/prefers-reduced-motion\n```\n@media (prefers-reduced-motion: no-preference) {\n  .App-logo {\n    animation: App-logo-spin infinite 20s linear;\n  }\n}\n```\n\n## flex\n- flexible box\n- flex container | flex item\n### 场景\n- 小程序开发\n- （View）容器默认宽度100%，高度自适应\n- 主轴 ｜ 交叉轴\n- flex-direction: row | column | row-reverse | column-reverse\n- justify-content: center | space-between平均分布 | space-around等距分布\n\n### display：inline-flex 会消除容器的块状属性\n\n\n\n","tags":["很久以前系列","HTML","响应式"]},{"title":"Extensible-Markup-Language-XML","url":"/2016/03/03/Extensible-Markup-Language-XML/","content":"\n#### doctype\n之前了解的都不细致，cookbook里面讲的很清楚，document type definition，文档类型声明\n\n为什么它要在第一行呢，因为是它告诉浏览器如何处理文档的，若非，则浏览器进入quirks mode,怪异模式，这样子代码就有可能无法正常运行了吼\n\n```\n<!DOCTYPE html>\n```\n\n奏是这么清爽，告诉浏览器处于标准模式下\n\n其实很早的时候也是超级简单的。\n\n#### 字符编码\n\nhead标记中第一行要包含字符集（charset）的声明,告诉浏览器应该如何解释这个文件。\n\n```\n<meta charset=\"utf-8\"/>\n<meta http-equiv=\"content-type\" content=\"text/html; charset=UTF-8\">\n```\n```\n指定文件兼容性模式\n<meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n```\n\n#### HTML5(降低标记markup，简化调用->不用加type了)\n\n- 语法编写风格->最好闭合所有标记，使用小写字母，用引号括属性\n- HTML5没有官方的验证服务。。。\n- validator.w3.org\n- html5.validator.nu\n\n\n#### H5\n\n1. 兼容性\n2. 文档结构\n3. Web APP Function\n\n#### 语法上的改进：\n\n- 内容类型\n- doctype声明\n- 指定字符编码\n- 可以省略标记的元素\n- 具有布尔值的属性\n- 省略引号\n\n#### 增加:\n\n结构上\n\n其他（video audio canvas）\n\ninput\n\n#### 废除：\n\n不再使用frame框架\n\n#### 增加:\n\n- 属性（表单，链接）\n- 全局属性：\ncontentEditable（boolean）\n\ndesignMode\n\nhidden（boolean）\n\nspellcheck\n\ntabindex(-1)\nallow focusing on any element: tabindex\n\n- 增加的主体结构元素\n\narticle（独立性）——>可嵌套，插件，内嵌页面，促进语义化\n\nsection（分段，分块）——>1.不要将其作为设置样式的页面容器。2.若article，aside，nav更合适，就放手让它们做吧。3.没有标题内容，不用section\n\nnav:传统导航条，侧边栏，页内，翻页操作\n\naside：article（内OR外）\n\ntime元素\n\n微格式\n\npubdate属性\n\n- 增加的非主体结构元素\n\nheader 可以出现多次\n\nfooter 作为其上层父级内容区块或是一个根区块的脚注\n\nhgroup 对多个相关联的H1，H6标题进行分组\n\naddress 在文档中呈现联系信息\n\npoint.1 显示（隐式）编排内容区域块\n\n- 标题分级\n\n- 不同区域块使用相同标题\n\n- 表单新增元素与属性\n\nform\n\nformaction\n\nformmethod\n\nformenctype\n\nformtarget(在何处打开)\n\nautofocus\n\nrequired\n\nlabels\n\n- 标签的control属性\n\n- 文本框的placeholder属性\n\n- 文本框的list属性\n\n- 文本框的autocomplete属性\n\n- pattern属性（正则验证）\n\n- 文本框的selectionDirection属性->获取用户操作\n\n- 复选框的indeterminate属性\n\n- image提交按钮的height与width属性\n\n### 聊一聊html中有趣的属性\n\n#### map area\nMDN指路：https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/map\n\nHTML <map> 属性 与 <area> 属性一起使用来定义一个图像映射(一个可点击的链接区域).\n\nname属性 给map一个名字用来查询，这个属性是必须的，值必须不能为空并且不能带空格。name属性不准与同文档中其他map元素的值相同，如果id属性也被添加，name属性和id属性的值必须相同。\n\n\n<map name=\"example-map-1\">\n  <area shape=\"circle\" coords=\"200,250,25\" href=\"another.htm\" />\n  <area shape=\"default\" />\n</map>\n\n\n\n#### Deprecated Tags / Deprecated Attributes\n","tags":["很久以前系列","HTML"]},{"title":"SDN","url":"/2015/12/15/SDN/","content":"> Let's define some terminology(术语), starting with terminal types(终端类型):\n\n- VirtualBox console terminal: connects to OpenFlowTutorial. This is the one created when you started up the VM. You can't copy and paste from this tutorial page to the console terminal, so it's a bit of a pain.Minimize this NOW, if you haven't already done so. Once you've used it to set up networking, it won't be needed.\n\n- SSH terminal: connects to OpenFlowTutorial. Created by using putty on Windows or SSH on OS X / Linux, as described in the previous section. Copy and paste should work on this terminal.\n\n- xterm terminal: connects to a host in the virtual network. Created in the next section when you start up the virtual network. Will be labeled at the top with the name of the host.\n\n- The OpenFlowTutorial VM includes a number of OpenFlow-specific and general networking utilities pre-installed. Please read the short descriptions:\n\n- OpenFlow Controller: sits above the OpenFlow interface. The OpenFlow reference distribution includes a controller that acts as an Ethernet learning switch in combination with an OpenFlow switch. You'll run it and look at messages being sent. Then, in the next section, you'll write our own controller on top of NOX or Beacon (platforms for writing controller applications).\n\n- OpenFlow Switch: sits below the OpenFlow interface. The OpenFlow reference distribution includes a user-space software switch. Open vSwitch is another software but kernel-based switch, while there is a number of hardware switches available from Broadcom (Stanford Indigo release), HP, NEC, and others.\n\n- dpctl: command-line utility that sends quick OpenFlow messages, useful for viewing switch port and flow stats, plus manually inserting flow entries.\n\n- Wireshark: general (non-OF-specific) graphical utility for viewing packets. The OpenFlow reference distribution includes a Wireshark dissector, which parses OpenFlow messages sent to the OpenFlow default port (6633) in a conveniently readable way.\n\n- iperf: general command-line utility for testing the speed of a single TCP connection.\n\n- Mininet: network emulation platform. Mininet creates a virtual OpenFlow network - controller, switches, hosts, and links - on a single real or virtual machine. More Mininet details can be found at the Mininet web page.\n\n- cbench: utility for testing the flow setup rate of OpenFlow controllers.\n\n#### mininet指路：\n- https://github.com/mininet/mininet/\n- http://mininet.org/walkthrough\n\n#### mininet 的命令:\n注意:\nCleanup —— If Mininet crashes for some reason, clean it up:\n```\n$ sudo mn -c\n```","tags":["很久以前系列","ComputerNetwork"]},{"title":"计网RIP","url":"/2015/12/01/计网RIP/","content":"\n> 前段时间计算机网络实验课，老师说最后考的主要是RIP这部分，所以原理多看了看。\n    \n\nRIP，全称是路由信息协议，是TCP/IP环境下开发出的第一款内部网关路由协议。1988年被写入RFC1058。\n有类、距离矢量动态路由协议。\n\n    回忆有类和无类的概念：\n\n\t- 有类代表这个网络是按照主类进行计算，路由的传递不携带子网掩码，不能进行VLSM和CIDR：RIPv1\n\t- 无类代表这个网络不是按照主类进行计算，路由的传递携带子网掩码，可以进行VLSM和CIDR：RIPv2\n\n距离矢量代表这个网络是按照传闻进行计算，每个路由器只知道目的网段的距离，路由的传递不携带结构信息，最短距离基于传闻：RIP、EIGRP、BGP      \n    \n链路状态代表这个网络是按照结构进行计算，区域内每个路由器都知道本域内的结构信息，最短距离基于SPF运算：OSPF\n      \n### RIP路由协议概述— RIP介绍\n- 通过UDP进行封装，端口为520。      \n- 数据包分为两种：request和response，周期性更新。- 管理距离为120，metric为跳数，16跳不可达。\n- RIP公有的计时器有三个：update、invalid、flush\n\t- update：更新计时器，30s，RIP进程开始时计时，到期发送整个路由表（除水平分割内容外），永远持续。\n\t- invalid：失效计时器，180s，当相邻路由器发送的更新表项中存在这个路由条目时开始计时，到期显示possibly down，再次收到这个条目时重置\n\t- flush：刷新计时器，240s，当相邻路由器发送的更新表项中存在这个路由条目时开始计时，到期删除路由，再次收到这个条目时重置\n- RIP的防环机制有六个：水平分割、最大跳数、路由毒化、毒性逆转、抑制更新计时器、触发更新\n\t- 水平分割：从某个接口收到的路由信息，不会从这个接口再发出去\n\t- 最大跳数：无论如何，RIP的路由条目在16跳时，就认为不可达\n\t- 路由毒化：一旦得知网段发生断连，则将网段路由条目的跳数记为16跳\n\t- 毒性逆转：当得到一个16跳的路由条目，就马上从收到的端口发回该16跳的条目\n\t- 抑制更新计时器：一个条目失效后，如果从原更新源出现了该条目更新，则抑制180s\n\t- 触发更新：一个条目发生变化后，无视周期性更新，直接将变化后的条目发出\n\n\n### RIPv1和RIPv2的数据包结构\n\t- 不连续子网\n\t- 兼容\n\t- RIPv1使用广播更新，地址为255.255.255.255，自动边界汇总，不可关闭；\n\t- RIPv2使用组播更新，地址为224.0.0.9，自动边界汇总，可以关闭。\n\n\n      在很多非以太网络中，链路的带宽不高，路由的周期性更新会对数据的传递造成较大影响，所以希望降低更新对链路的影响。\n\n<strong>解决的办法：</strong>\n- 增加周期性更新的更新计时器\n- 设置触发更新\n### 配置：\n```\nrouter(config)#interface serial0/0\nrouter(config-if)#ip rip triggered\n```\n\n\t\t\n### open system interconnection reference model (OSI) vs TCP/IP\n- TCP/IP\n- 应用程序 - 操作系统 - 设备驱动网络接口\n- 应用层 - HTTP DNS FTP SSH TELNET\n\n### 以太网\nRobert Metcalfe | Xerox Alto\n论文 - 以太网：本地计算机网络的分布式交换\n网卡 \nMac地址","tags":["很久以前系列","ComputerNetwork"]}]